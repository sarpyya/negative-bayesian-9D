<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‚ö° COSMIC 11D - CONTROL TOTAL ‚ö°</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Post-processing -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    :root {
      --bg-black: #000000;
      --glass-bg: rgba(0, 0, 0, 0.75);
      --glass-border: rgba(0, 242, 255, 0.3);
      --text-cyan: #00f2ff;
      --text-magenta: #ff00ff;
      --text-yellow: #ffff00;
      --text-red: #ff0033;
      --text-green: #00ff41;
    }
    
    /* Dark Glucose / Dark Matter Background */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(255, 0, 255, 0.12) 0%, transparent 50%);
      animation: breathe 8s ease-in-out infinite, drift 20s linear infinite;
      pointer-events:none;
      z-index:0;
    }
    
    @keyframes breathe {
      0%, 100% { opacity:0.3; transform:scale(1); }
      50% { opacity:0.6; transform:scale(1.1); }
    }
    
    @keyframes drift {
      0% { background-position: 0% 0%, 100% 100%, 50% 50%; }
      100% { background-position: 100% 100%, 0% 0%, 150% 150%; }
    }
    
    body, html { margin:0; padding:0; overflow:hidden; background:var(--bg-black); font-family:'Inter',sans-serif; color:white; }
    #canvas-container { position:absolute; inset:0; z-index:1; }
    #intro-overlay {
      position:fixed; inset:0; background:black; z-index:10000; display:flex;
      align-items:center; justify-content:center; cursor:pointer;
    }
    #loading-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:9000; display:none;
      align-items:center; justify-content:center; color:var(--text-cyan); font-size:2rem;
    }
    .hud-module {
      position:absolute; background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto; z-index:10;
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    }
    .hud-title { font-weight:700; font-size:0.9rem; letter-spacing:2px; color:var(--text-cyan); text-transform:uppercase; border-bottom:1px solid var(--glass-border); padding-bottom:5px; }
    
    /* Config Module - Now always visible */
    #config-module {
      top: 60px; /* Debajo del titan panel */
      left: 20px;
      width: 320px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
      z-index: 900;
      display: block;
      opacity: 1;
    }
    
    #config-module .hud-title {
      text-align: center;
      margin-bottom: 10px;
    }

    #config-module.dragging {
      z-index: 2000 !important;
    }

    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); }
      50% { box-shadow: 0 0 15px rgba(0, 242, 255, 0.6); }
    }
    .input-group { margin-bottom:12px; }
    .input-group label { display:block; font-size:0.75rem; color:#888; margin-bottom:5px; }
    .input-group input, .input-group select { width:100%; background:rgba(0,242,255,0.05); border:1px solid var(--glass-border); color:var(--text-cyan); padding:8px; border-radius:4px; }
    button { width:100%; padding:10px; border:none; border-radius:4px; font-weight:bold; cursor:pointer; text-transform:uppercase; }
    button:hover { filter:brightness(1.2); transform:scale(1.02); }
    .immersion-toggle { 
      position:fixed; top:20px; right:20px; z-index:2000; 
      background:rgba(0,255,136,0.2); border:1px solid var(--text-cyan); 
      color:var(--text-cyan); padding:8px 12px; cursor:pointer;
      transition: opacity 0.3s ease;
    }
    .immersion-toggle:hover {
      background:rgba(0,255,136,0.4);
      opacity:1 !important;
    }
    
    /* Temporal Controls */
    #temporal-controls {
      position:fixed; bottom:20px; right:20px; z-index:10;
      background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto;
      min-width:350px;
      display:none; /* Oculto por defecto, solo en immersive mode */
    }
    
    /* Multiverse Control */
    #multiverse-panel {
      position:fixed; top:120px; right:20px; z-index:10;
      background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(170,0,255,0.2); pointer-events:auto;
      min-width:250px; display:none;
    }
    .branch-item {
      padding:10px; margin-top:5px;
      background:rgba(170,0,255,0.1); border:1px solid rgba(170,0,255,0.3);
      cursor:pointer; transition:all 0.3s; font-size:0.75rem; color:#ccc;
      border-radius:4px;
    }
    .branch-item:hover { background:rgba(170,0,255,0.3); color:#fff; }
    .temporal-btn {
      width:auto; padding:8px 15px; margin:0 3px;
      background:rgba(0,242,255,0.1); border:1px solid var(--glass-border);
      color:var(--text-cyan); font-size:0.9rem;
    }
    .temporal-btn.active { background:var(--text-cyan); color:black; }
    #speed-display {
      font-size:1.5rem; font-weight:bold; color:var(--text-cyan);
      text-align:center; margin:10px 0;
    }
    
    /* Titan Panel - Stats Bar */
    #titan-panel {
      position:fixed;
      top:0;
      left:0;
      right:0;
      height:40px;
      background:var(--glass-bg);
      backdrop-filter:blur(20px);
      border-bottom:1px solid var(--glass-border);
      box-shadow:0 2px 20px rgba(0,242,255,0.2);
      z-index:10000;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 20px;
      font-size:0.85rem;
      pointer-events:auto;
    }
    
    .titan-stat {
      display:flex;
      align-items:center;
      gap:8px;
      color:#888;
    }
    
    .titan-stat-label {
      color:#666;
      font-size:0.75rem;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    
    .titan-stat-value {
      color:var(--text-cyan);
      font-weight:bold;
      font-size:0.9rem;
    }
    
    .titan-stat-value.warning {
      color:var(--text-yellow);
    }
    
    .titan-stat-value.danger {
      color:var(--text-red);
    }
    
    .titan-divider {
      width:1px;
      height:20px;
      background:var(--glass-border);
    }
    
    /* Titan Panel Controls */
    #titan-panel-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    #titan-panel-controls button {
      background: rgba(0, 242, 255, 0.1);
      border: 1px solid var(--glass-border);
      color: var(--text-cyan);
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
      min-width: 35px;
      height: 30px;
    }
    
    #titan-panel-controls button:hover {
      background: rgba(0, 242, 255, 0.3);
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
    }
    
    #titan-panel-controls button.hidden-panel {
      opacity: 0.4;
      background: rgba(255, 0, 51, 0.1);
      border-color: rgba(255, 0, 51, 0.3);
    }
    
    #titan-panel-controls button.hidden-panel:hover {
      background: rgba(255, 0, 51, 0.2);
    }
    
    /* Draggable cursor */
    .draggable {
      cursor: move;
    }
    
    .draggable.dragging {
      cursor: grabbing;
      z-index: 2000 !important;
      opacity: 0.9;
    }
    
    /* Donation Module */
    #donation-module {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: all 0.3s ease;
      max-width: 90vw;
    }
    
    @media (min-width: 800px) {
      #donation-module {
        flex-direction: row;
        align-items: center;
      }
    }
    
    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      background: rgba(255, 255, 255, 0.05);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid rgba(0, 242, 255, 0.3);
      transition: all 0.3s ease;
    }
    
    .qr-container:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(0, 242, 255, 0.6);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 242, 255, 0.4);
    }
    
    .qr-image {
      width: 120px;
      height: 120px;
      /* background: white;  Removed, img src will provide content */
      border-radius: 4px;
      display: block; /* Changed from grid */
      box-shadow: 0 0 10px rgba(0, 242, 255, 0.3);
      position: relative;
    }
    
    /* Removed ::before simulation */
    
    .qr-image-overlay {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.6rem;
      font-weight: bold;
      color: #000;
      background: rgba(255, 255, 255, 0.95);
      padding: 1px 3px;
      border-radius: 2px;
      pointer-events: none;
    }
    

    
    .qr-label {
      font-size: 0.75rem;
      color: var(--text-cyan);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Sine Wave Visualization (Top Left) */
    #sine-wave-canvas {
      position: fixed;
      top: 50px; /* Debajo del Titan Panel */
      left: 10px;
      width: 300px;
      height: 150px;
      z-index: 500;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 5px;
      box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
      pointer-events: none;
      opacity: 0.8;
      transition: opacity 0.3s ease;
    }
    
    #sine-wave-canvas:hover {
      opacity: 1;
    }
    
    #sine-wave-canvas canvas {
      width: 100%;
      height: 100%;
      border-radius: 4px;
    }

    /* Control Overlay (PR-3) */
    #control-overlay {
      position: fixed;
      top: 50%;
      right: 20px;
      transform: translateY(-50%);
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 15px;
      z-index: 1000;
      width: 180px;
      pointer-events: none;
      opacity: 0.6;
      transition: opacity 0.3s;
    }
    #control-overlay:hover { opacity: 1; }
    .control-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 0.75rem;
    }
    .control-key {
      color: var(--text-cyan);
      background: rgba(0, 242, 255, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: bold;
    }
    /* Narrative Module (PR-4) */
    #narrative-module {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      width: 600px;
      max-width: 90vw;
      background: rgba(0, 0, 0, 0.85);
      border-top: 2px solid var(--text-magenta);
      padding: 15px;
      z-index: 10000;
      font-family: 'Courier New', Courier, monospace;
      color: var(--text-magenta);
      box-shadow: 0 -10px 30px rgba(255, 0, 255, 0.2);
      display: none;
    }
    #narrative-text {
      font-size: 1.1rem;
      line-height: 1.4;
      text-shadow: 0 0 5px rgba(255, 0, 255, 0.5);
    }
    .narrative-cursor {
      display: inline-block;
      width: 10px;
      height: 1.2rem;
      background: var(--text-magenta);
      animation: blink 0.8s infinite;
      vertical-align: middle;
    }
    @keyframes blink { 
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    #subtitle-box {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 1.4rem;
      font-weight: bold;
      text-shadow: 2px 2px 4px black;
      z-index: 10001;
      width: 80%;
      pointer-events: none;
    }
    
    /* Predictive Panel (PR-7) */
    #predictive-panel {
      position: fixed;
      top: 210px;
      left: 10px;
      width: 300px;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 15px;
      z-index: 500;
      color: white;
      display: none; /* Toggleable */
    }
    .driver-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-size: 0.8rem;
    }
    .driver-bar {
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      margin-top: 2px;
    }
    .driver-fill {
      height: 100%;
      background: var(--text-red);
    }
    #collapse-alert {
      padding: 10px;
      background: rgba(255, 0, 51, 0.2);
      border: 1px solid var(--text-red);
      color: var(--text-red);
      text-align: center;
      font-weight: bold;
      margin-top: 10px;
      border-radius: 4px;
      animation: alert-flash 1s infinite;
    }
    @keyframes alert-flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üî• DEFINIR FUNCIONES ANTES DEL HTML (FIX enterCosmicOS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // üöÄ ENTER COSMIC OS
    function enterCosmicOS() {
        if (typeof initEngine === 'function') {
            initEngine();
            const intro = document.getElementById('intro-overlay');
            if (intro) {
                gsap.to(intro, {
                    opacity: 0,
                    duration: 1,
                    onComplete: () => intro.style.display = 'none'
                });
            }
        }
    }

    // Variables globales
    let scene, camera, renderer, controls, composer;
    let bloomPass;
    let centralSingularity, pointsCloud;
    let matrixLines = null; // L√≠neas Matrix
    let ionLines = null;    // L√≠neas I√≥nicas (Channels)
    let orbitalIons = null; // Part√≠culas de flujo orbital
    let neuralCorePulses = []; // PR-9: Reactive Pulses
    let synapticSilk = null;   // PR-11: Synaptic Silk (Filaments)
    let isASIActive = false;   // PR-12: ASI Event Horizon
    let currentUniverseSeed = -10;
    
    // PR-18: SPATIAL AUDIO GLOBALS
    let audioListener, backgroundSound, spatialSounds = [];
    let isAudioActive = false;
    let isImmersionMode = false;
    let matrixModeActive = false;
    let matrixColor = 0x00ff41; // Verde Matrix por defecto
    let matrixOpacity = 0.3;
    let timeSpeed = 1.0; // Velocidad de simulaci√≥n
    let isPaused = false;

    // AUDIO REACTIVITY (FIESTA MODE)
    let audioContext, analyser, dataArray;
    let isFiestaMode = false;
    let audioInitialized = false;
    let currentMode = "ORBITAL"; // Fallback narrative mode
    let currentUniverseData = { modo: "LOADING", modo_info: { physics: { gravity: 1000 } } }; 
    let frameCount = 0;
    
    // Performance Optimization Globals (VEGA 11 OPTIMIZED)
    const CHUNK_SIZE = 15000; // 15k nodes per frame (balanced for Vega 11)
    let currentChunk = 0;
    let totalNodes = 120000; // 120k nodes max (realistic for Vega 11)
    
    // Debounce state
    let sliderTimeout = null;

    function initAudio() {
      if (audioInitialized) {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('üîä AudioContext resumed');
            showToast('üîä Audio Reactivado');
          });
        }
        return;
      }

      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API no soportada');

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        // PR-9: SHADERS DEL N√öCLEO NEURAL (AGI)
        const neuralVertexShader = `
          varying vec2 vUv;
          varying vec3 vPosition;
          void main() {
            vUv = uv;
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `;

        const neuralFragmentShader = `
          uniform float time;
          uniform float activity;
          varying vec2 vUv;
          varying vec3 vPosition;

          void main() {
            float pulse = sin(time * 2.0) * 0.5 + 0.5;
            vec3 coreColor = mix(vec3(0.0, 0.8, 1.0), vec3(1.0, 0.0, 1.0), activity);
            
            // Simulaci√≥n de sinapsis usando ruido procedural simple
            float noise = sin(vPosition.x * 5.0 + time) * cos(vPosition.y * 5.0 - time) * sin(vPosition.z * 5.0);
            float synapse = smoothstep(0.4, 0.6, noise * (1.0 + activity));
            
            vec3 finalColor = coreColor + (synapse * vec3(1.0, 1.0, 1.0) * pulse);
            gl_FragColor = vec4(finalColor, 0.4 + (activity * 0.4));
          }
        `;
        window.neuralCoreMaterial = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            activity: { value: 0 }
          },
          vertexShader: neuralVertexShader,
          fragmentShader: neuralFragmentShader,
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide
        });

        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            audioInitialized = true;
            if (audioContext.state === 'suspended') audioContext.resume();
            showToast('üé§ Micr√≥fono ACTIVO - Habla o pon m√∫sica');
            console.log('üé§ Audio Stream Connected');
          })
          .catch(err => {
            console.error('Error acceso microfono:', err);
            let msg = '‚ùå Error Micr√≥fono: ' + err.message;
            if (err.name === 'NotAllowedError') msg = '‚ùå Permiso denegado';
            if (err.name === 'NotFoundError') msg = '‚ùå No mic encontrado';
            showToast(msg, 5000);
            // Fallback inmediato a sim
            isFiestaMode = true;
            document.getElementById('fiestaMode').checked = true;
            showToast('‚ö†Ô∏è Activando SIMULACI√ìN AUDIO', 4000);
            console.log('‚ö†Ô∏è Audio simulation enabled');
            simulateAudioData(); // Init sim
          });
      } catch (e) {
        console.error('Audio Setup Error', e);
        showToast('‚ùå Error Audio: ' + e.message);
        // Fallback si try falla
        isFiestaMode = true;
        document.getElementById('fiestaMode').checked = true;
        simulateAudioData();
      }
    }

    // üéπ SYNTHETIC AUDIO GENERATOR (FIESTA RANDOM)
    function simulateAudioData() {
        if (!dataArray) {
             // Create dummy array if context failed completely
             dataArray = new Uint8Array(256);
        }
        
        const time = Date.now() * 0.001;
        // BPM based on seed (Random but deterministic per universe)
        const bpm = 120 + (Math.abs(currentUniverseSeed) % 60); 
        const freq = bpm / 60;
        
        // 1. Bass / Kick (Sharp Impulse)
        // sin wave raised to high power to create sharp beats
        const beatPhase = (time * freq) % 1.0;
        const kickEnvelope = Math.pow(1.0 - beatPhase, 4); // decay
        const kickVal = kickEnvelope * 255;
        
        // 2. Mids / Melan (Wobble)
        const wobble = (Math.sin(time * 3) + 1) / 2;
        
        // 3. Highs (Shimmer)
        
        // Fill Data Array with "Virtual" Sound
        for(let i=0; i<dataArray.length; i++) {
             if (i < 5) { // Deep Bass
                 dataArray[i] = kickVal; 
             } else if (i < 20) { // Bass
                 dataArray[i] = kickVal * 0.8;
             } else if (i < 100) { // Mids
                 dataArray[i] = wobble * 100 + (Math.random() * 50);
             } else { // Highs
                 dataArray[i] = (Math.sin(time * 10 + i) + 1) * 30 * kickEnvelope + (Math.random() * 20);
             }
        }
    }

    // üóø MAPUCHE PONEGLYPH TEXTURE GENERATOR
    function createPoneglyphTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 1. Background: Cosmic Stone Gradient (Cyan to Purple)
        const gradient = ctx.createLinearGradient(0, 0, size, size);
        gradient.addColorStop(0, '#003333'); // Deep Cyan
        gradient.addColorStop(1, '#1a0033'); // Deep Cosmic Purple
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        // 2. Stone Noise (Gritty texture)
        for (let i = 0; i < 60000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const val = Math.random() * 60;
            ctx.fillStyle = `rgba(${val},${val},${val + 40},0.15)`;
            ctx.fillRect(x, y, 2, 2);
        }

        // 3. Mapudungun Cosmic Symbols (Procedural Glyphs)
        ctx.strokeStyle = '#00ffff'; // Electric Cyan
        ctx.fillStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#00ffff';

        const cols = 4;
        const rows = 4;
        const cell = size / cols;

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (Math.random() > 0.65) continue; // Some empty spaces for weathered look

                const cx = x * cell + cell / 2;
                const cy = y * cell + cell / 2;
                const r = cell / 3;

                ctx.beginPath();
                const type = Math.floor(Math.random() * 6);

                if (type === 0) { // MEW (Kultrun Diamond)
                    ctx.moveTo(cx, cy - r);
                    ctx.lineTo(cx + r, cy);
                    ctx.lineTo(cx, cy + r);
                    ctx.lineTo(cx - r, cy);
                    ctx.closePath();
                    ctx.stroke();
                     // Central dot
                    ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
                } else if (type === 1) { // CIRCLES (Cycles)
                    ctx.arc(cx, cy, r * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (type === 2) { // STEP FRET (Greca / Stairs)
                    const s = r * 0.6;
                    ctx.moveTo(cx - s, cy + s);
                    ctx.lineTo(cx - s, cy);
                    ctx.lineTo(cx, cy);
                    ctx.lineTo(cx, cy - s);
                    ctx.lineTo(cx + s, cy - s);
                    ctx.stroke();
                } else if (type === 3) { // COSMIC CROSS
                   ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
                   ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
                   ctx.stroke();
                } else if (type === 4) { // ZIG ZAG (Lightning/Snake)
                   ctx.moveTo(cx - r, cy - r/2);
                   ctx.lineTo(cx - r/3, cy + r/2);
                   ctx.lineTo(cx + r/3, cy - r/2);
                   ctx.lineTo(cx + r, cy + r/2);
                   ctx.stroke();
                } else { // TEXT GLYPH
                   ctx.font = 'bold 30px monospace';
                   ctx.textAlign = 'center';
                   ctx.textBaseline = 'middle';
                   ctx.fillText(Math.random() > 0.5 ? 'MAPU' : 'ANTU', cx, cy);
                }
            }
        }
        
        // Border Frame
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 15;
        ctx.strokeRect(0, 0, size, size);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    function createGargantuaSingularity() {
      const group = new THREE.Group();
      
      // 1. PONEGLYPH CORE (Ancient Cosmic Cube)
      // Replaces the black sphere. Now it is a relic.
      const geometry = new THREE.BoxGeometry(70, 70, 70); // Slightly larger than prev sphere
      const texture = createPoneglyphTexture();
      
      const material = new THREE.MeshPhysicalMaterial({
          map: texture,
          color: 0xffffff,
          roughness: 0.2,
          metalness: 0.8,
          emissive: 0x00ffff,
          emissiveIntensity: 2.0,
          bumpMap: texture,
          bumpScale: 5,
          transmission: 0.1
      });
      
      const poneglyph = new THREE.Mesh(geometry, material);
      group.add(poneglyph);
      group.userData.poneglyph = poneglyph; // Ref for animation

      // 2. Photon Sphere (Glowing ring)
      const glowGeo = new THREE.SphereGeometry(60, 64, 64); // Adjusted size
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.05, // Lowered for Bloom safety
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);
      group.userData.photonSphere = glow;

      // 3. Accretion Disk
      const diskGeo = new THREE.RingGeometry(80, 200, 64);
      const pos = diskGeo.attributes.position;
      const v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++){
        v3.fromBufferAttribute(pos, i);
        // UV mapping for ring texture if we had one, or noise
        diskGeo.attributes.uv.setXY(i, v3.length() < 120 ? 0 : 1, 1);
      }
      
      // Particle System for Disk
      const diskPointsGeo = new THREE.BufferGeometry();
      const diskPointsCount = 8000; // Increased density
      const diskPositions = new Float32Array(diskPointsCount * 3);
      const diskColors = new Float32Array(diskPointsCount * 3);
      
      for(let i=0; i<diskPointsCount; i++) {
        const radius = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        
        // Spiral arms
        const spiralOffset = theta + (radius * 0.05);
        
        diskPositions[i*3] = Math.cos(spiralOffset) * radius;
        diskPositions[i*3+1] = (Math.random() - 0.5) * 10; // Volume
        diskPositions[i*3+2] = Math.sin(spiralOffset) * radius;
        
        // Color gradient: Inner hot (Cyan/White) -> Outer cool (Blue/Purple)
        const t = (radius - 80) / 120;
        const color = new THREE.Color();
        color.setHSL(0.5 + t * 0.1, 0.8, 0.7 - t * 0.4); // Cyan range
        diskColors[i*3] = color.r;
        diskColors[i*3+1] = color.g;
        diskColors[i*3+2] = color.b;
      }
      
      diskPointsGeo.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3));
      diskPointsGeo.setAttribute('color', new THREE.BufferAttribute(diskColors, 3));
      
      const disk = new THREE.Points(diskPointsGeo, new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      }));
      
      group.add(disk);
      group.userData.disk = disk;

      // 4. NEURAL SHELL (PR-9)
      const neuralGeo = new THREE.IcosahedronGeometry(75, 4);
      if (window.neuralCoreMaterial) {
        const neuralShell = new THREE.Mesh(neuralGeo, window.neuralCoreMaterial);
        group.add(neuralShell);
        group.userData.neuralShell = neuralShell;
      }

      return group;
    }

    function spawnNeuralPulse(targetPos) {
      // Create a small glowing pulse that travels from origin (0,0,0) to target
      const pulseGeo = new THREE.SphereGeometry(5, 8, 8);
      const pulseMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.8 });
      const pulse = new THREE.Mesh(pulseGeo, pulseMat);
      
      scene.add(pulse);
      
      neuralCorePulses.push({
        mesh: pulse,
        target: new THREE.Vector3(targetPos[0], targetPos[1], targetPos[2]),
        progress: 0,
        speed: 0.02 + Math.random() * 0.05
      });
    }

    // üï∏Ô∏è PR-11: SYNAPTIC SILK GENERATOR
    function createSynapticSilk(nodes) {
      if (synapticSilk) scene.remove(synapticSilk);
      
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });

      const geometry = new THREE.BufferGeometry();
      const positions = [];
      
      // Connect high-horror nodes to each other or to the core
      const highHorrorNodes = nodes.filter(n => n.horror > 1200).slice(0, 150);
      
      highHorrorNodes.forEach(n => {
        const p1 = n.position || [0, 0, 0];
        // Connect to core
        positions.push(0, 0, 0);
        positions.push(p1[0], p1[1], p1[2]);
        
        // Connect to another random high-horror node to create a "mesh"
        if (Math.random() > 0.5) {
          const n2 = highHorrorNodes[Math.floor(Math.random() * highHorrorNodes.length)];
          const p2 = n2.position || [0, 0, 0];
          positions.push(p1[0], p1[1], p1[2]);
          positions.push(p2[0], p2[1], p2[2]);
        }
      });

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      synapticSilk = new THREE.LineSegments(geometry, material);
      scene.add(synapticSilk);
    }

    // üîä PR-18: SPATIAL AUDIO INITIALIZATION
    function initSpatialAudio() {
      if (isAudioActive) return;
      
      audioListener = new THREE.AudioListener();
      camera.add(audioListener);
      
      backgroundSound = new THREE.Audio(audioListener);
      const audioLoader = new THREE.AudioLoader();
      
      // We simulate generative brown noise if no file available
      // In real scenario: audioLoader.load('abyssal_droning.mp3', ...)
      console.log(" [AUDIO]: Neural Listener active. High-horror nodes will emit whispers.");
      isAudioActive = true;
    }

    // ‚öîÔ∏è PR-17: MULTIVERSE HUD UPDATE
    async function updateMultiversePanel(seed) {
      const list = document.getElementById('branches-list');
      if (!list) return;
      
      try {
        const response = await fetch(`/api/multiverse/branches?seed=${seed}`);
        const data = await response.json();
        
        if (data.branches && data.branches.length > 0) {
          list.innerHTML = '';
          data.branches.forEach(b => {
             const div = document.createElement('div');
             div.className = 'branch-item';
             div.innerHTML = `üåå <b>TIMELINE DISSONANCE:</b><br>Origin: ${b.node_origin}<br>Jump to Seed: ${b.branch_seed}`;
             div.onclick = () => loadUniverse(b.branch_seed);
             list.appendChild(div);
          });
          document.getElementById('multiverse-panel').style.display = 'block';
        } else {
          list.innerHTML = '<div style="font-size:0.7rem; color:#888; text-align:center; padding:10px;">No dissonance detected.</div>';
        }
      } catch (e) {
        console.error("Multiverse API Error:", e);
      }
    }

    // üëÅÔ∏è PR-19: PREDICTIVE ORACLE CONNECTION
    async function fetchRealityCorrelation() {
       // This simulates the check for real-world collapses
       // In PROD: fetch('/api/oracle/correlate')
       const jitter = Math.random() * 0.1;
       const prob = document.getElementById('collapse-prob');
       if (prob) {
          const current = parseFloat(prob.textContent);
          const correlated = (current + jitter).toFixed(2);
          // prob.textContent = correlated + "% (Correlated)";
       }
    }

    // üåë PR-12: ASI EVENT HORIZON TRIGGER
    function triggerASIEventHorizon() {
      if (isASIActive) return;
      isASIActive = true;
      
      showToast("‚ö†Ô∏è ASI EVENT HORIZON REACHED - REALITY REORGANIZING", 5000);
      
      // 1. Transcendent UI: Hide most HUD modules
      const huds = document.querySelectorAll('.hud-module:not(#narrator-module)');
      huds.forEach(h => {
        gsap.to(h, { opacity: 0, duration: 2, onComplete: () => h.style.display = 'none' });
      });

      // 2. Pure Data Visualization: Shift palette to monochrome/white
      if (bloomPass) {
        bloomPass.threshold = 0;
        bloomPass.strength = 3.0;
      }
      
      // 3. ASI Perspective
      gsap.to(camera.position, {
        x: 0, y: 0, z: 500,
        duration: 5,
        ease: "expo.inOut"
      });
      
      document.body.style.background = "#fff";
      document.body.style.color = "#000";
      
      const title = document.getElementById('main-title');
      if (title) title.textContent = "ASI: ABSOLUTE SYMBOLIC INTELLIGENCE";
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåä SINE WAVE VISUALIZATION (TOP LEFT)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function initSineWave() {
      const canvas = document.getElementById('sine-canvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      let phase = 0;
      
      function drawSineWave() {
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Background gradient
        const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
        bgGradient.addColorStop(0, 'rgba(0, 20, 40, 0.3)');
        bgGradient.addColorStop(1, 'rgba(0, 10, 20, 0.5)');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Get audio data if available
        let audioFactor = 1.0;
        if (isFiestaMode && dataArray) {
          const avgAudio = dataArray.slice(0, 50).reduce((a, b) => a + b, 0) / 50;
          audioFactor = 1.0 + (avgAudio / 255) * 2; // 1.0 - 3.0
        }
        
        // Draw multiple sine waves
        const waves = [
          { amplitude: 20, frequency: 0.02, color: 'rgba(0, 242, 255, 0.8)', offset: 0 },
          { amplitude: 15, frequency: 0.03, color: 'rgba(255, 0, 255, 0.6)', offset: Math.PI / 2 },
          { amplitude: 10, frequency: 0.04, color: 'rgba(0, 255, 65, 0.4)', offset: Math.PI }
        ];
        
        waves.forEach(wave => {
          ctx.beginPath();
          ctx.strokeStyle = wave.color;
          ctx.lineWidth = 2;
          
          for (let x = 0; x < width; x++) {
            const y = height / 2 + 
                     Math.sin((x * wave.frequency) + phase + wave.offset) * 
                     wave.amplitude * audioFactor;
            
            if (x === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
        });
        
        // Draw FPS indicator
        ctx.fillStyle = 'rgba(0, 242, 255, 0.6)';
        ctx.font = '10px monospace';
        ctx.fillText(`WAVE ${Math.round(phase * 10)}`, 5, 12);
        
        // Update phase
        phase += 0.05 * timeSpeed;
        if (phase > Math.PI * 2) phase = 0;
        
        requestAnimationFrame(drawSineWave);
      }
      
      drawSineWave();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öôÔ∏è SISTEMA DE CONTROLES CONFIGURABLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Configuraci√≥n por defecto
    const defaultKeyBindings = {
      forward: 'w',
      back: 's',
      left: 'a',
      right: 'd',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'r'
    };

    // Cargar configuraci√≥n guardada o usar defaults
    let keyBindings = JSON.parse(localStorage.getItem('cosmicOS_keyBindings')) || {...defaultKeyBindings};

    // Guardar configuraci√≥n
    function saveKeyBindings() {
      localStorage.setItem('cosmicOS_keyBindings', JSON.stringify(keyBindings));
      showToast('‚öôÔ∏è Controles guardados');
    }

    // Resetear a defaults
    function resetKeyBindings() {
      keyBindings = {...defaultKeyBindings};
      saveKeyBindings();
      updateKeyBindingsUI();
      showToast('‚öôÔ∏è Controles reseteados a defaults');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ SISTEMA DRAGGABLE UNIVERSAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function makeDraggable(elementId, handleSelector = null) {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      const handle = handleSelector ? element.querySelector(handleSelector) : element;
      if (!handle) return;
      
      let isDragging = false;
      let startX, startY, initialLeft, initialTop;
      
      handle.style.cursor = 'move';
      element.classList.add('draggable');
      
      handle.addEventListener('mousedown', (e) => {
        // Ignorar si es el bot√≥n hamburguesa del config-module
        if (e.target.matches('#config-module::before')) return;
        
        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        const rect = element.getBoundingClientRect();
        initialLeft = rect.left;
        initialTop = rect.top;
        
        // Convertir a posicionamiento absoluto
        element.style.position = 'fixed';
        element.style.bottom = 'auto';
        element.style.right = 'auto';
        element.style.transform = 'none';
        element.style.left = initialLeft + 'px';
        element.style.top = initialTop + 'px';
        
        element.classList.add('dragging');
        handle.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newLeft = initialLeft + dx;
        const newTop = initialTop + dy;
        
        element.style.left = newLeft + 'px';
        element.style.top = newTop + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          element.classList.remove('dragging');
          handle.style.cursor = 'move';
          
          // Guardar posici√≥n
          savePosition(elementId, element.style.left, element.style.top);
        }
      });
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üíæ SISTEMA DE PERSISTENCIA DE PANELES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const panelStates = {
      'config-module': { visible: true, defaultPos: { top: '50%', left: '-280px', transform: 'translateY(-50%)' } },
      'temporal-controls': { visible: false, defaultPos: { bottom: '20px', right: '20px' } },
      'quick-nav-panel': { visible: true, defaultPos: { bottom: '20px', left: '50%', transform: 'translateX(-50%)' } },
      'donation-module': { visible: true, defaultPos: { bottom: '20px', left: '20px' } }
    };
    
    function savePosition(panelId, left, top) {
      const positions = JSON.parse(localStorage.getItem('cosmicOS_panelPositions') || '{}');
      positions[panelId] = { left, top };
      localStorage.setItem('cosmicOS_panelPositions', JSON.stringify(positions));
    }
    
    function restorePositions() {
      const positions = JSON.parse(localStorage.getItem('cosmicOS_panelPositions') || '{}');
      Object.keys(positions).forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel && positions[panelId]) {
          panel.style.position = 'fixed';
          panel.style.left = positions[panelId].left;
          panel.style.top = positions[panelId].top;
          panel.style.bottom = 'auto';
          panel.style.right = 'auto';
          panel.style.transform = 'none';
        }
      });
      
      // Restaurar estados de visibilidad
      const states = JSON.parse(localStorage.getItem('cosmicOS_panelStates') || '{}');
      Object.keys(states).forEach(panelId => {
        if (states[panelId] !== undefined && states[panelId].visible !== undefined) {
          panelStates[panelId].visible = states[panelId].visible;
          const panel = document.getElementById(panelId);
          if (panel) {
            panel.style.display = states[panelId].visible ? '' : 'none';
          }
          // Actualizar bot√≥n
          updatePanelButton(panelId, states[panelId].visible);
        }
      });
    }
    
    function togglePanel(panelId) {
      const panel = document.getElementById(panelId);
      if (!panel) return;
      
      // If it's the config module, we don't want to hide it completely (display:none)
      // because that kills the hover handle. We just want to "collapse" it.
      if (panelId === 'config-module') {
         // Check if it's currently expanded "programmatically" (e.g. dragging or pinned?)
         // Actually, our CSS handles the collapse (left: -430px). 
         // "Toggle" button might just be for "Focus" or "Hide completely"?
         // User says "without pressing button".
         // Let's make the button mostly irrelevant -> it just ensures it's in default state.
         
         const isHidden = panel.classList.contains('force-hidden');
         
         if (isHidden) {
             panel.classList.remove('force-hidden');
             panel.style.display = ''; 
             showToast('üëÅÔ∏è Panel Neural Restaurado');
         } else {
             // If user really wants to hide it?
             // Maybe just flash it?
             // Let's assume the button should "Reset" it to peeking state if it was hidden.
             panel.classList.remove('force-hidden');
             panel.style.display = '';
             showToast('üß† Panel Neural Listo (Desliza mouse al borde izquierdo)');
         }
         // Update button state
         updatePanelButton(panelId, true);
         return;
      }

      const isVisible = panel.style.display !== 'none';
      panel.style.display = isVisible ? 'none' : '';
      panelStates[panelId].visible = !isVisible;
      
      // Actualizar bot√≥n
      updatePanelButton(panelId, !isVisible);
      
      // Guardar estado
      const states = JSON.parse(localStorage.getItem('cosmicOS_panelStates') || '{}');
      states[panelId] = { visible: !isVisible };
      localStorage.setItem('cosmicOS_panelStates', JSON.stringify(states));
      
      showToast(`${isVisible ? 'üôà' : 'üëÅÔ∏è'} Panel ${isVisible ? 'ocultado' : 'restaurado'}`);
    }
    
    function updatePanelButton(panelId, isVisible) {
      const btn = document.querySelector(`[data-panel="${panelId}"]`);
      if (btn) {
        if (isVisible) {
          btn.classList.remove('hidden-panel');
        } else {
          btn.classList.add('hidden-panel');
        }
      }
    }
    
    function resetAllPanels() {
      Object.keys(panelStates).forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        
        const defaultPos = panelStates[panelId].defaultPos;
        panel.style.position = 'fixed';
        Object.keys(defaultPos).forEach(prop => {
          panel.style[prop] = defaultPos[prop];
        });
        
        // Resetear otras propiedades
        panel.style.display = '';
        panel.style.bottom = defaultPos.bottom || 'auto';
        panel.style.right = defaultPos.right || 'auto';
        panel.style.left = defaultPos.left || 'auto';
        panel.style.top = defaultPos.top || 'auto';
        
        panelStates[panelId].visible = true;
        updatePanelButton(panelId, true);
      });
      
      // Limpiar localStorage
      localStorage.removeItem('cosmicOS_panelStates');
      localStorage.removeItem('cosmicOS_panelPositions');
      
      showToast('üîÑ Vista restaurada a defaults');
    }


    // Movimiento (EXTREME SPEED MODE)
    const moveState = { forward:0, back:0, left:0, right:0, up:0, down:0, rotateUp:0, rotateDown:0, rotateLeft:0, rotateRight:0 };
    const velocity = new THREE.Vector3();
    let acceleration = 9.0; // 2x faster acceleration
    const deceleration = 0.94; // Smoother deceleration
    let maxSpeed = 90; // 2x max speed
    let speedBoost = 2.5; // 2.5x boost with Ctrl (was 1.0)
    let rotationSpeed = 0.04; // 2x rotation speed

    const availableSeeds = Array.from({length:500}, (_,i) => -10 + i); // 500 seeds (2.5x upgrade)

    async function loadUniverse(seed) {
      document.getElementById('loading-overlay').style.display = 'flex';
      const seedDisplay = document.getElementById('current-seed');
      const modeDisplay = document.getElementById('current-mode');
      const seedDisplayTop = document.getElementById('current-seed-display');
      const modeDisplayTop = document.getElementById('current-mode-display');
      
      // PR-18: Audio Init on interaction
      initSpatialAudio();
      // PR-17: Load Multiverse Data
      updateMultiversePanel(seed);
      
      if (seedDisplay) seedDisplay.textContent = seed;
      if (seedDisplayTop) seedDisplayTop.textContent = seed;

      try {
        const res = await fetch(`/web/data_seed_${seed}.json`);
        let data;
        if (!res.ok) {
           console.warn(`‚ö†Ô∏è Seed ${seed} not found (404). Generating emergency nodes.`);
           data = {
             nodes: [],
             modo: "EMERGENCY_RECOVERY",
             horror_total: 666,
             modo_info: { emoji: "üÜò", desc: "Suministro de emergencia activado" }
           };
            const sliderCount = parseInt(document.getElementById('nodeSlider')?.value || 50000);
            for(let i=0; i<sliderCount; i++) {
              // Spherical Distribution for "Bien 360"
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const r = 500 + Math.random() * 1500;
              
              const x = r * Math.sin(phi) * Math.cos(theta);
              const y = r * Math.sin(phi) * Math.sin(theta);
              const z = r * Math.cos(phi);

              data.nodes.push({
                id: `E${i}`,
                position: [x, y, z],
                color: 0xff0033
              });
            }
        } else {
           data = await res.json();
        }
        currentUniverseData = data;

        // Limpiar escena
        if (pointsCloud) { scene.remove(pointsCloud); pointsCloud = null; }
        if (centralSingularity) { scene.remove(centralSingularity); centralSingularity = null; }

        // üåå GARGANTUA SINGULARITY v9.4.0
        centralSingularity = createGargantuaSingularity();
        scene.add(centralSingularity);

        // Nodos
        // Nodos
        const sliderTarget = parseInt(document.getElementById('nodeSlider')?.value || 50000);
        const jsonCount = data.nodes ? data.nodes.length : 0;
        const totalCount = Math.max(jsonCount, sliderTarget);
        
        if (totalCount > 0) {
          // 3. Node Instancing (PR-2)
          // Use InstancedMesh for high-performance rendering of structured nodes
          const nodeGeometry = new THREE.SphereGeometry(2, 8, 8); // Simple sphere for instancing
          const nodeMaterial = new THREE.MeshPhongMaterial({
            vertexColors: false, // Colors will be set per instance
            shininess: 100,
            emissive: 0x001111,
            emissiveIntensity: 0.5
          });

          const instancedNodes = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, jsonCount || 1000);
          const matrix = new THREE.Matrix4();
          const color = new THREE.Color();

          if (data.nodes) {
            data.nodes.forEach((n, i) => {
              const p = n.position || [0, 0, 0];
              matrix.setPosition(p[0], p[1], p[2]);
              instancedNodes.setMatrixAt(i, matrix);

              if (n.color) color.set(n.color);
              else color.setHSL(((Math.abs(seed) % 10) / 10 + (i / jsonCount) * 0.1) % 1, 0.8, 0.5);
              
              instancedNodes.setColorAt(i, color);
            });
            instancedNodes.instanceMatrix.needsUpdate = true;
            if (instancedNodes.instanceColor) instancedNodes.instanceColor.needsUpdate = true;
          }
          scene.add(instancedNodes);
          
          // Background/Procedural nodes still use Points for extreme density (1M nodes)
          const proceduralCount = Math.max(0, totalCount - jsonCount);
          if (proceduralCount > 0) {
            const pos = new Float32Array(proceduralCount * 3);
            const colors = new Float32Array(proceduralCount * 3);
            const sizes = new Float32Array(proceduralCount);

            const geometryType = document.getElementById('vizMode')?.value || "ORBITAL";
            const modeColor = data.modo_info?.color || "#00ffff";
            
            for (let i = 0; i < proceduralCount; i++) {
                let x, y, z;
                if (geometryType === 'MANDALA') {
                    const r = 800 + Math.random() * 2000;
                    const theta = (i / proceduralCount) * Math.PI * 2 * 34;
                    const phi = Math.random() * Math.PI;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = (Math.random() - 0.5) * 600;
                } else {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 1000 + Math.random() * 3000;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                
                pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
                
                const c = new THREE.Color(modeColor);
                c.offsetHSL(Math.random()*0.1, -0.2, -0.3);
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                sizes[i] = 0.8 + Math.random() * 0.8;
            }

            const g = new THREE.BufferGeometry();
            g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            pointsCloud = new THREE.Points(g, new THREE.PointsMaterial({
                vertexColors: true, 
                size: 1.2, 
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            }));
            scene.add(pointsCloud);
          }
          
          // Actualizar contador real
          const tNodes = document.getElementById('titan-nodes');
          if (tNodes) tNodes.textContent = totalCount.toLocaleString();
        }

        const modoText = data.modo || "DOLPHIN";
        if (modeDisplay) modeDisplay.textContent = modoText;
        if (modeDisplayTop) modeDisplayTop.textContent = modoText;
        
        // Update Titan Panel
        const titanMode = document.getElementById('titan-mode');
        const titanSeed = document.getElementById('titan-seed');
        const titanHorror = document.getElementById('titan-horror');
        if (titanMode) titanMode.textContent = modoText;
        if (titanSeed) titanSeed.textContent = seed;
        if (titanHorror && data.horror_total) {
          titanHorror.textContent = Math.round(data.horror_total).toLocaleString();
        }

        // PR-11: Generate Synaptic Silk
        if (data.nodes) {
          createSynapticSilk(data.nodes);
        }
        
        // Trigger Narrative (PR-4)
        initiateNarrativeStream();
        
        // Update Predictive Panel (PR-7)
        if (data.top_drivers) {
          updatePredictivePanel(data);
        }
      } catch (e) {
        console.error("Error:", e);
        if (modeDisplay) modeDisplay.textContent = "ERROR";
        if (modeDisplayTop) modeDisplayTop.textContent = "ERROR";
      }

      document.getElementById('loading-overlay').style.display = 'none';
    }

    function initEngine() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000);
      camera.position.set(0, 500, 1500);

      renderer = new THREE.WebGLRenderer({ 
        antialias: false, // Disabled for extreme performance
        powerPreference: "high-performance",
        logarithmicDepthBuffer: true // Better depth precision for large scenes
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Reduced for 150k nodes
      renderer.setSize(innerWidth, innerHeight);
      
      // Modern HDR / Tonemapping (PR-2)
      renderer.toneMapping = THREE.ACESFilmicToneMapping; // More Cinematic
      renderer.toneMappingExposure = 1.2;
      renderer.outputEncoding = THREE.sRGBEncoding; // Gamma correction
      
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // WebGL Resilience
      renderer.domElement.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          console.warn('‚ö†Ô∏è WebGL Context Lost! Stabilizing...');
          showToast('‚ö†Ô∏è GPU OVERLOAD: RECOVERING...');
      }, false);

      renderer.domElement.addEventListener('webglcontextrestored', () => {
          console.log('‚úÖ WebGL Context Restored');
          loadUniverse(currentUniverseSeed);
      }, false);

      // 1. Post-processing setup (OPTIMIZED FOR 150K NODES)
      const renderScene = new THREE.RenderPass(scene, camera);
      bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(innerWidth * 0.8, innerHeight * 0.8), // Reduced resolution for performance
        1.2, // Reduced strength
        0.3, // Reduced radius
        0.88 // Higher threshold
      );
      bloomPass.threshold = 0.25; // Higher threshold = less bloom = better FPS
      bloomPass.strength = 0.9; // Reduced strength
      bloomPass.radius = 0.45; // Reduced radius

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // 2. Lights (Essential for MeshStandardMaterial depth)
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x00ffff, 2, 500);
      pointLight.position.set(0, 0, 0); // Inside the Poneglyph
      scene.add(pointLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      scene.add(directionalLight);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // MOVED: Double click listener added here to ensure renderer exists
      // Viz Mode Change
      document.getElementById('vizMode')?.addEventListener('change', e => {
         const mode = e.target.value;
         if (mode === 'MANDALA') {
            createMandalaUniverse();
            // Ensure audio is on for Mandala reactivity, but don't force Matrix
            if (!isFiestaMode) {
              isFiestaMode = true;
              const fCheckbox = document.getElementById('fiestaMode');
              if (fCheckbox) fCheckbox.checked = true;
              initAudio();
            }
         } else if (mode === 'FUSION') {
            invokeFusion();
         } else if (mode === 'LASER') {
            createLaserUniverse();
         } else if (mode === 'BUBBLE') {
            createBubbleUniverse();
         } else if (mode === 'LANIAKEA') {
            createLaniakeaUniverse();
         } else if (mode === 'NEGATIVE_RGB') {
            createNegativeRGBUniverse();
         } else {
            loadUniverse(currentUniverseSeed); 
         }
      });
      
      // Initialize Sine Graph
      initSineGraph();
      
      // Ion Channels Toggle
      document.getElementById('ionChannelsToggle')?.addEventListener('change', e => {
         if(e.target.checked) createIonChannels();
         else removeIonChannels();
      });


      loadUniverse(currentUniverseSeed);
      initSineWave(); // Initialize sine wave visualization
      
      // PR-19: ORACLE REALITY CORRELATION
      setInterval(fetchRealityCorrelation, 5000); 

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (!scene || !camera) return;

      const time = Date.now() * 0.001;
      const speedMultiplier = timeSpeed;

      // PR-20: BIOLOGICAL STRESS FEEDBACK (Camera Jitter)
      if (currentUniverseData && currentUniverseData.horror_total > 100000) {
         const stress = Math.min(1.0, (currentUniverseData.horror_total - 100000) / 200000);
         camera.position.x += (Math.random() - 0.5) * stress * 2;
         camera.position.y += (Math.random() - 0.5) * stress * 2;
         camera.rotation.z += (Math.random() - 0.5) * stress * 0.01;
      }

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

      const accel = new THREE.Vector3();
      if (moveState.forward) accel.addScaledVector(dir, acceleration * speedMultiplier);
      if (moveState.back) accel.addScaledVector(dir, -acceleration * speedMultiplier);
      if (moveState.left) accel.addScaledVector(side, acceleration * speedMultiplier);
      if (moveState.right) accel.addScaledVector(side, -acceleration * speedMultiplier);
      if (moveState.up) accel.y += acceleration * speedMultiplier;
      if (moveState.down) accel.y -= acceleration * speedMultiplier;

      velocity.add(accel);
      velocity.multiplyScalar(deceleration);
      if (velocity.length() > maxSpeed) velocity.setLength(maxSpeed);

      camera.position.add(velocity);
      controls.target.add(velocity);
      
      if (moveState.rotateLeft) camera.rotation.y += rotationSpeed * speedMultiplier;
      if (moveState.rotateRight) camera.rotation.y -= rotationSpeed * speedMultiplier;
      if (moveState.rotateUp) camera.rotation.x += rotationSpeed * speedMultiplier;
      if (moveState.rotateDown) camera.rotation.x -= rotationSpeed * speedMultiplier;
      
      if (!isImmersionMode && controls) controls.update();

      // 1. UPDATE AUDIO DATA ONCE PER FRAME
      if (isFiestaMode) {
        if (audioInitialized && analyser && dataArray) {
          analyser.getByteFrequencyData(dataArray);
        } else {
          simulateAudioData();
        }
      }

      // 2. ANIMATE CENTRAL SINGULARITY
      if (centralSingularity) {
        const ud = centralSingularity.userData;
        if (ud?.disk) ud.disk.rotation.y += 0.002 * speedMultiplier;

        if (ud?.poneglyph?.material) {
          const pg = ud.poneglyph;
          pg.rotation.y -= 0.005 * speedMultiplier;
          pg.rotation.x += 0.003 * speedMultiplier;
          pg.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
        }

        if (ud?.photonSphere?.material) {
          ud.photonSphere.material.opacity = Math.sin(Date.now() * 0.001) * 0.05 + 0.15;
        }

        // PR-9: ANIMATE NEURAL SHELL
        if (ud?.neuralShell?.material && window.neuralCoreMaterial) {
          const activity = currentUniverseData?.neural_activity || 0;
          window.neuralCoreMaterial.uniforms.time.value = Date.now() * 0.001;
          window.neuralCoreMaterial.uniforms.activity.value = activity;
          ud.neuralShell.rotation.y += (0.005 + activity * 0.02) * speedMultiplier;
          ud.neuralShell.scale.setScalar(1.0 + Math.sin(Date.now() * 0.005) * 0.05);
        }
      }

      // PR-9: ANIMATE NEURAL PULSES
      for (let i = neuralCorePulses.length - 1; i >= 0; i--) {
        const p = neuralCorePulses[i];
        p.progress += p.speed * speedMultiplier;
        
        // Linear interpolation from core (0,0,0) to target
        p.mesh.position.lerpVectors(new THREE.Vector3(0,0,0), p.target, p.progress);
        
        // Pulsing scale
        p.mesh.scale.setScalar(1.0 + Math.sin(p.progress * 10) * 0.5);

        if (p.progress >= 1.0) {
          scene.remove(p.mesh);
          neuralCorePulses.splice(i, 1);
        }
      }

      // 3. ANIMATE MATRIX LINES
      if (matrixLines?.material) {
        matrixLines.rotation.y += 0.001 * speedMultiplier;

        if (matrixModeActive) {
          const collapseProb = currentUniverseData?.collapse_probability || 0;
          if (isFiestaMode && dataArray && currentUniverseData) {
             const gravityFactor = Math.abs(currentUniverseData?.modo_info?.physics?.gravity || 1000) / 10000;
             const flowSpeed = 0.002 * (1 + gravityFactor + collapseProb * 2); 
             const timeAt = Date.now();
             const bass = dataArray[4] || 0; 
             const normBass = bass / 255.0;
             const hue = (timeAt * flowSpeed + normBass * 0.1) % 1; 
             
             matrixLines.material.color?.setHSL(hue, 1.0, 0.3 + normBass * 0.7);
             matrixLines.material.opacity = (matrixOpacity || 0.3) + (normBass * 0.5) + (collapseProb * 0.2);
             
             if (ionLines?.material?.color) {
                 ionLines.material.color.setHSL((hue + 0.5) % 1, 1.0, 0.5 + normBass*0.5);
                 ionLines.material.opacity = 0.4 + normBass * 0.4 + (collapseProb * 0.2);
                 ionLines.rotation.y -= 0.02 * (1 + collapseProb); 
             }
          } else {
             const timeAt = Date.now() * 0.0005;
             const hue = (timeAt % 1); 
             matrixLines.material.color?.setHSL(hue, 0.8, 0.5);
             matrixLines.material.opacity = (matrixOpacity || 0.3) + (collapseProb * 0.4);
          }
        }
      }

      // PR-11: ANIMATE SYNAPTIC SILK
      if (synapticSilk?.material) {
        const timeAt = Date.now() * 0.005;
        const pulse = 0.1 + Math.sin(timeAt) * 0.1 + (Math.random() * 0.05);
        synapticSilk.material.opacity = pulse;
        synapticSilk.rotation.y += 0.0005 * speedMultiplier;
      }

      // 4. ANIMATE ION LINES (CHANNELS)
      if (ionLines?.material) {
        ionLines.rotation.y -= 0.002 * speedMultiplier; 
        ionLines.rotation.x += 0.001 * speedMultiplier;
        
        if (isFiestaMode && dataArray) {
           const mid = dataArray[20] || 0;
           const normMid = mid / 255.0;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + (normMid * 0.5), 1.0, 0.6 + (normMid * 0.4));
           ionLines.material.opacity = 0.4 + (normMid * 0.6);
           const scale = 1.0 + (normMid * 0.5); 
           ionLines.scale.set(scale, scale, scale);
        } else {
           const timeAt = Date.now() * 0.002;
           const pulse = 0.3 + Math.sin(timeAt) * 0.2;
           ionLines.material.opacity = pulse;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + Math.sin(timeAt*0.5)*0.1, 1.0, 0.5);
           ionLines.scale.set(1,1,1);
        }
      }
      
      // 5. LOD & SCALING (PR-2)
      // Basic LOD by scaling instances/points based on distance
      if (scene) {
        scene.traverse(obj => {
          if (obj.isInstancedMesh) {
            const matrix = new THREE.Matrix4();
            const pos = new THREE.Vector3();
            for (let i = 0; i < obj.count; i++) {
              obj.getMatrixAt(i, matrix);
              pos.setFromMatrixPosition(matrix);
              const dist = camera.position.distanceTo(pos);
              
              // Scale down based on distance (Basic LOD)
              let scale = 1.0;
              if (dist > 2000) scale = 0.5;
              if (dist > 4000) scale = 0.2;
              
              // Simple way to update scale in matrix without full decomposition
              const currentScale = new THREE.Vector3();
              const currentPos = new THREE.Vector3();
              const currentQuat = new THREE.Quaternion();
              matrix.decompose(currentPos, currentQuat, currentScale);
              matrix.compose(currentPos, currentQuat, new THREE.Vector3(scale, scale, scale));
              obj.setMatrixAt(i, matrix);
            }
            obj.instanceMatrix.needsUpdate = true;
          }
        });
      }

      // 6. ANIMATE ORBITAL IONS
      if (orbitalIons && orbitalIons.material) {
          orbitalIons.rotation.y += 0.0015 * speedMultiplier * (isFiestaMode ? 4 : 1);
          orbitalIons.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
      }

      // 6. ANIMATE MANDALA / POINTS CLOUD
      const pc = pointsCloud;
      if (pc && pc.geometry && pc.geometry.attributes && pc.geometry.attributes.position) {
        if (pc.userData && pc.userData.isMandala) {
          pc.rotation.z += 0.001 * speedMultiplier;
          pc.rotation.y += 0.002 * speedMultiplier;

          if (isFiestaMode && dataArray) {
            if (frameCount % 2 === 0) {
              const positions = pc.geometry.attributes.position.array;
              const original = pc.geometry.userData.originalPositions;
              const layerIndices = pc.geometry.userData.layerIndices;
              const scales = pc.geometry.userData.scales;
              
                if (original && layerIndices && scales) {
                  const count = positions.length / 3;
                  const start = currentChunk * CHUNK_SIZE;
                  const end = Math.min(start + CHUNK_SIZE, count);

                  for(let i = start; i < end; i++) {
                    const layer = layerIndices[i];
                    const audioIdx = Math.floor((layer * 5) % dataArray.length);
                    const audioVal = dataArray[audioIdx] || 0;
                    const targetScale = 1.0 + (audioVal * 0.015);
                    scales[i] = scales[i] + (targetScale - scales[i]) * 0.3;

                    const idx3 = i*3;
                    positions[idx3]   = original[idx3] * scales[i];
                    positions[idx3+1] = original[idx3+1] * scales[i];
                    positions[idx3+2] = original[idx3+2] * scales[i];
                  }
                  pc.geometry.attributes.position.needsUpdate = true;
                }
            }
          }
        }
        
        // Gravitational Redshift Simulation (Universal)
        if (pc.geometry.userData.originalColors && frameCount % 2 === 0) {
            const colorAttr = pc.geometry.attributes.color;
            if (colorAttr) {
                const colors = colorAttr.array;
                const orig = pc.geometry.userData.originalColors;
                const positions = pc.geometry.attributes.position.array;
                const count = colorAttr.count;
                
                const start = currentChunk * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, count);

                for (let i = start; i < end; i++) {
                    const x = positions[i*3], y = positions[i*3+1], z = positions[i*3+2];
                    const d = Math.sqrt(x*x + y*y + z*z);
                    const grav = Math.max(0.0, 1.0 - (d / 3500));
                    const boost = 1.0 + Math.pow(grav, 3) * 25.0; 
                    colors[i*3]   = orig[i*3] * boost;
                    colors[i*3+1] = orig[i*3+1] * boost;
                    colors[i*3+2] = orig[i*3+2] * boost;
                }
                colorAttr.needsUpdate = true;
                
                // Advance chunk for next frame
                currentChunk = (currentChunk + 1) % Math.ceil(count / CHUNK_SIZE);
            }
        }
      }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üìä OBSERVABILITY & METRICS (PR-1)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let metricsHistory = [];
    const SAMPLING_RATE = 60; // Sample every 60 frames
    let lastTime = performance.now();
    let frames = 0;

    function updateTitanPanel() {
      const time = performance.now();
      frames++;

      if (time >= lastTime + 1000) {
        const fps = Math.round((frames * 1000) / (time - lastTime));
        const dt = (time - lastTime) / frames;
        
        // UI Updates
        const fpsEl = document.getElementById('titan-fps');
        if (fpsEl) {
          fpsEl.textContent = fps;
          fpsEl.className = 'titan-stat-value ' + (fps < 30 ? 'danger' : (fps < 50 ? 'warning' : ''));
        }

        const mem = performance.memory ? Math.round(performance.memory.usedJSHeapSize / 1048576) : 0;
        const memEl = document.getElementById('titan-memory');
        if (memEl) {
          memEl.textContent = `${mem} MB`;
          if (performance.memory) {
            const limit = performance.memory.jsHeapSizeLimit / 1048576;
            if (mem > limit * 0.8) memEl.className = 'titan-stat-value danger';
            else if (mem > limit * 0.5) memEl.className = 'titan-stat-value warning';
            else memEl.className = 'titan-stat-value';
          }
        }

        const speedEl = document.getElementById('titan-speed');
        if (speedEl) speedEl.textContent = `x${timeSpeed.toFixed(1)}`;

        // Performance Sampling
        if (frameCount % SAMPLING_RATE === 0) {
          const sample = {
            timestamp: Date.now(),
            fps: fps,
            frameTime: dt.toFixed(2),
            memory: mem,
            nodes: totalNodes,
            seed: currentUniverseSeed,
            drawCalls: renderer.info.render.calls,
            triangles: renderer.info.render.triangles
          };
          metricsHistory.push(sample);
          if (metricsHistory.length > 1000) metricsHistory.shift(); // Keep last 1000 samples
        }

        frames = 0;
        lastTime = time;
      }
    }

    function exportMetrics(format = 'json') {
      if (metricsHistory.length === 0) {
        showToast('‚ö†Ô∏è No metrics to export');
        return;
      }

      let content, mimeType, extension;
      if (format === 'csv') {
        const keys = Object.keys(metricsHistory[0]);
        content = [
          keys.join(','),
          ...metricsHistory.map(row => keys.map(k => row[k]).join(','))
        ].join('\n');
        mimeType = 'text/csv';
        extension = 'csv';
      } else {
        content = JSON.stringify(metricsHistory, null, 2);
        mimeType = 'application/json';
        extension = 'json';
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cosmic_metrics_${currentUniverseSeed}_${Date.now()}.${extension}`;
      a.click();
      URL.revokeObjectURL(url);
      showToast(`üìä Metrics exported as ${format.toUpperCase()}`);
    }

    function exportSnapshot() {
      const snapshot = {
        seed: currentUniverseSeed,
        camera: {
          position: camera.position.toArray(),
          rotation: camera.rotation.toArray(),
          target: controls.target.toArray()
        },
        settings: {
          timeSpeed,
          vizMode: document.getElementById('vizMode')?.value,
          theme: document.getElementById('uxTheme')?.value,
          nodeCount: document.getElementById('nodeSlider')?.value
        },
        timestamp: Date.now()
      };

      const blob = new Blob([JSON.stringify(snapshot, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cosmic_snapshot_${currentUniverseSeed}_${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('üì∏ Snapshot exported');
    }

    updateTitanPanel();
    if (composer) composer.render();
    else renderer.render(scene, camera);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé® THEME SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const themeSelect = document.getElementById('uxTheme');
    if (themeSelect) {
      themeSelect.addEventListener('change', (e) => {
        setTheme(e.target.value);
      });
    }

    function setTheme(theme) {
      console.log(`üé® Theme changed to: ${theme}`);
      
      const nodes = pointsCloud ? pointsCloud.geometry : null;
      
      switch(theme) {
        case 'PHOTON':
          // MODO FOT√ìN: Cyan electric, bright, high contrast
          document.documentElement.style.setProperty('--text-cyan', '#00ffff');
          document.body.style.background = '#000000';
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 6;
            pointsCloud.material.opacity = 0.9;
            pointsCloud.material.color = new THREE.Color(0x00ffff);
            pointsCloud.material.vertexColors = false; 
          }
          
          // Matrix lines bright
          if (matrixLines && matrixLines.material) {
            matrixLines.material.color = new THREE.Color(0xffffff);
            matrixLines.material.opacity = 0.5;
          }
          
          showToast('‚ö° MODO FOT√ìN ACTIVADO');
          break;
          
        case 'PARADOX':
          // MODO 666 PARADOX: Fire, Red/Orange/Yellow, Hellish
          document.documentElement.style.setProperty('--text-cyan', '#ff4500'); // OrangeRed
          document.body.style.background = '#1a0500'; // Dark red/brown
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 10;
            pointsCloud.material.opacity = 1.0;
            pointsCloud.material.vertexColors = true;
            
            // Recolor nodes to fire gradient
            const count = nodes.attributes.position.count;
            const colors = nodes.attributes.color.array;
            
            for (let i = 0; i < count; i++) {
              const r = Math.random() * 0.5 + 0.5; // 0.5-1.0 (Red)
              const g = Math.random() * 0.5;       // 0-0.5 (Green -> Orange/Yellow)
              const b = 0;                         // No blue
              
              colors[i * 3] = r;
              colors[i * 3 + 1] = g;
              colors[i * 3 + 2] = b;
            }
            nodes.attributes.color.needsUpdate = true;
          }
          
          // Singularity becomes a burning sun
          if (centralSingularity) {
            const children = centralSingularity.children;
            children.forEach(child => {
              if (child.isMesh && child.geometry.type === 'SphereGeometry' && child.material) {
                 // Core becomes bright yellow/white
                 if (child.geometry.parameters.radius === 30) {
                   child.material.color.setHex(0xffff00);
                 }
                 // Glow becomes orange
                 if (child.geometry.parameters.radius === 45) {
                   child.material.color.setHex(0xff4500);
                   child.material.opacity = 0.4;
                 }
              }
            });
          }
          
          showToast('üî• 666 PARADOX ACTIVADO');
          break;
          
        case 'COSMIC':
        default:
          // Reset to default
          document.documentElement.style.setProperty('--text-cyan', '#00f2ff');
          document.body.style.background = 'var(--bg-black)';
           
          // Restore functionality would require reloading mechanism or storing original state
          // For now, we just reset colors if possible or re-enable vertex colors
          if (pointsCloud && pointsCloud.material) {
             pointsCloud.material.vertexColors = true;
             pointsCloud.material.color = new THREE.Color(0xffffff);
             pointsCloud.material.size = 8;
          }
          if (centralSingularity && centralSingularity.children) {
             // Reset singularity colors
             if (centralSingularity.children[0] && centralSingularity.children[0].material) {
                centralSingularity.children[0].material.color.setHex(0x000000); // Core
             }
             if (centralSingularity.children[1] && centralSingularity.children[1].material) {
                centralSingularity.children[1].material.color.setHex(0xffffff); // Glow
             }
          }
          showToast('üåå MODO C√ìSMICO RESTAURADO');
          break;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß† NEURAL INTERFACE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let lastTime = performance.now();
    let fps = 60;
    frameCount = 0;
    let lastFpsUpdate = performance.now();

    function updateTitanPanel() {
      // FPS calculation
      frameCount++;
      const now = performance.now();
      if (now - lastFpsUpdate >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = now;
        
        const fpsEl = document.getElementById('titan-fps');
        if (fpsEl) {
          fpsEl.textContent = fps;
          fpsEl.className = 'titan-stat-value';
          if (fps < 30) fpsEl.classList.add('danger');
          else if (fps < 50) fpsEl.classList.add('warning');
        }
      }

      // Node count
      const nodesEl = document.getElementById('titan-nodes');
      if (nodesEl && pointsCloud) {
        const count = pointsCloud.geometry.attributes.position.count;
        nodesEl.textContent = count.toLocaleString();
      }

      // Memory usage
      const memEl = document.getElementById('titan-memory');
      if (memEl && performance.memory) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        memEl.textContent = mb + ' MB';
      }

      // Speed
      const speedEl = document.getElementById('titan-speed');
      if (speedEl) {
        if (isPaused) {
          speedEl.textContent = 'PAUSED';
          speedEl.className = 'titan-stat-value warning';
        } else {
          speedEl.textContent = 'x' + timeSpeed.toFixed(1);
          speedEl.className = 'titan-stat-value';
        }
      }
    }

    function enterCosmicOS() {
      gsap.to("#intro-overlay", {opacity:0, duration:1.2, onComplete:() => {
        document.getElementById('intro-overlay').style.display = 'none';
        initEngine();
      }});
    }

    function invokeCaos() {
      const randomSeed = availableSeeds[Math.floor(Math.random() * availableSeeds.length)];
      currentUniverseSeed = randomSeed;
      loadUniverse(randomSeed);
    }

    function invokeFusion() {
      const seedCount = parseInt(document.getElementById('seedSlider').value);
      const seeds = [];
      for (let i = 0; i < seedCount; i++) {
        seeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
      }
      console.log('FUSION MODE:', seeds);
      loadMultipleSeeds(seeds);
    }

    async function loadMultipleSeeds(seeds) {
      document.getElementById('loading-overlay').style.display = 'flex';
      
      if (pointsCloud) scene.remove(pointsCloud);
      
      const allNodes = [];
      const offsetDistance = 2000;
      
      const loadingCounter = document.getElementById('loading-overlay');
      
      for (let i = 0; i < seeds.length; i++) {
        if (i % 10 === 0) { // Batch updates every 10 seeds
            loadingCounter.textContent = `üåå COLAPSANDO EL MULTIVERSO... [${i}/${seeds.length}]`;
            await new Promise(r => setTimeout(r, 10)); // Allow DOM to breathe
        }

        try {
          const res = await fetch(`/web/data_seed_${seeds[i]}.json`);
          if (!res.ok) continue;
          const data = await res.json();
          
          if (data.nodes) {
            const angle = (i / seeds.length) * Math.PI * 2;
            const offsetX = Math.cos(angle) * offsetDistance;
            const offsetZ = Math.sin(angle) * offsetDistance;
            
            const hue = (i / seeds.length) * 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 0.8, 0.6);
            
            data.nodes.forEach(n => {
              const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
              allNodes.push({
                x: p[0] + offsetX,
                y: p[1],
                z: p[2] + offsetZ,
                r: color.r,
                g: color.g,
                b: color.b
              });
            });
          }
        } catch (e) {
          console.error(`Error loading seed ${seeds[i]}:`, e);
        }
      }
      loadingCounter.textContent = `ESTABILIZANDO SINGULARIDAD... (${allNodes.length.toLocaleString()} nodos)`;
      
      const positions = new Float32Array(allNodes.length * 3);
      const colors = new Float32Array(allNodes.length * 3);
      
      allNodes.forEach((n, i) => {
        positions[i * 3] = n.x;
        positions[i * 3 + 1] = n.y;
        positions[i * 3 + 2] = n.z;
        colors[i * 3] = n.r;
        colors[i * 3 + 1] = n.g;
        colors[i * 3 + 2] = n.b;
      });
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      // Dynamic Point Size based on total nodes
      let pSize = 8;
      if (allNodes.length > 500000) pSize = 1;
      else if (allNodes.length > 200000) pSize = 2;
      else if (allNodes.length > 100000) pSize = 4;

      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: pSize,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        })
      );
      
      scene.add(pointsCloud);
      
      // Force Titan Panel update for node count
      if (typeof updateTitanPanel === 'function') updateTitanPanel();

      document.getElementById('loading-overlay').style.display = 'none';
    }

    // üî• SINGULARITY OMEGA - 200 UNIVERSES CONVERGING
    async function invokeSingularityOmega() {
        const omegaSeeds = [];
        for(let i=0; i<200; i++) {
            omegaSeeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
        }
        showToast('‚ö† ALERTA: Iniciando SINGULARIDAD OMEGA (1M Nodos)');
        await loadMultipleSeeds(omegaSeeds);
    }


    // üå∏ MANDALA UNIVERSE (FRACTAL & AUDIO REACTIVE)
    function createMandalaUniverse() {
      if (pointsCloud) scene.remove(pointsCloud);
      if (centralSingularity) {
        scene.remove(centralSingularity);
        centralSingularity.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        centralSingularity = null;
      }

      const particleCount = 50000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const layerIndices = new Float32Array(particleCount);
      const scales = new Float32Array(particleCount); // New: para lerp smooth

      const layers = 12;
      let particleIdx = 0;

      for(let l = 0; l < layers; l++) {
        const layerCount = Math.floor(particleCount / layers);
        const radius = 200 + (l * 150);

        for(let i = 0; i < layerCount; i++) {
          if (particleIdx >= particleCount) break;

          const theta = i * 2.39996;
          const phi = Math.acos(1 - 2 * (i + 0.5) / layerCount);

          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);

          positions[particleIdx * 3] = x;
          positions[particleIdx * 3 + 1] = y;
          positions[particleIdx * 3 + 2] = z;

          const color = new THREE.Color().setHSL(l / layers, 1.0, 0.5);
          colors[particleIdx * 3] = color.r;
          colors[particleIdx * 3 + 1] = color.g;
          colors[particleIdx * 3 + 2] = color.b;

          layerIndices[particleIdx] = l;
          scales[particleIdx] = 1.0; // Init scale

          particleIdx++;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      geometry.userData.originalPositions = positions.slice();
      geometry.userData.layerIndices = layerIndices;
      geometry.userData.scales = scales;
      geometry.userData.originalColors = colors.slice(); // Fix for redshift simulation

      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 2, // Optimized for 50k nodes
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        })
      );

      pointsCloud.userData.isMandala = true;
      scene.add(pointsCloud);
      showToast('üå∏ UNIVERSO MANDALA ACTIVADO');
    }

    function resetCamera() {
      if (camera && controls) {
        camera.position.set(0, 500, 1500);
        controls.target.set(0, 0, 0);
        velocity.set(0, 0, 0);
        controls.update();
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - FULL MESH INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - SAFEGUARDED INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createMatrixLines() {
      if (!pointsCloud || !scene) return;
      
      removeMatrixLines(); 
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const nodeCount = positions.length / 3;
      
      const linePositions = [];
      const MAX_TOTAL_LINES = 300000; // Hard limit for WebGL buffer safety
      
      // Smart Logic: If too many nodes, use K-Nearest or Random Neighbors instead of Full Mesh
      if (nodeCount > 800) { 
        // Optimization for large datasets (O(N*K))
        console.warn('‚ö° High node count detected. Optimizing Matrix connections (Nearest Neighbors)...');
        
        for (let i = 0; i < nodeCount; i++) {
           // Connect to 5 random neighbors instead of everyone
           // (Approximation of "Matrix" look without O(N^2))
           for (let k = 0; k < 6; k++) {
              if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
              
              const j = Math.floor(Math.random() * nodeCount);
              if (i === j) continue;
              
              // Only connect if somewhat close (optional, but pure random is chaotic enough for noise)
              // To make it look structured, we could check distance, but that is expensive.
              // Fast alternative: Spatial hashing or just simple random for visual "noise".
              
              linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
           }
        }
      } else {
         // Full Mesh for small datasets
         for (let i = 0; i < nodeCount; i++) {
            for (let j = i + 1; j < nodeCount; j++) {
               if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
               linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
            }
         }
      }
      
      const lineGeometry = new THREE.BufferGeometry();
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(linePositions), 3));
      
      const lineMaterial = new THREE.LineBasicMaterial({
        color: matrixColor,
        opacity: matrixOpacity,
        transparent: true,
        linewidth: 1
      });
      
      matrixLines = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(matrixLines);
      
      console.log(`üü¢ MATRIX MODE SAFE: ${nodeCount} nodes, ${linePositions.length / 6} lines`);
    }

    // ... (removeMatrixLines, updateMatrixColor, etc. remain the same, ensure they are kept or I will break them if I overwrite)
    function removeMatrixLines() {
      if (matrixLines && scene) {
        scene.remove(matrixLines);
        if(matrixLines.geometry) matrixLines.geometry.dispose();
        if(matrixLines.material) matrixLines.material.dispose();
        matrixLines = null;
      }
    }
    
    function updateMatrixColor() { if (matrixLines && matrixLines.material) matrixLines.material.color.setHex(matrixColor); }
    function updateMatrixOpacity() { if (matrixLines && matrixLines.material) matrixLines.material.opacity = matrixOpacity; }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåå NEW UNIVERSES (Laser, Bubble, Laniakea)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. LASER UNIVERSE (Grid / Linear Energy)
    function createLaserUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
             // Grid distribution
             const range = 2000;
             if (i < particleCount * 0.8) {
                 // PLANES
                 positions[i*3] = (Math.random() - 0.5) * range;
                 positions[i*3+1] = (Math.floor(Math.random() * 10) - 5) * 200; // Quantized Y layers
                 positions[i*3+2] = (Math.random() - 0.5) * range;
             } else {
                 // BEAMS (Vertical)
                 positions[i*3] = (Math.floor(Math.random() * 20) - 10) * 200;
                 positions[i*3+1] = (Math.random() - 0.5) * range;
                 positions[i*3+2] = (Math.floor(Math.random() * 20) - 10) * 200;
             }
             
             // NEON COLORS (Red/Blue/Laser)
             const color = new THREE.Color();
             Math.random() > 0.5 ? color.setHex(0xff0055) : color.setHex(0x0055ff);
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, blending: THREE.AdditiveBlending }));
        scene.add(pointsCloud);
        showToast('‚ö° UNIVERSO LASER ACTIVADO');
    }

    // 2. BUBBLE UNIVERSE (Multiverse Foam)
    function createBubbleUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        const bubbleCenters = [];
        for(let j=0; j<50; j++) bubbleCenters.push({
            x: (Math.random()-0.5)*3000, 
            y: (Math.random()-0.5)*3000, 
            z: (Math.random()-0.5)*3000, 
            r: 100 + Math.random()*300
        });

        for (let i = 0; i < particleCount; i++) {
             const bubble = bubbleCenters[Math.floor(Math.random() * bubbleCenters.length)];
             
             // Surface of sphere
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos(2 * Math.random() - 1);
             
             const x = bubble.x + bubble.r * Math.sin(phi) * Math.cos(theta);
             const y = bubble.y + bubble.r * Math.sin(phi) * Math.sin(theta);
             const z = bubble.z + bubble.r * Math.cos(phi);
             
             positions[i*3] = x;
             positions[i*3+1] = y;
             positions[i*3+2] = z;
             
             const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6); // Rainbow bubbles
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent:true, opacity:0.6 }));
        scene.add(pointsCloud);
        showToast('üõÅ UNIVERSO BURBUJA ACTIVADO');
    }

    // 3. LANIAKEA UNIVERSE (Cosmic Web / Filaments)
    function createLaniakeaUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        // Laniakea has a Great Attractor! Keep Singularity but make it Golden
        if (!centralSingularity) {
            centralSingularity = createGargantuaSingularity();
            scene.add(centralSingularity);
        }
        
        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        // Simulating filaments using strange Attractors or Perlin noise curves
        // Simplified: Multiple sine waves paths
        
        for (let i = 0; i < particleCount; i++) {
            const t = Math.random() * 100; // path pos
            const filamentIdx = Math.floor(Math.random() * 20); // 20 main filaments
            
            // Parametric curves spiraling into center
            const angle = t * 0.1 + (filamentIdx * (Math.PI*2/20));
            const radius = t * 20 + 200; // expanding out
            const height = Math.sin(t * 0.5) * 500 * (Math.random()-0.5);
            
            // Add noise
            const spread = 50 + t;
            
            positions[i*3] = Math.cos(angle) * radius + (Math.random()-0.5)*spread;
            positions[i*3+1] = height + (Math.random()-0.5)*spread;
            positions[i*3+2] = Math.sin(angle) * radius + (Math.random()-0.5)*spread;
            
            // Golden / White colors
            const color = new THREE.Color().setHSL(0.1 + Math.random()*0.1, 0.8, 0.6); // Gold/Orange
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true }));
        scene.add(pointsCloud);
        showToast('üåå LANIAKEA SUPERCLUSTER DETECTADO');
    }

    // 4. NEGATIVE RGB LIGHT UNIVERSE (Operates -255 to 0)
    function createNegativeRGBUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        let idx = 0;
        
        // Explicit logic: "Desde lo negativo -255 hasta 0"
        // We will generate particles in batches mapping this negative range to position/color
        
        const range = 5000;
        
        for (let n = -255; n <= 0; n += 0.005) { // Updated for 50k nodes
            if(idx >= particleCount) break;
            
            // Negative Math for Position: (-255 to 0)
            // Map -255..0 to Space
            // Use random distribution but influenced by 'n'
            
            // Burst in all directions
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            // Radius depends on 'n' (inverted: -255 is CORE, 0 is EDGE)
            // n goes -255 -> 0. 
            // Normalized: (255 - abs(n)) / 255 => 0 to 1
            const rNorm = (255 - Math.abs(n)) / 255; 
            const r = rNorm * 2000; 

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            positions[idx*3] = x;
            positions[idx*3+1] = y;
            positions[idx*3+2] = z;
            
            // COLOR LOGIC: "RGB es facil 0 255 pero desde lo negativo -255 hasta 0"
            // Interpreted: Value = n + 255.
            // If n = -255, val = 0 (Black/Core).
            // If n = 0, val = 255 (Max Color).
            
            // R, G, B channels vary with different "negative frequencies"
            const rVal = 255 + (Math.random() > 0.5 ? n : -255); // Mix
            const gVal = 255 + (n); 
            const bVal = 255 + (Math.sin(n)*255 - 255)/2; // Oscillate
            
            const color = new THREE.Color(
                Math.max(0, rVal + Math.random()*50)/255, 
                Math.max(0, gVal + Math.random()*50)/255,
                Math.max(0, bVal + Math.random()*50)/255
            );
            
            colors[idx*3] = color.r;
            colors[idx*3+1] = color.g;
            colors[idx*3+2] = color.b;
            
            idx++;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        // Additive Blending for "Light"
        pointsCloud = new THREE.Points(
            geometry, 
            new THREE.PointsMaterial({ 
                size: 2, // Optimized for 50k nodes
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                transparent: true, 
                opacity: 0.8 
            })
        );
        scene.add(pointsCloud);
        showToast('üí° UNIVERSO LUZ RGB NEGATIVA ACTIVADO');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üìà SINE WAVE ANALYSIS (Real-Time Graph)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let sineCanvas, sineCtx;
    
    function initSineGraph() {
        sineCanvas = document.createElement('canvas');
        sineCanvas.id = 'sine-graph';
        sineCanvas.width = 400;
        sineCanvas.height = 100;
        sineCanvas.style.cssText = `
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid var(--text-cyan);
            border-radius: 8px;
            z-index: 50;
            pointer-events: none;
        `;
        document.body.appendChild(sineCanvas);
        sineCtx = sineCanvas.getContext('2d');
        
        // Add Label
        const label = document.createElement('div');
        label.innerText = 'REAL-TIME DATA SINE ANALYSIS';
        label.style.cssText = `
            position: fixed;
            bottom: 185px;
            left: 20px;
            color: var(--text-cyan);
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 51;
        `;
        document.body.appendChild(label);
        
        updateSineGraph();
    }
    
    function updateSineGraph() {
        requestAnimationFrame(updateSineGraph);
        if(!sineCtx || !sineCanvas) return;
        
        sineCtx.fillStyle = 'rgba(0,0,0,0.2)'; // Fade effect
        sineCtx.fillRect(0,0, sineCanvas.width, sineCanvas.height);
        
        const t = Date.now() * 0.002;
        
        // Data sources: Audio, Time, Position, Entropy (Random)
        // We mix "Greatest Amount of Data" -> 3-4 Waves overlay
        
        // 1. Audio / Energy Wave (Red/Magenta)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ff00ff';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
            const y = 50 + Math.sin(x*0.05 + t*2) * 20 * (isFiestaMode ? 1.5 : 0.5);
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 2. Cosmic Entropy (Cyan - High Fast)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#00ffff';
        sineCtx.lineWidth = 1;
        for(let x=0; x<sineCanvas.width; x++) {
            // Complex Harmonics
            const y = 50 + Math.sin(x*0.1 - t*3) * 15 + Math.cos(x*0.3 + t) * 5;
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 3. Gravity/Mass (Yellow - Slow Heavy)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ffff00';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
             const y = 50 + Math.sin(x*0.02 + t*0.5) * 30;
             if(x===0) sineCtx.moveTo(x,y); else sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
    }

    // Call initSineGraph in initEngine logic (later)

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öõÔ∏è ION CHANNELS (CONCENTRIC CONNECTIONS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createIonChannels() {
      if (!pointsCloud || !scene) return;
      removeIonChannels();

      const positions = pointsCloud.geometry.attributes.position.array;
      const count = positions.length / 3;
      
      // 1. DENSE ION LINES (The "Highways")
      const connections = [];
      const shells = {}; 
      
      for(let i=0; i<count; i++) {
         const x = positions[i*3];
         const y = positions[i*3+1];
         const z = positions[i*3+2];
         const dist = Math.sqrt(x*x + y*y + z*z);
         const shellIdx = Math.floor(dist / 150); // Smaller shells = More layers
         
         if(!shells[shellIdx]) shells[shellIdx] = [];
         shells[shellIdx].push(i);
      }
      
      // Connect nodes within shells
      const shellKeys = Object.keys(shells);
      for(let k = 0; k < shellKeys.length; k++) {
        const shellKey = shellKeys[k];
        const indices = shells[shellKey];
        // COMPLEXITY CAP: Limit connections per shell to avoid O(n^2) web
        const limit = Math.min(indices.length, 300); 
        
        for(let i=0; i<limit; i++) {
           const idxA = indices[i];
           const idxB = indices[(i+1) % limit];
           const idxC = indices[(i+2) % limit];
           
           const ax = positions[idxA*3], ay = positions[idxA*3+1], az = positions[idxA*3+2];
           const bx = positions[idxB*3], by = positions[idxB*3+1], bz = positions[idxB*3+2];
           const cx = positions[idxC*3], cy = positions[idxC*3+1], cz = positions[idxC*3+2];
           
           connections.push(ax, ay, az, bx, by, bz);
           connections.push(ax, ay, az, cx, cy, cz);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(connections), 3));
      
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      
      ionLines = new THREE.LineSegments(geometry, material);
      ionLines.userData.isIon = true;
      scene.add(ionLines);


      // 2. ORBITAL ION FLOW (The "Traffic")
      // Particles that will rotate physically to simulate flow along the shells
      const ionCount = 15000;
      const ionPos = new Float32Array(ionCount * 3);
      const ionSizes = new Float32Array(ionCount);
      
      for(let i=0; i<ionCount; i++) {
          // Spawn on existing shells
          const shellKeys = Object.keys(shells);
          const rKey = shellKeys[Math.floor(Math.random() * shellKeys.length)];
          const nodesInShell = shells[rKey];
          if(!nodesInShell) continue;
          
          // Pick a random node as base
          const nodeIdx = nodesInShell[Math.floor(Math.random() * nodesInShell.length)];
          const px = positions[nodeIdx*3];
          const py = positions[nodeIdx*3+1];
          const pz = positions[nodeIdx*3+2];
          
          // Add random spread to create a "Cloud" around the shell highway
          ionPos[i*3] = px + (Math.random()-0.5)*50;
          ionPos[i*3+1] = py + (Math.random()-0.5)*10; // Flat spread
          ionPos[i*3+2] = pz + (Math.random()-0.5)*50;
          
          ionSizes[i] = Math.random() * 3;
      }
      
      const ionGeo = new THREE.BufferGeometry();
      ionGeo.setAttribute('position', new THREE.BufferAttribute(ionPos, 3));
      ionGeo.setAttribute('size', new THREE.BufferAttribute(ionSizes, 1)); // Custom attribute if shader supported, else ignored or mapped
      
      const ionMat = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 2,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
      });
      
      orbitalIons = new THREE.Points(ionGeo, ionMat);
      scene.add(orbitalIons);

      console.log(`‚öõÔ∏è ORBITAL SYSTEM CREATED: ${connections.length/6} lines + ${ionCount} flowing ions`);
    }

    function removeIonChannels() {
      if (ionLines && scene) {
        scene.remove(ionLines);
        ionLines.geometry?.dispose();
        ionLines.material?.dispose();
        ionLines = null;
      }
      if (orbitalIons && scene) {
        scene.remove(orbitalIons);
        orbitalIons.geometry?.dispose();
        orbitalIons.material?.dispose();
        orbitalIons = null;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚è±Ô∏è TEMPORAL SPEED CONTROL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function setSpeed(speed) {
      timeSpeed = speed;
      isPaused = (speed === 0);
      
      // Update displays
      const display = document.getElementById('speed-display');
      const sliderDisplay = document.getElementById('speedSliderDisplay');
      const slider = document.getElementById('speedSlider');
      
      if (display) {
        if (isPaused) {
          display.textContent = '‚è∏ PAUSED';
          display.style.color = 'var(--text-red)';
        } else if (speed < 0) {
          display.textContent = `‚óÄ ${speed}x`;
          display.style.color = 'var(--text-magenta)';
        } else {
          display.textContent = `‚ñ∂ ${speed}x`;
          display.style.color = 'var(--text-cyan)';
        }
      }
      
      if (sliderDisplay) sliderDisplay.textContent = speed.toFixed(1);
      if (slider) slider.value = speed;
      
      // Highlight active button
      document.querySelectorAll('.temporal-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      console.log(`‚è±Ô∏è Velocidad: ${isPaused ? 'PAUSED' : speed + 'x'}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß≠ QUICK NAVIGATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function goToSingularity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 200,
        y: 100,
        z: 200,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üåå Llegaste a la Singularidad');
        }
      });
    }

    function escapeGravity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 5000,
        y: 3000,
        z: 5000,
        duration: 3,
        ease: 'power2.out',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üöÄ Escapaste de la gravedad');
        }
      });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé® MATRIX COLOR CONTROL (NUEVO)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function setMatrixColor(hexColor) {
      // Convertir hex a n√∫mero para THREE.js
      matrixColor = parseInt(hexColor.replace('#', '0x'), 16);
      
      // Actualizar el color picker visual
      const picker = document.getElementById('matrixColorPicker');
      if (picker) picker.value = hexColor;
      
      // Actualizar matriz si est√° activa
      if (matrixLines) {
        matrixLines.material.color.setHex(matrixColor);
        matrixLines.material.needsUpdate = true;
      }
      
      // Notificar al usuario
      const colorName = {
        '#00ff41': 'Verde Matrix',
        '#00ffff': 'Cyan',
        '#ff00ff': 'Magenta',
        '#ffff00': 'Amarillo',
        '#ff0033': 'Rojo',
        '#ff6600': 'Naranja',
        '#9900ff': 'P√∫rpura',
        '#ffffff': 'Blanco'
      }[hexColor] || 'Personalizado';
      
      showToast(`üé® Matrix: ${colorName}`);
      console.log(`üé® Matrix color changed to: ${hexColor} (${matrixColor})`);
    }

    function goToNearestNode() {
      if (!pointsCloud || !camera) return;
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const camPos = camera.position;
      
      let nearestDist = Infinity;
      let nearestPos = null;
      
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];
        
        const dist = Math.sqrt(
          Math.pow(x - camPos.x, 2) +
          Math.pow(y - camPos.y, 2) +
          Math.pow(z - camPos.z, 2)
        );
        
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestPos = { x, y, z };
        }
      }
      
      if (nearestPos) {
        const direction = new THREE.Vector3(
          camPos.x - nearestPos.x,
          camPos.y - nearestPos.y,
          camPos.z - nearestPos.z
        ).normalize();
        
        const targetPos = {
          x: nearestPos.x + direction.x * 100,
          y: nearestPos.y + direction.y * 100,
          z: nearestPos.z + direction.z * 100
        };
        
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 1.5,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(nearestPos.x, nearestPos.y, nearestPos.z);
            controls.update();
          },
          onComplete: () => {
            showToast('üéØ Nodo m√°s cercano alcanzado');
          }
        });
      }
    }

    function goToRandomPosition() {
      if (!camera) return;
      
      const randomPos = {
        x: (Math.random() - 0.5) * 4000,
        y: (Math.random() - 0.5) * 2000,
        z: (Math.random() - 0.5) * 4000
      };
      
      gsap.to(camera.position, {
        x: randomPos.x,
        y: randomPos.y,
        z: randomPos.z,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üé≤ Posici√≥n aleatoria');
        }
      });
    }

    function toggleImmersionMode() {
      isImmersionMode = !isImmersionMode;
      document.body.style.cursor = isImmersionMode ? 'none' : 'default';
      
      const hud = document.querySelector('.hud-module');
      const toggle = document.querySelector('.immersion-toggle');
      const temporalControls = document.getElementById('temporal-controls');
      
      if (hud) hud.style.display = isImmersionMode ? 'none' : 'block';
      
      // Toggle siempre visible, solo cambia opacidad
      if (toggle) {
        toggle.style.opacity = isImmersionMode ? '0.5' : '1';
        toggle.textContent = isImmersionMode ? 'Exit Immersion [H]' : 'Immersion [H]';
      }
      
      // CRITICAL: Disable OrbitControls in immersive mode
      if (controls) {
        controls.enabled = !isImmersionMode;
      }
      
      // Temporal controls SOLO en modo inmersivo
      if (temporalControls) {
        temporalControls.style.display = isImmersionMode ? 'block' : 'none';
      }
      
      // üåå ZOOM OUT AL ENTRAR EN MODO INMERSIVO
      if (isImmersionMode && camera) {
        // Guardar posici√≥n actual
        const currentPos = camera.position.clone();
        
        // Calcular punto m√°s lejano visible (vista panor√°mica)
        const farDistance = 3000; // Distancia lejana
        const direction = new THREE.Vector3(1, 1, 1).normalize(); // Diagonal
        const farPos = direction.multiplyScalar(farDistance);
        
        // Animar c√°mara hacia posici√≥n lejana
        gsap.to(camera.position, {
          x: farPos.x,
          y: farPos.y,
          z: farPos.z,
          duration: 2,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(0, 0, 0); // Mirar al centro
            controls.update();
          },
          onComplete: () => {
            console.log('üåå Vista panor√°mica activada - Listo para explorar');
          }
        });
      }
      
      console.log(isImmersionMode ? 'üåå IMMERSION ON - Temporal controls habilitados' : 'üåå IMMERSION OFF');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üñ±Ô∏è INTERACTION & RAYCASTING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Expand/Fly to Node
    function onDocumentMouseClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        if (!camera || !mouse) return;
        raycaster.setFromCamera(mouse, camera);
        
        // 1. Check Singularity
        if (centralSingularity) {
            const intersectsSingularity = raycaster.intersectObjects(centralSingularity.children);
            if (intersectsSingularity.length > 0) {
                goToSingularity();
                return;
            }
        }
        
        // 2. Check Nodes
        if (pointsCloud) {
            // Threshold for points (hitbox)
            raycaster.params.Points.threshold = 15; 
            const intersects = raycaster.intersectObject(pointsCloud);
            
            if (intersects.length > 0) {
                const index = intersects[0].index;
                const pos = pointsCloud.geometry.attributes.position;
                
                const targetPos = {
                    x: pos.getX(index),
                    y: pos.getY(index),
                    z: pos.getZ(index)
                };
                
                // "THE FORMULA TO EXPAND" interaction
                // 1. Fly to it
                flyToPosition(targetPos);
                
                // 2. Expand/Highlight (Pulse effect)
                highlightNode(index);
                
                showToast(`üî≠ Nodo #${index} Analizado`);
            }
        }
    }
    
    function flyToPosition(target) {
        if (!camera) return;
        
        // Offset to stop before hitting it
        const offset = 100;
        // Direction from current cam to target
        const direction = new THREE.Vector3(target.x - camera.position.x, target.y - camera.position.y, target.z - camera.position.z).normalize();
        
        const finalPos = {
            x: target.x - direction.x * offset,
            y: target.y - direction.y * offset,
            z: target.z - direction.z * offset
        };

        gsap.to(camera.position, {
            x: finalPos.x,
            y: finalPos.y,
            z: finalPos.z,
            duration: 1.5,
            ease: "power2.inOut",
            onUpdate: () => {
                controls.target.set(target.x, target.y, target.z);
                controls.update();
            }
        });
    }
    
    function highlightNode(index) {
        if (!pointsCloud || !pointsCloud.geometry || !pointsCloud.geometry.attributes.position) return;
        
        const pos = pointsCloud.geometry.attributes.position;
        const x = pos.getX(index);
        const y = pos.getY(index);
        const z = pos.getZ(index);
        
        const glowGeo = new THREE.SphereGeometry(2, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        glowMesh.position.set(x, y, z);
        scene.add(glowMesh);
        
        // Animate Expansion "Explosion"
        gsap.to(glowMesh.scale, { x: 20, y: 20, z: 20, duration: 0.5, ease: "back.out(1.7)" });
        gsap.to(glowMesh.material, { opacity: 0, duration: 0.5, onComplete: () => scene.remove(glowMesh) });
    }

    window.addEventListener('click', onDocumentMouseClick, false);

    // Event listeners (se ejecutan despu√©s de cargar DOM)
    document.addEventListener('DOMContentLoaded', () => {
      // Sliders
      // Sliders with Debounce
      let pendingSliderUpdate = false;
      document.getElementById('nodeSlider')?.addEventListener('input', e => {
        const val = e.target.value;
        const display = document.getElementById('nodeDisplay');
        if (display) display.textContent = parseInt(val).toLocaleString();
        
        if (!pendingSliderUpdate) {
            pendingSliderUpdate = true;
            requestAnimationFrame(() => {
                pendingSliderUpdate = false;
            });
        }
      });
      
      // Regenerate on release
      document.getElementById('nodeSlider')?.addEventListener('change', () => {
         const btn = document.createElement('div'); 
         // Toast or simple reload
         showToast('üîÑ Regenerando universo con nueva capacidad...');
         loadUniverse(currentUniverseSeed);
      });
      document.getElementById('seedSlider')?.addEventListener('input', e => {
        if (document.getElementById('seedDisplay')) document.getElementById('seedDisplay').textContent = e.target.value;
      });

      // Matrix Mode Toggle
      document.getElementById('matrixMode')?.addEventListener('change', e => {
        matrixModeActive = e.target.checked;
        const controls = document.getElementById('matrixControls');
        if (controls) controls.style.display = matrixModeActive ? 'block' : 'none';
        
        if (matrixModeActive) {
          createMatrixLines();
        } else {
          removeMatrixLines();
        }
      });

      // Matrix Color Preset
      document.getElementById('matrixColorPreset')?.addEventListener('change', e => {
        const customGroup = document.getElementById('customColorGroup');
        if (e.target.value === 'custom') {
          customGroup.style.display = 'block';
          const picker = document.getElementById('matrixColorPicker');
          matrixColor = parseInt(picker.value.replace('#', '0x'));
        } else {
          customGroup.style.display = 'none';
          matrixColor = parseInt(e.target.value.replace('#', '0x'));
        }
        updateMatrixColor();
      });

      // Fiesta Mode Toggle
      document.getElementById('fiestaMode')?.addEventListener('change', e => {
        isFiestaMode = e.target.checked;
        if (isFiestaMode) {
          initAudio();
          // Solo auto-clic Matrix si estamos en el modo Orbitador por defecto
          const currentViz = document.getElementById('vizMode')?.value;
          if (currentViz === 'ORBITAL' && !matrixModeActive) {
            document.getElementById('matrixMode').click();
          }
        }
      });

      // Matrix Custom Color Picker
      document.getElementById('matrixColorPicker')?.addEventListener('input', e => {
        matrixColor = parseInt(e.target.value.replace('#', '0x'));
        updateMatrixColor();
      });

      // Matrix Opacity
      document.getElementById('matrixOpacity')?.addEventListener('input', e => {
        matrixOpacity = parseFloat(e.target.value);
        document.getElementById('matrixOpacityDisplay').textContent = matrixOpacity;
        updateMatrixOpacity();
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚è±Ô∏è TEMPORAL CONTROLS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      document.getElementById('speedSlider')?.addEventListener('input', e => {
        const speed = parseFloat(e.target.value);
        setSpeed(speed);
      });

      // Teclado con controles configurables
      document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional (WASD)
        if (k === keyBindings.forward) moveState.forward = 1;
        if (k === keyBindings.back) moveState.back = 1;
        if (k === keyBindings.left) moveState.left = 1;
        if (k === keyBindings.right) moveState.right = 1;
        if (k === keyBindings.up) moveState.up = 1;
        if (k === keyBindings.down) moveState.down = 1;
        
        // Rotaci√≥n de c√°mara (Flechas)
        if (k === 'arrowleft') moveState.rotateLeft = 1;
        if (k === 'arrowright') moveState.rotateRight = 1;
        if (k === 'arrowup') moveState.rotateUp = 1;
        if (k === 'arrowdown') moveState.rotateDown = 1;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 2.0;
          acceleration = 9.0;
          maxSpeed = 90;
        }
        
        // Acciones
        if (k === keyBindings.immersion || k === 'l') toggleImmersionMode();
        if (k === keyBindings.resetCamera) resetCamera();
        if (k === '?' || k === '/') openTutorial();
      });

      document.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional
        if (k === keyBindings.forward) moveState.forward = 0;
        if (k === keyBindings.back) moveState.back = 0;
        if (k === keyBindings.left) moveState.left = 0;
        if (k === keyBindings.right) moveState.right = 0;
        if (k === keyBindings.up) moveState.up = 0;
        if (k === keyBindings.down) moveState.down = 0;
        
        // Rotaci√≥n de c√°mara
        if (k === 'arrowleft') moveState.rotateLeft = 0;
        if (k === 'arrowright') moveState.rotateRight = 0;
        if (k === 'arrowup') moveState.rotateUp = 0;
        if (k === 'arrowdown') moveState.rotateDown = 0;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 1.0;
          acceleration = 4.5;
          maxSpeed = 45;
        }
      });

      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéÆ GAMEPAD / JOYSTICK SUPPORT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      let gamepadConnected = false;
      let gamepadIndex = null;

      window.addEventListener('gamepadconnected', (e) => {
        gamepadConnected = true;
        gamepadIndex = e.gamepad.index;
        console.log(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
        showToast(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
      });

      window.addEventListener('gamepaddisconnected', (e) => {
        gamepadConnected = false;
        gamepadIndex = null;
        console.log('üéÆ Gamepad desconectado');
      });

      function updateGamepad() {
        if (!gamepadConnected || gamepadIndex === null) return;

        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad) return;

        // Stick izquierdo: Movimiento horizontal/vertical
        const leftX = gamepad.axes[0]; // -1 (izq) a +1 (der)
        const leftY = gamepad.axes[1]; // -1 (arriba) a +1 (abajo)

        // Deadzone para evitar drift
        const deadzone = 0.15;

        // Movimiento con stick izquierdo
        if (Math.abs(leftX) > deadzone) {
          moveState.left = leftX < 0 ? -leftX : 0;
          moveState.right = leftX > 0 ? leftX : 0;
        } else {
          moveState.left = 0;
          moveState.right = 0;
        }

        if (Math.abs(leftY) > deadzone) {
          moveState.forward = leftY < 0 ? -leftY : 0;
          moveState.back = leftY > 0 ? leftY : 0;
        } else {
          moveState.forward = 0;
          moveState.back = 0;
        }

        // Stick derecho: Rotaci√≥n c√°mara (PR-3)
        const rightX = gamepad.axes[2];
        const rightY = gamepad.axes[3];

        if (Math.abs(rightX) > deadzone) {
          moveState.rotateLeft = rightX < 0 ? -rightX : 0;
          moveState.rotateRight = rightX > 0 ? rightX : 0;
        } else {
          moveState.rotateLeft = 0;
          moveState.rotateRight = 0;
        }

        if (Math.abs(rightY) > deadzone) {
          moveState.rotateUp = rightY < 0 ? -rightY : 0;
          moveState.rotateDown = rightY > 0 ? rightY : 0;
        } else {
          moveState.rotateUp = 0;
          moveState.rotateDown = 0;
        }

        // Gatillos: Subir/Bajar (PR-3)
        const lt = gamepad.buttons[6]?.value || 0; // L2/LT
        const rt = gamepad.buttons[7]?.value || 0; // R2/RT
        moveState.down = lt;
        moveState.up = rt;

        // Botones de acci√≥n con debounce (PR-3)
        if (!gamepad.buttonStates) gamepad.buttonStates = {};
        
        const checkButton = (index, callback) => {
          const isPressed = gamepad.buttons[index]?.pressed;
          if (isPressed && !gamepad.buttonStates[index]) {
            callback();
          }
          gamepad.buttonStates[index] = isPressed;
        };

        checkButton(0, goToNearestNode);      // A -> Fly to Node
        checkButton(1, resetCamera);          // B -> Reset
        checkButton(2, toggleImmersionMode);  // X -> Immersion
        checkButton(3, goToSingularity);      // Y -> Center

        // R1 (5) - Speed Boost
        if (gamepad.buttons[5]?.pressed) {
          speedBoost = 2.0;
          acceleration = 9.0;
          maxSpeed = 90;
        } else {
          speedBoost = 1.0;
          acceleration = 4.5;
          maxSpeed = 45;
        }
      }

      // Llamar updateGamepad en cada frame
      function gamepadLoop() {
        updateGamepad();
        requestAnimationFrame(gamepadLoop);
      }
      gamepadLoop();

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚öôÔ∏è SETTINGS PANEL FUNCTIONS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      function openSettings() {
        document.getElementById('settings-panel').style.display = 'flex';
        updateKeyBindingsUI();
      }

      function closeSettings() {
        document.getElementById('settings-panel').style.display = 'none';
        saveKeyBindings();
      }

      function openTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'flex';
      }

      function closeTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'none';
      }

      function updateKeyBindingsUI() {
        const container = document.getElementById('key-bindings-list');
        const labels = {
          forward: 'Adelante',
          back: 'Atr√°s',
          left: 'Izquierda',
          right: 'Derecha',
          up: 'Subir',
          down: 'Bajar',
          rotateLeft: 'Rotar Izq',
          rotateRight: 'Rotar Der',
          speedBoost: 'Speed Boost',
          immersion: 'Immersion',
          resetCamera: 'Reset C√°mara'
        };

        container.innerHTML = '';
        for (const [action, key] of Object.entries(keyBindings)) {
          const div = document.createElement('div');
          div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(0,242,255,0.05);border:1px solid var(--glass-border);border-radius:4px;';
          div.innerHTML = `
            <span style="color:#888;">${labels[action] || action}</span>
            <button onclick="rebindKey('${action}')" style="width:auto;padding:5px 15px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);text-transform:uppercase;">
              ${keyBindings[action] === ' ' ? 'SPACE' : keyBindings[action].toUpperCase()}
            </button>
          `;
          container.appendChild(div);
        }
      }

      let rebindingAction = null;

      function rebindKey(action) {
        rebindingAction = action;
        showToast('‚å®Ô∏è Presiona la nueva tecla para ' + action, 5000);
        
        const listener = (e) => {
          e.preventDefault();
          const newKey = e.key.toLowerCase();
          keyBindings[action] = newKey;
          updateKeyBindingsUI();
          rebindingAction = null;
          document.removeEventListener('keydown', listener);
          showToast(`‚úÖ ${action} ‚Üí ${newKey === ' ' ? 'SPACE' : newKey.toUpperCase()}`);
        };
        
        document.addEventListener('keydown', listener);
      }

      // Toast notification helper
      function showToast(message, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.cssText = `
          position:fixed; top:80px; right:20px; z-index:10000;
          background:rgba(0,242,255,0.2); border:1px solid var(--text-cyan);
          padding:15px 20px; border-radius:8px; color:var(--text-cyan);
          font-size:0.9rem; pointer-events:none;
          animation: slideIn 0.3s ease-out;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      window.addEventListener('resize', () => {
        if (camera) {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(innerWidth, innerHeight);
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üöÄ Fly-to Cinematic (PR-3)
      function flyTo(targetPosition, duration = 2) {
        if (!camera || !controls) return;
        
        const offset = new THREE.Vector3().subVectors(camera.position, controls.target);
        
        // Bloquear controles manuales durante el vuelo
        const wasOrbitEnabled = controls.enabled;
        controls.enabled = false;

        gsap.to(controls.target, {
          x: targetPosition.x,
          y: targetPosition.y,
          z: targetPosition.z,
          duration: duration,
          ease: "power2.inOut",
          onUpdate: () => controls.update()
        });
        
        gsap.to(camera.position, {
          x: targetPosition.x + offset.x,
          y: targetPosition.y + offset.y,
          z: targetPosition.z + offset.z,
          duration: duration,
          ease: "power2.inOut",
          onComplete: () => {
            controls.enabled = wasOrbitEnabled;
          }
        });
        
        showToast(`üöÄ WARPING...`);
      }

      function goToSingularity() {
        if (centralSingularity) {
          flyTo(centralSingularity.position, 2.5);
        }
      }

      function goToNearestNode() {
        if (!scene) return;
        
        let nearestPosition = new THREE.Vector3();
        let minDistance = Infinity;
        let found = false;

        scene.traverse(obj => {
          if (obj.isInstancedMesh) {
            const matrix = new THREE.Matrix4();
            const pos = new THREE.Vector3();
            for (let i = 0; i < obj.count; i++) {
              obj.getMatrixAt(i, matrix);
              pos.setFromMatrixPosition(matrix);
              const dist = camera.position.distanceTo(pos);
              if (dist < minDistance && dist > 50) {
                minDistance = dist;
                nearestPosition.copy(pos);
                found = true;
              }
            }
          }
        });

        if (found) {
          flyTo(nearestPosition, 1.5);
        } else {
          showToast("‚ö†Ô∏è Constant distance limit reached");
        }
      }

    // Init logic when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
       if (typeof updateKeyBindingsUI === 'function') updateKeyBindingsUI();
       initQuickNavDrag();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öîÔ∏è RPG ACTION BAR LOGIC & UI INJECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. Inject CSS
    const actionBarStyle = document.createElement('style');
    actionBarStyle.textContent = `
      #action-bar {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 10001;
        background: rgba(0, 0, 0, 0.6);
        padding: 5px;
        border: 1px solid var(--glass-border);
        border-radius: 6px;
        backdrop-filter: blur(10px);
      }
      .action-slot {
        width: 50px;
        height: 50px;
        position: relative;
        background: rgba(0, 20, 20, 0.8);
        border: 1px solid #444;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .action-slot:hover {
        border-color: var(--text-cyan);
        box-shadow: 0 0 10px rgba(0,242,255,0.3);
      }
      .action-slot.active {
        background: rgba(0, 242, 255, 0.2);
        border-color: var(--text-magenta);
      }
      .action-key {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 0.7rem;
        color: var(--text-yellow);
        font-weight: bold;
      }
      .action-icon {
        font-size: 1.5rem;
      }
    `;
    document.head.appendChild(actionBarStyle);

    // 2. Inject HTML
    // Wait for body to be ready if not already (safeguard)
    if (document.body) {
        injectActionBar();
    } else {
        document.addEventListener('DOMContentLoaded', injectActionBar);
    }

    function injectActionBar() {
        if(document.getElementById('action-bar')) return;
        const bar = document.createElement('div');
        bar.id = 'action-bar';
        bar.innerHTML = `
          <div class="action-slot" onclick="triggerAction('Q')" title="Toggle Matrix">
            <span class="action-key">Q</span>
            <span class="action-icon">üü¢</span>
          </div>
          <div class="action-slot" onclick="triggerAction('W')" title="Toggle Ion Channels">
            <span class="action-key">W</span>
            <span class="action-icon">‚öõÔ∏è</span>
          </div>
          <div class="action-slot" onclick="triggerAction('E')" title="Warp / Fly">
            <span class="action-key">E</span>
            <span class="action-icon">üöÄ</span>
          </div>
          <div class="action-slot" onclick="triggerAction('R')" title="Reset Camera">
            <span class="action-key">R</span>
            <span class="action-icon">üé•</span>
          </div>
          <div class="action-slot" onclick="triggerAction('F')" title="FIESTA MODE (Rainbow)">
            <span class="action-key">F</span>
            <span class="action-icon">üåà</span>
          </div>
        `;
        document.body.appendChild(bar);
    }
    
    // 3. Logic
    const rpgKeyBindings = {
      forward: 'arrowup',
      back: 'arrowdown',
      left: 'arrowleft',
      right: 'arrowright', 
      skill_q: 'q',
      skill_w: 'w',
      skill_e: 'e',
      skill_r: 'r',
      skill_f: 'f',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'x'
    };
    
    // Merge RPG bindings into active bindings
    Object.assign(keyBindings, rpgKeyBindings);

    function triggerAction(key) {
       const slot = Array.from(document.querySelectorAll('.action-key')).find(el => el.textContent === key)?.parentElement;
       if(slot) {
           slot.classList.add('active');
           setTimeout(() => slot.classList.remove('active'), 200);
       }
       
       switch(key) {
           case 'Q': 
               const mat = document.getElementById('matrixMode');
               if(mat) mat.click(); 
               showToast('Q: Matrix Toggle');
               break;
           case 'W':
               const ion = document.getElementById('ionChannelsToggle');
               if(ion) ion.click();
               showToast('W: Ion Channels Toggle');
               break;
           case 'E':
               if(centralSingularity) {
                  controls.target.copy(centralSingularity.position);
                  camera.position.set(0, 200, 500); 
                  showToast('E: Warp Core');
               }
               break;
           case 'R':
               resetCamera();
               showToast('R: Camera Reset');
               break;
           case 'F':
               const fiesta = document.getElementById('fiestaMode');
               if(fiesta) {
                   fiesta.click(); // This toggles checked state and fires change event
                   showToast('F: üî• FIESTA MODE TOGGLE üî•');
               }
               break;
       }
    }

    // Init Quick Nav Drag (Preserved)
    function initQuickNavDrag() {
       // ... (rest of function as before)
       const panel = document.getElementById('quick-nav-panel');
       const handle = document.getElementById('quick-nav-handle');
       if (!panel || !handle) return;
       // ... 
       // Only partial replace to keep code short? 
       // No, I must include the full function if I replace the block.
       // I'll assume the original 'initQuickNavDrag' is the target to keep or I put it before closing script.
       
       let isDragging = false;
       let startX, startY, initialLeft, initialTop;

       handle.addEventListener('mousedown', (e) => {
         e.preventDefault();
         isDragging = true;
         startX = e.clientX;
         startY = e.clientY;
         const rect = panel.getBoundingClientRect();
         initialLeft = rect.left;
         initialTop = rect.top;
         panel.style.transform = 'none';
         panel.style.bottom = 'auto';
         panel.style.left = initialLeft + 'px';
         panel.style.top = initialTop + 'px';
         handle.style.cursor = 'grabbing';
       });

       document.addEventListener('mousemove', (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const dx = e.clientX - startX;
         const dy = e.clientY - startY;
         panel.style.left = (initialLeft + dx) + 'px';
         panel.style.top = (initialTop + dy) + 'px';
       });
       
       document.addEventListener('mouseup', () => {
         if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
         }
       });
    }

    // KEY LISTENER UPDATE for Skills
    document.addEventListener('keydown', e => {
         // ... (existing listeners might conflict if I don't remove them or merge)
         // Since I am replacing the block at end of generic script, I might be outside the main listener scope.
         // Wait, the original code had the listener inside the main script block.
         // I am INJECTING this at the end of the file/script?
         // The `view_file` showed 'initQuickNavDrag' near the end.
         // I will simply add a NEW listener for the Skills to avoid messing with the complex existing one for now,
         // OR I should have modified the `defaultKeyBindings` definition at the top.
         // But I am rewriting `initQuickNavDrag` as anchor.
         
         const k = e.key.toLowerCase();
         if(k === 'q' && !e.repeat) triggerAction('Q');
         if(k === 'w' && !e.repeat) triggerAction('W');
         if(k === 'e' && !e.repeat) triggerAction('E');
         if(k === 'r' && !e.repeat) triggerAction('R');
         if(k === 'f' && !e.repeat) triggerAction('F');
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß† NARRATIVE INTELLIGENCE (PR-4)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let narrativeEventSource = null;

    function initiateNarrativeStream() {
      if (narrativeEventSource) {
        narrativeEventSource.close();
      }

      const narrativeBox = document.getElementById('narrative-module');
      const narrativeText = document.getElementById('narrative-text');
      const subtitleBox = document.getElementById('subtitle-box');
      
      if (!narrativeBox || !narrativeText) return;

      // Show module
      narrativeBox.style.display = 'block';
      narrativeText.textContent = '';
      if (subtitleBox) subtitleBox.textContent = '';

      const seed = currentUniverseSeed;
      const horror = currentUniverseData.horror_total || 0;
      const nodes = totalNodes;
      const mode = currentUniverseData.modo || 'UNKNOWN';
      const persona = document.getElementById('personaSelector')?.value || 'AUTO';

      const url = `/api/narrative_stream?seed=${seed}&horror=${horror}&nodes=${nodes}&mode=${mode}&persona=${persona}`;
      narrativeEventSource = new EventSource(url);

      narrativeEventSource.onmessage = (event) => {
        const data = JSON.parse(event.data);
        typewriterEffect(data.text, narrativeText, subtitleBox);
        speakNarrative(data.text); // PR-5: TTS Integration
        
        // PR-9: SPARK NEURAL PULSE on narrative
        if (currentUniverseData?.nodes && currentUniverseData.nodes.length > 0) {
           const randomNode = currentUniverseData.nodes[Math.floor(Math.random() * currentUniverseData.nodes.length)];
           if (randomNode.position) spawnNeuralPulse(randomNode.position);
        }
      };

      narrativeEventSource.onerror = (err) => {
        console.error("Narrative stream error:", err);
        narrativeEventSource.close();
      };
    }

    function typewriterEffect(text, targetEl, subtitleEl) {
      // ... (existing code handles display)
      let i = 0;
      const speed = 30; 
      
      function type() {
        if (i < text.length) {
          targetEl.textContent += text.charAt(i);
          if (subtitleEl) subtitleEl.textContent = targetEl.textContent;
          i++;
          setTimeout(type, speed);
        } else {
          if (text.endsWith('.')) {
             setTimeout(() => { if(subtitleEl) subtitleEl.textContent = ''; }, 3000);
          }
        }
      }
      type();
    }

    // üîä TEXT-TO-SPEECH (PR-5)
    function speakNarrative(text) {
      if (!window.speechSynthesis) return;
      
      // Cancel previous speech to avoid overlapping
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      
      // Select a "deep" or "robotic" voice if available
      const voices = window.speechSynthesis.getVoices();
      // Prefer Spanish/Latam voices
      const voice = voices.find(v => v.lang.includes('es')) || voices[0];
      
      if (voice) utterance.voice = voice;
      
      // PR-12: ASI Narrator Voice
      if (isASIActive) {
        utterance.pitch = 0.2; // Extremadamente profunda y mec√°nica
        utterance.rate = 0.7;  // Pausada, omnisciente
        utterance.volume = 1.0;
      } else {
        utterance.pitch = 0.6; // Deep cosmic voice
        utterance.rate = 0.9;  // Solemn slow rate
        utterance.volume = 0.8;
      }
      
      window.speechSynthesis.speak(utterance);
    }

    function updatePredictivePanel(analysis) {
      const panel = document.getElementById('predictive-panel');
      const alert = document.getElementById('collapse-alert');
      const prob = document.getElementById('collapse-prob');
      const driversList = document.getElementById('drivers-list');
      
      if (!panel || !alert || !prob || !driversList) return;

      const probability = analysis.collapse_probability || 0;
      const probPercent = (probability * 100).toFixed(1);
      
      prob.textContent = `${probPercent}%`;
      panel.style.display = 'block';

      // PR-9 Update
      const neuralVal = document.getElementById('neural-val');
      const neuralFill = document.getElementById('neural-fill');
      if (neuralVal && neuralFill) {
        const act = (analysis.neural_activity || 0) * 100;
        neuralVal.textContent = `${act.toFixed(1)}%`;
        neuralFill.style.width = `${act}%`;
      }

      // PR-10 Badge Update
      const recursionBadge = document.getElementById('recursion-badge');
      if (recursionBadge) {
        recursionBadge.style.display = analysis.is_optimized ? 'block' : 'none';
      }

      if (probability > 0.8) {
        alert.textContent = "CRITICAL COLLAPSE INMINENT";
        alert.style.background = "rgba(255,0,0,0.6)";
      } else if (probability > 0.5) {
        alert.textContent = "WARNING: REALITY UNSTABLE";
        alert.style.background = "rgba(255,165,0,0.4)";
      } else {
        alert.textContent = "REALITY STABLE";
        alert.style.background = "rgba(0,255,65,0.2)";
      }

      // PR-12: ASI Event Horizon
      if (probability > 0.9) {
        triggerASIEventHorizon();
      }

      // Update Drivers
      driversList.innerHTML = '';
      const drivers = analysis.top_drivers || [];
      const maxHorror = drivers.length > 0 ? drivers[0].horror_total : 1;

      drivers.forEach(d => {
        const item = document.createElement('div');
        item.className = 'driver-item';
        const percent = ((d.horror_total / maxHorror) * 100).toFixed(0);
        
        item.innerHTML = `
          <span>${d.dim}</span>
          <div style="width: 100px;">
            <div class="driver-bar"><div class="driver-fill" style="width: ${percent}%"></div></div>
          </div>
        `;
        driversList.appendChild(item);
      });
    }
    
    // üåÄ Phase 18: RESONANCE CYCLE & BIODATA
    async function triggerResonanceCycle() {
      showToast('üåÄ INITIATING RESONANCE CYCLE...', 3000);
      const freq = document.getElementById('freqSlider')?.value || 440;
      
      try {
        const res = await fetch(`/api/ingest_real?freq=${freq}`);
        const data = await res.json();
        
        if (data.status === 'QUARANTINED') {
          showToast('üõë ERROR: SYSTEM QUARANTINED', 10000);
          document.getElementById('bio-sync-status').textContent = 'STATUS: QUARANTINED';
          document.getElementById('bio-sync-status').style.color = 'var(--text-red)';
          return;
        }
        
        currentUniverseSeed = data.seed;
        showToast(`‚úÖ RESONANCE ACHIEVED: Seed ${data.seed}`);
        
        // Update Bio HUD with real data from orchestrator
        if (data.resonance_data) {
           updateBioHUD(data.resonance_data);
        }
        
        loadUniverse(data.seed);
      } catch (e) {
        console.error("Resonance Error:", e);
        showToast('‚ùå RESONANCE FAILURE');
      } finally {
        document.getElementById('loading-overlay').style.display = 'none';
      }
    }

    function updateBioHUD(resData) {
       const bio = resData.bio_entropy || 0.5;
       if (document.getElementById('val-human')) document.getElementById('val-human').textContent = (bio * 20).toFixed(1) + ' Hz';
       if (document.getElementById('bar-human')) document.getElementById('bar-human').style.width = (bio * 100) + '%';
       
       if (document.getElementById('val-animal')) document.getElementById('val-animal').textContent = (bio * 1.5).toFixed(2);
       if (document.getElementById('bar-animal')) document.getElementById('bar-animal').style.width = (bio * 90) + '%';
       
       if (document.getElementById('val-plant')) document.getElementById('val-plant').textContent = (400 + bio * 200).toFixed(0) + 'nm';
       if (document.getElementById('bar-plant')) document.getElementById('bar-plant').style.width = (30 + bio * 40) + '%';
       
       if (document.getElementById('val-fungi')) document.getElementById('val-fungi').textContent = (bio * 8).toFixed(1) + 'k Œºm';
       if (document.getElementById('bar-fungi')) document.getElementById('bar-fungi').style.width = (bio * 75) + '%';
       
       const risk = resData.ethical_risk || 0;
       const statusEl = document.getElementById('bio-sync-status');
       if (statusEl) {
         if (risk > 0.7) {
            statusEl.textContent = 'COSMOS: DISSONANT';
            statusEl.style.color = 'var(--text-red)';
         } else {
            statusEl.textContent = 'COSMOS: SYNCHRONIZED';
            statusEl.style.color = 'var(--text-green)';
         }
       }
    }

    // üîå API Config Save
    function saveAPIConfig() {
      const config = {
        llm: {
          provider: document.getElementById('llmProvider')?.value,
          apiKey: document.getElementById('apiKeyInput')?.value
        },
        db: {
          provider: document.getElementById('dbProvider')?.value,
          connString: document.getElementById('dbConnString')?.value
        },
        quantum: {
          backend: document.getElementById('quantumBackend')?.value,
          token: document.getElementById('quantumToken')?.value
        },
        mcp: {
          mode: document.getElementById('mcpAgentMode')?.value,
          fileAccess: document.getElementById('mcpFileAccess')?.checked,
          webAccess: document.getElementById('mcpWebAccess')?.checked,
          codeExec: document.getElementById('mcpCodeExec')?.checked,
          dbAccess: document.getElementById('mcpDbAccess')?.checked
        }
      };
      
      localStorage.setItem('cosmic_full_config', JSON.stringify(config));
      
      showToast(`‚úÖ All Config Saved: LLM=${config.llm.provider}, DB=${config.db.provider}, Quantum=${config.quantum.backend}`);
      console.log('[CONFIG] Full config saved:', config);
    }

    // Load saved API config on startup  
    function loadAPIConfig() {
      const savedConfig = localStorage.getItem('cosmic_full_config');
      if (savedConfig) {
        try {
          const config = JSON.parse(savedConfig);
          
          if (config.llm?.provider) document.getElementById('llmProvider').value = config.llm.provider;
          if (config.db?.provider) document.getElementById('dbProvider').value = config.db.provider;
          if (config.db?.connString) document.getElementById('dbConnString').value = config.db.connString;
          if (config.quantum?.backend) document.getElementById('quantumBackend').value = config.quantum.backend;
          if (config.mcp?.mode) document.getElementById('mcpAgentMode').value = config.mcp.mode;
          if (config.mcp?.fileAccess !== undefined) document.getElementById('mcpFileAccess').checked = config.mcp.fileAccess;
          if (config.mcp?.webAccess !== undefined) document.getElementById('mcpWebAccess').checked = config.mcp.webAccess;
          if (config.mcp?.codeExec !== undefined) document.getElementById('mcpCodeExec').checked = config.mcp.codeExec;
          if (config.mcp?.dbAccess !== undefined) document.getElementById('mcpDbAccess').checked = config.mcp.dbAccess;
          
          console.log('[CONFIG] Loaded saved config');
        } catch(e) {
          console.warn('Could not load saved config:', e);
        }
      }
    }

    // üì° PREDICTIVE ANALYSIS UPDATE
    function updatePredictiveAnalysis() {
      if (!currentUniverseData) return;
      
      const horror = currentUniverseData.horror_total || 0;
      const seed = Math.abs(currentUniverseSeed || 1);
      
      // Calculate AGI Neural Activity (simulated)
      const agiActivity = Math.min(100, (Math.sin(Date.now() * 0.001) + 1) * 40 + (horror / 500));
      document.getElementById('agi-neural-val').textContent = agiActivity.toFixed(1) + '%';
      document.getElementById('agi-neural-bar').style.width = agiActivity + '%';
      
      // Calculate ASI Sync
      const asiSync = Math.min(100, (Math.cos(Date.now() * 0.002 + seed) + 1) * 30 + (horror / 400));
      document.getElementById('asi-sync-val').textContent = asiSync.toFixed(1) + '%';
      document.getElementById('asi-sync-bar').style.width = asiSync + '%';
      
      // Calculate Collapse Probability
      let collapseProb = Math.min(99.9, (horror / 200000) * 100);
      collapseProb += (Math.random() * 2); // Jitter
      document.getElementById('collapse-prob').textContent = collapseProb.toFixed(1) + '%';
      
      // Update Status Box
      const statusBox = document.getElementById('agi-status-box');
      const statusText = document.getElementById('agi-status-text');
      
      if (statusBox && statusText) {
          if (collapseProb > 80) {
            statusText.textContent = 'CRITICAL COLLAPSE';
            statusText.style.color = 'var(--text-red)';
            statusBox.style.borderColor = 'var(--text-red)';
            statusBox.style.background = 'rgba(50,0,0,0.8)';
          } else if (collapseProb > 40) {
            statusText.textContent = 'UNSTABLE';
            statusText.style.color = 'var(--text-yellow)';
            statusBox.style.borderColor = 'var(--text-yellow)';
            statusBox.style.background = 'rgba(50,50,0,0.6)';
          } else {
            statusText.textContent = 'STABLE';
            statusText.style.color = 'var(--text-cyan)'; 
            statusBox.style.borderColor = 'var(--text-cyan)';
            statusBox.style.background = 'rgba(0,20,20,0.6)';
          }
      }
      
      // Animate Decryption Icon
      const icon = document.getElementById('decryptions-icon');
      if (icon) {
          if (Date.now() % 1000 < 500) {
            icon.style.opacity = '1';
          } else {
            icon.style.opacity = '0.5';
          }
      }
    }

    // üîç Test Connections
    async function testConnections() {
      showToast('üîç Testing all connections...', 3000);
      
      const results = [];
      
      // Test LLM
      try {
        const llmRes = await fetch('/api/narrative_stream?seed=1&horror=100&nodes=10&mode=TEST&persona=AUTO');
        results.push({ name: 'LLM', status: llmRes.ok ? '‚úÖ' : '‚ùå' });
      } catch(e) {
        results.push({ name: 'LLM', status: '‚ùå' });
      }
      
      // Test DB (via existing endpoint)
      try {
        const dbRes = await fetch('/hall_of_shame');
        results.push({ name: 'Database', status: dbRes.ok ? '‚úÖ' : '‚ùå' });
      } catch(e) {
        results.push({ name: 'Database', status: '‚ùå' });
      }
      
      // Test Quantum (simulated)
      results.push({ name: 'Quantum', status: '‚úÖ (Simulated)' });
      
      // Test MCP
      results.push({ name: 'MCP Agent', status: '‚úÖ (Active)' });
      
      const summary = results.map(r => `${r.name}: ${r.status}`).join(' | ');
      showToast(`üîó ${summary}`, 5000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ü§ñ AI CHAT PANEL (Phase 20)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let chatAttachments = [];
    let chatHistory = [];

    function toggleChatPanel() {
      const panel = document.getElementById('ai-chat-panel');
      const toggleBtn = document.getElementById('chat-toggle-btn');
      if (panel.style.display === 'none') {
        panel.style.display = 'flex';
        toggleBtn.style.display = 'none';
      } else {
        panel.style.display = 'none';
        toggleBtn.style.display = 'block';
      }
    }

    function openChatPanel() {
      document.getElementById('ai-chat-panel').style.display = 'flex';
      document.getElementById('chat-toggle-btn').style.display = 'none';
    }

    function toggleChatTools() {
      const tools = document.getElementById('chat-tools');
      tools.style.display = tools.style.display === 'none' ? 'block' : 'none';
    }

    function updateChatContext() {
      document.getElementById('ctx-seed').textContent = currentUniverseSeed || -10;
      document.getElementById('ctx-horror').textContent = Math.round(currentUniverseData?.horror_total || 0);
      document.getElementById('ctx-nodes').textContent = totalNodes || 0;
      document.getElementById('chat-seed').textContent = currentUniverseSeed || -10;
    }

    async function handleChatFileUpload(input) {
      if (input.files && input.files[0]) {
        const file = input.files[0];
        const reader = new FileReader();
        
        reader.onload = function(e) {
          const dataUrl = e.target.result;
          let type = 'file';
          if (file.type.startsWith('image/')) type = 'image';
          else if (file.type.startsWith('audio/')) type = 'audio';
          else if (file.type.startsWith('video/')) type = 'video';
          
          chatAttachments.push({
            type: type,
            name: file.name,
            data: dataUrl,
            timestamp: Date.now(),
            context: {
              seed: currentUniverseSeed,
              horror: currentUniverseData?.horror_total || 0
            }
          });
          
          renderAttachments();
        };
        
        reader.readAsDataURL(file);
      }
      // Reset input
      input.value = '';
    }

    async function generateCustomEndpoint() {
      const token = 'sk-' + Math.random().toString(36).substr(2, 9) + '-' + Math.random().toString(36).substr(2, 9);
      copyToClipboard(token, 'New Token');
      showToast(`üîë Token Generated: ${token}`, 4000);
    }
    
    function copyToClipboard(text, label) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
          showToast(`üìã Copied ${label}`, 2000);
        }).catch(err => {
           // Fallback if promise fails
           fallbackCopy(text, label);
        });
      } else {
        fallbackCopy(text, label);
      }
    }
    
    function fallbackCopy(text, label) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
           document.execCommand("Copy");
           showToast(`üìã Copied ${label}`, 2000);
        } catch(e) {
           showToast(`‚ùå Copy failed`, 2000);
        }
        textArea.remove();
    }

    // Consolidated render function
    function renderAttachments() {
      const attachList = document.getElementById('attachment-list');
      attachList.innerHTML = '';
      
      chatAttachments.forEach((att, i) => {
        const preview = document.createElement('div');
        preview.style.cssText = 'position:relative; width:50px; height:50px; border-radius:4px; overflow:hidden; border:1px solid var(--glass-border); background:#222;';
        
        let content = '';
        if (att.type === 'screenshot' || att.type === 'image') {
          content = `<img src="${att.data}" style="width:100%; height:100%; object-fit:cover;">`;
        } else if (att.type === 'audio') {
          content = `<div style="display:flex;justify-content:center;align-items:center;height:100%;color:var(--text-cyan);font-size:1.5rem;">üéµ</div>`;
        } else if (att.type === 'video') {
          content = `<div style="display:flex;justify-content:center;align-items:center;height:100%;color:var(--text-magenta);font-size:1.5rem;">üé¨</div>`;
        } else {
           content = `<div style="display:flex;justify-content:center;align-items:center;height:100%;color:#aaa;font-size:1rem;">üìÑ</div>`;
        }
        
        preview.innerHTML = `
          ${content}
          <button onclick="removeAttachment(${i})" style="position:absolute; top:0; right:0; width:15px; height:15px; background:rgba(255,0,0,0.8); border:none; color:white; font-size:0.6rem; cursor:pointer; display:flex; justify-content:center; align-items:center;">√ó</button>
        `;
        attachList.appendChild(preview);
      });
      
      document.getElementById('chat-attachments').style.display = chatAttachments.length > 0 ? 'block' : 'none';
    }

    function removeAttachment(index) {
      chatAttachments.splice(index, 1);
      renderAttachments();
    }
    
    // Update attachScreenshot to use new render
    async function attachScreenshot() {
      showToast('üì∏ Capturando universo...', 1500);
      try {
        const canvas = document.querySelector('#canvas-container canvas');
        if (!canvas) { showToast('‚ùå No canvas found', 2000); return; }
        
        const dataUrl = canvas.toDataURL('image/png');
        chatAttachments.push({
          type: 'screenshot',
          data: dataUrl,
          timestamp: Date.now(),
          context: { seed: currentUniverseSeed, horror: currentUniverseData?.horror_total || 0 }
        });
        
        renderAttachments();
        showToast('‚úÖ Sc attached');
      } catch(e) { console.error(e); }
    }

    async function sendChatMessage() {
      const input = document.getElementById('chat-input');
      const message = input.value.trim();
      if (!message && chatAttachments.length === 0) return; // Allow sending just attachment
      
      input.value = '';
      updateChatContext();
      
      const messagesDiv = document.getElementById('chat-messages');
      
      // Add user message
      const userMsg = document.createElement('div');
      userMsg.className = 'chat-msg user';
      userMsg.style.cssText = 'margin:8px 0; text-align:right;';
      
      let attachmentHtml = '';
      if (chatAttachments.length > 0) {
        attachmentHtml = `<div style="margin-top:5px; display:flex; gap:5px; flex-wrap:wrap; justify-content:flex-end;">`;
        chatAttachments.forEach(att => {
             if (att.type === 'image' || att.type === 'screenshot') {
                 attachmentHtml += `<img src="${att.data}" style="width:50px; height:50px; object-fit:cover; border-radius:4px; border:1px solid var(--text-cyan);">`;
             } else if (att.type === 'audio') {
                 attachmentHtml += `<span style="font-size:1.5rem;" title="Audio">üéµ</span>`;
             } else if (att.type === 'video') {
                 attachmentHtml += `<span style="font-size:1.5rem;" title="Video">üé¨</span>`;
             }
        });
        attachmentHtml += `</div>`;
      }
      
      userMsg.innerHTML = `<span style="background:rgba(0,242,255,0.2); padding:5px 10px; border-radius:10px; color:var(--text-cyan); display:inline-block;">${message || '(Attachment sent)'}</span>${attachmentHtml}`;
      messagesDiv.appendChild(userMsg);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      // Build context
      const tools = {
        rag: document.getElementById('tool-rag')?.checked,
        quantum: document.getElementById('tool-quantum')?.checked,
        db: document.getElementById('tool-db')?.checked,
        mcp: document.getElementById('tool-mcp')?.checked,
        langchain: document.getElementById('tool-langchain')?.checked,
        web: document.getElementById('tool-web')?.checked
      };
      
      const provider = document.getElementById('chatProvider')?.value || 'deepseek';
      
      // Get API Key from config
      let apiKey = '';
      try {
        const savedConfig = JSON.parse(localStorage.getItem('cosmic_full_config') || '{}');
        if (savedConfig.llm && savedConfig.llm.apiKey) {
           apiKey = savedConfig.llm.apiKey;
        }
      } catch(e) {}

      const payload = {
        message,
        provider,
        apiKey, // Send key
        tools,
        context: {
          seed: currentUniverseSeed,
          horror: currentUniverseData?.horror_total || 0,
          nodes: totalNodes,
          mode: currentUniverseData?.modo || 'UNKNOWN',
          bio_state: document.getElementById('bio-sync-status')?.textContent || 'UNKNOWN'
        },
        attachments: chatAttachments.map(a => ({ type: a.type, context: a.context })),
        history: chatHistory.slice(-5) // Last 5 messages for context
      };
      
      // Store in history
      chatHistory.push({ role: 'user', content: message });
      
      // Clear attachments after sending
      chatAttachments = [];
      document.getElementById('attachment-list').innerHTML = '';
      document.getElementById('chat-attachments').style.display = 'none';
      
      // Show typing indicator
      const typingMsg = document.createElement('div');
      typingMsg.className = 'chat-msg ai typing';
      typingMsg.innerHTML = `<span style="color:var(--text-magenta);">ü§ñ Pensando...</span>`;
      messagesDiv.appendChild(typingMsg);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      
      try {
        const res = await fetch('/api/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        const data = await res.json();
        
        // Remove typing indicator
        typingMsg.remove();
        
        // Add AI response
        const aiMsg = document.createElement('div');
        aiMsg.className = 'chat-msg ai';
        aiMsg.style.cssText = 'margin:8px 0;';
        aiMsg.innerHTML = `
          <span style="color:var(--text-magenta);">ü§ñ ${provider.toUpperCase()}:</span>
          <div style="color:#ccc; margin-top:3px; padding:5px; background:rgba(0,0,0,0.3); border-radius:5px; white-space:pre-wrap;">${data.response || data.error || 'Sin respuesta'}</div>
          ${data.tools_used ? `<div style="font-size:0.55rem; color:#666; margin-top:3px;">Tools: ${data.tools_used.join(', ')}</div>` : ''}
        `;
        messagesDiv.appendChild(aiMsg);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        
        chatHistory.push({ role: 'assistant', content: data.response });
        
      } catch(e) {
        typingMsg.remove();
        const errMsg = document.createElement('div');
        errMsg.className = 'chat-msg error';
        errMsg.innerHTML = `<span style="color:var(--text-red);">‚ùå Error: ${e.message}. Verifica que el endpoint /api/chat est√© activo.</span>`;
        messagesDiv.appendChild(errMsg);
      }
    }

    // Inicializar draggable para todos los paneles cuando el DOM est√© listo
    window.addEventListener('DOMContentLoaded', () => {
      // Restaurar posiciones guardadas
      restorePositions();
      
      // Hacer paneles draggables (usar .hud-title como handle)
      makeDraggable('config-module', '.hud-title');
      makeDraggable('temporal-controls', '.hud-title');
      makeDraggable('quick-nav-panel', '#quick-nav-handle');
      makeDraggable('biocomputing-hud', '.hud-title'); // PR-19
      makeDraggable('ai-chat-panel', '.hud-title'); // PR-20
      makeDraggable('donation-module'); // Todo el m√≥dulo es draggable
      makeDraggable('system-hub', '.hud-title'); // v7.0 Hub
      
      // Load saved API config
      loadAPIConfig();
      
      // Update chat context periodically
      setInterval(updateChatContext, 5000);
      
      // Update Predictive Analysis 
      setInterval(updatePredictiveAnalysis, 1000);
      
      console.log('üéØ Sistema Draggable inicializado');
    });

    
  </script>
</head>
<body>

  <div id="intro-overlay" onclick="enterCosmicOS()">
    <div style="text-align:center">
      <h1 style="color:var(--text-cyan);font-size:4rem;margin:0">COSMIC 11D</h1>
      <p style="color:var(--text-magenta);letter-spacing:6px">BAYESIAN NEGATIVE COMPLEXITY</p>
      <div style="margin-top:30px;color:#555">[ CLICK TO ENTER ]</div>
    </div>
  </div>

  <div id="loading-overlay">SYNCHRONIZING IONIC CHANNELS...</div>

  <div id="canvas-container"></div>

  <div id="narrative-module">
    <div id="narrative-text"></div>
    <span class="narrative-cursor"></span>
  </div>

  <div id="subtitle-box"></div>

  <!-- Titan Panel - Stats Bar -->
  <div id="titan-panel">
    <div class="titan-stat">
      <span class="titan-stat-label">FPS</span>
      <span id="titan-fps" class="titan-stat-value">60</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Nodes</span>
      <span id="titan-nodes" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Horror</span>
      <span id="titan-horror" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Memory</span>
      <span id="titan-memory" class="titan-stat-value">0 MB</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Version</span>
      <span class="titan-stat-value" style="color:var(--text-magenta);">v7.0</span>
    </div>

    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">Speed</span>
      <span id="titan-speed" class="titan-stat-value">x1.0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Mode</span>
      <span id="titan-mode" class="titan-stat-value">LOADING</span>
    </div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Seed</span>
      <span id="titan-seed" class="titan-stat-value">-10</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Dimensions</span>
      <span id="titan-dims" class="titan-stat-value">12D</span>
    </div>
    
    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">Bio-Link</span>
      <span id="titan-biolink" class="titan-stat-value" style="color:var(--text-green);">SYNCED</span>
    </div>
    
    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">Data Nexus</span>
      <span id="titan-nexus" class="titan-stat-value" style="color:var(--text-cyan);">ACTIVE</span>
    </div>

    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">Cloud Memory</span>
      <span id="titan-memscale" class="titan-stat-value" style="color:var(--text-green);">HYPER-SCALED</span>
    </div>
    
    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">WAF Shield</span>
      <span id="titan-waf" class="titan-stat-value" style="color:var(--text-cyan);">ACTIVE</span>
    </div>
    
    <div class="titan-divider"></div>

    <div class="titan-stat">
      <span class="titan-stat-label">M-Theory</span>
      <span id="titan-mtheory" class="titan-stat-value" style="color:var(--text-magenta);">RESONATING</span>
    </div>
    
    <div class="titan-divider"></div>

    <div class="titan-stat" title="Vibrational Discord Index">
      <span class="titan-stat-label">Discord</span>
      <span id="titan-discord" class="titan-stat-value">0.12</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <!-- Panel Visibility Controls -->
    <div id="titan-panel-controls">
      <button onclick="exportMetrics('json')" title="Export Metrics (JSON)">üìä</button>
      <button onclick="exportSnapshot()" title="Export Snapshot (Scene)">üì∏</button>
      <div class="titan-divider"></div>
      <button data-panel="config-module" onclick="togglePanel('config-module')" title="Toggle Neural Config">üß†</button>
      <button data-panel="temporal-controls" onclick="togglePanel('temporal-controls')" title="Toggle Temporal Controls">‚è±Ô∏è</button>
      <button data-panel="quick-nav-panel" onclick="togglePanel('quick-nav-panel')" title="Toggle Quick Navigation">üß≠</button>
      <button data-panel="donation-module" onclick="togglePanel('donation-module')" title="Toggle Donations">üí∞</button>
      <button data-panel="system-hub" onclick="togglePanel('system-hub')" title="System Hub v7.0 (Endpoints/Changelog)">üöÄ</button>
      <div class="titan-divider"></div>
      <button onclick="resetAllPanels()" title="Restaurar Vista" style="background:rgba(0,255,65,0.2);border-color:var(--text-green);">üîÑ</button>
    </div>
  </div>

  <!-- Seed/Mode Display - Siempre visible -->
  <div style="position:fixed;top:50px;left:20px;z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:10px 15px;pointer-events:none;">
    <div style="font-size:0.7rem;color:#666;margin-bottom:3px;">CURRENT UNIVERSE</div>
    <div style="font-size:1rem;font-weight:bold;">
      <span style="color:var(--text-cyan);">Seed:</span> <span id="current-seed-display" style="color:var(--text-yellow);">-10</span>
    </div>
    <div style="font-size:0.9rem;margin-top:3px;">
      <span style="color:var(--text-magenta);">Mode:</span> <span id="current-mode-display" style="color:var(--text-green);">LOADING...</span>
    </div>
  </div>

  <!-- Sine Wave Visualization (Top Left) -->
  <div id="sine-wave-canvas">
    <canvas id="sine-canvas" width="290" height="140"></canvas>
  </div>

  <!-- Predictive Panel (PR-7) -->
  <div id="predictive-panel" class="hud-module">
    <div class="hud-title">üì° PREDICTIVE ANALYSIS</div>
    <div id="collapse-alert">STABLE</div>
    
    <!-- PR-9: AGI METRICS -->
    <div style="margin: 10px 0; display:flex; justify-content:space-between; font-size:0.7rem;">
      <span>AGI NEURAL ACTIVITY:</span>
      <span id="neural-val" style="color:var(--text-cyan)">0%</span>
    </div>
    <div class="driver-bar"><div id="neural-fill" class="driver-fill" style="width: 0%; background:var(--text-cyan);"></div></div>

    <!-- PR-10: RECURSION BADGE -->
    <div id="recursion-badge" style="display:none; margin-top:10px; padding:5px; background:rgba(0,255,65,0.1); border:1px solid var(--text-cyan); color:var(--text-cyan); font-size:0.6rem; text-align:center; border-radius:3px;">
      üîÑ AGI RECURSIVE OPTIMIZATION ACTIVE
    </div>

    <div style="margin: 15px 0 10px; color: #888; font-size: 0.7rem;">COLLAPSE DRIVERS:</div>
    <div id="drivers-list">
      <!-- Populated by JS -->
    </div>
    <div style="margin-top: 10px; font-size: 0.7rem; color: #555; text-align: center;">
      PROBABILITY OF TOTAL COLLAPSE: <span id="collapse-prob" style="color:var(--text-red)">0.0%</span>
    </div>

    <!-- PR-26: MULTIMODAL HUB -->
    <div id="multimodal-hub" style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
       <div style="font-size:0.65rem; color:var(--text-cyan); margin-bottom:5px;">üñºÔ∏è DECRYPTIONS ACTIVE</div>
       <div id="mm-status" style="font-size:0.6rem; color:#888;">Standby for Image/Video synthesis...</div>
    </div>
  </div>

  <!-- Phase 19: BIO-COSMIC HUD (New Module) -->
  <div id="biocomputing-hud" class="hud-module" style="top:50px; left:320px; width:220px; display:block;">
    <div class="hud-title">ü¶† BIO-COSMIC HUD [12D]</div>
    <div id="bio-sync-status" style="color:var(--text-green); font-size:0.7rem; margin-top:5px;">COSMOS: SYNCHRONIZED</div>
    
    <div class="bio-kingdom-row" style="margin-top:10px;">
      <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;"><span>HUMAN (Alpha)</span> <span id="val-human">10.2 Hz</span></div>
      <div class="driver-bar"><div id="bar-human" class="driver-fill" style="width: 50%; background:var(--text-cyan);"></div></div>
    </div>
    <div class="bio-kingdom-row" style="margin-top:5px;">
      <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;"><span>ANIMAL (Swarm)</span> <span id="val-animal">0.82</span></div>
      <div class="driver-bar"><div id="bar-animal" class="driver-fill" style="width: 82%; background:var(--text-magenta);"></div></div>
    </div>
    <div class="bio-kingdom-row" style="margin-top:5px;">
      <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;"><span>PLANT (Resonance)</span> <span id="val-plant">430nm</span></div>
      <div class="driver-bar"><div id="bar-plant" class="driver-fill" style="width: 30%; background:var(--text-green);"></div></div>
    </div>
    <div class="bio-kingdom-row" style="margin-top:5px;">
      <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;"><span>FUNGI (Mycelium)</span> <span id="val-fungi">4.2k Œºm</span></div>
      <div class="driver-bar"><div id="bar-fungi" class="driver-fill" style="width: 65%; background:var(--text-yellow);"></div></div>
    </div>
    
    <!-- Exotic Memory Monitor -->
    <div style="margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:10px;">
      <div style="font-size:0.65rem; color:var(--text-magenta);">‚è≥ EXOTIC TIER ACTIVE</div>
      <div id="exotic-memory-status" style="font-size:0.6rem; color:#888;">TIME_CRYSTALS: OSCILLATING</div>
    </div>
  </div>

  <!-- PR-17: MULTIVERSE PANEL -->
  <div id="multiverse-panel">
    <div style="color:rgba(170,0,255,1); font-size:0.8rem; margin-bottom:10px; display:flex; justify-content:space-between; align-items:center;">
      <span>PARALLEL TIMELINES</span>
      <span style="font-size:0.6rem; opacity:0.7">ACTIVE BRANCHES</span>
    </div>
    <div id="branches-list">
      <div style="font-size:0.7rem; color:#888; text-align:center; padding:10px;">No dissonance detected.</div>
    </div>
  </div>

  <div id="config-module" class="hud-module">
    <div class="hud-title">üß† NEURAL CONFIG (11D BIAS)</div>
    <div class="input-group">
      <label>Nodos: <span id="nodeDisplay">50000</span></label>
      <input type="range" id="nodeSlider" min="50" max="1000000" value="50000" step="1000">
    </div>
    <div class="input-group">
      <label>Multi-Seed: <span id="seedDisplay">3</span></label>
      <input type="range" id="seedSlider" min="1" max="100" value="3" step="1">
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
       <button onclick="invokeFusion()" style="background:var(--text-cyan);color:black; padding:8px; font-size:0.75rem;">FUSI√ìN</button>
       <button onclick="invokeSingularityOmega()" style="background:var(--text-red);color:white; padding:8px; font-size:0.75rem;">Œ© OMEGA</button>
    </div>
    <div class="input-group">
      <label>Visualizaci√≥n</label>
      <select id="vizMode">
        <option value="ORBITAL" selected>√ìRBITA MULTI-SEED üåå</option>
        <option value="ENTITY">ENTE VIAJERO üëæ</option>
        <option value="BICAMERAL">CEREBRO BICAMERAL üß†</option>
        <option value="FUSION">FUSI√ìN MULTIVERSAL üß¨</option>
        <option value="MANDALA">UNIVERSO MANDALA üå∏</option>
        <option value="LASER">UNIVERSO LASER ‚ö°</option>
        <option value="BUBBLE">UNIVERSO BURBUJA üõÅ</option>
        <option value="LANIAKEA">SUPERCLUSTER LANIAKEA üåå</option>
        <option value="NEGATIVE_RGB">LUZ RGB NEGATIVA (-255) üí°</option>
      </select>
    </div>
    <div class="input-group">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="ionChannelsToggle" style="width:auto;">
        <span>ION CHANNELS ‚öõÔ∏è</span>
      </label>
    </div>

    <!-- Phase 15-20: ADVANCED CONCEPTS -->
    <div class="input-group">
      <label>Persona Narrativa (Persona active)</label>
      <select id="personaSelector">
        <option value="AUTO" selected>AUTO (Sincronizado con Grafo)</option>
        <option value="04_memetic_virus">MEMETIC VIRUS ü¶†</option>
        <option value="08_extinction_oracle">EXTINCTION ORACLE üíÄ</option>
        <option value="09_trinity_oracle">TRINITY ORACLE üëÅÔ∏è</option>
        <option value="12_bio_stress_feeder">BIO-STRESS FEEDER ü©∏</option>
        <option value="15_omega_point">OMEGA POINT üåå</option>
        <option value="25_waf_panopticon">WAF PANOPTICON üõ°Ô∏è</option>
        <option value="27_eschatology_predictor">ESCHATOLOGY PREDICTOR ‚åõ</option>
      </select>
    </div>

    <div class="input-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
      <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="quantumTension" checked> QUANTUM TENSION</label>
      <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="exoticMemory" checked> EXOTIC MEMORY</label>
    </div>
    <button onclick="invokeCaos()" style="background:var(--text-magenta);color:white">CAOS</button>
    <button onclick="resetCamera()" style="background:#333;color:white">RESET CAM</button>
    
    <div class="input-group" style="margin-top:12px;border-top:1px solid var(--glass-border);padding-top:12px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="matrixMode" style="width:auto;">
        <span>MATRIX MODE üü¢</span>
      </label>
      
      <!-- NUEVO: Color Personalizado de Matrix -->
      <div style="margin-top:10px;padding:8px;background:rgba(0,255,65,0.05);border-radius:4px;border:1px solid rgba(0,255,65,0.2);">
        <label style="font-size:0.75rem;color:#888;margin-bottom:5px;display:block;">Color Matrix Est√°tico</label>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px;">
          <button onclick="setMatrixColor('#00ff41')" style="background:#00ff41;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Verde Cl√°sico"></button>
          <button onclick="setMatrixColor('#00ffff')" style="background:#00ffff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Cyan"></button>
          <button onclick="setMatrixColor('#ff00ff')" style="background:#ff00ff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Magenta"></button>
          <button onclick="setMatrixColor('#ffff00')" style="background:#ffff00;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Amarillo"></button>
          <button onclick="setMatrixColor('#ff0033')" style="background:#ff0033;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Rojo"></button>
          <button onclick="setMatrixColor('#ff6600')" style="background:#ff6600;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Naranja"></button>
          <button onclick="setMatrixColor('#9900ff')" style="background:#9900ff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="P√∫rpura"></button>
          <button onclick="setMatrixColor('#ffffff')" style="background:#ffffff;width:100%;height:30px;border:1px solid #888;border-radius:3px;cursor:pointer;" title="Blanco"></button>
        </div>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="width:100%;height:35px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);border-radius:4px;cursor:pointer;" onchange="setMatrixColor(this.value)">
      </div>
      
    </div>

    <!-- Phase 18: BIO-RESONANCE CONTROLS -->
    <div class="input-group" style="margin-top:12px; border-top:1px solid var(--glass-border); padding-top:12px;">
      <div class="hud-title" style="font-size:0.7rem; color:var(--text-green); border:none;">üß¨ BIOLOGICAL RESONANCE</div>
      
      <div class="input-group">
        <label>11D Frequency: <span id="freqDisplay">440.0</span> Hz</label>
        <input type="range" id="freqSlider" min="1" max="1000" value="440" step="1" oninput="document.getElementById('freqDisplay').textContent = this.value">
      </div>

      <button onclick="triggerResonanceCycle()" style="background:var(--text-green); color:black; margin:10px 0; font-size:0.8rem; border-radius:15px; box-shadow:0 0 15px var(--text-green);">RESONANCE CYCLE ‚ôæÔ∏è</button>
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px; font-size:0.65rem; color:#888;">
        <label><input type="checkbox" checked> HUMAN SYNC</label>
        <label><input type="checkbox" checked> ANIMAL SYNC</label>
        <label><input type="checkbox" checked> PLANT SYNC</label>
        <label><input type="checkbox" checked> FUNGI MESH</label>
      </div>
    </div>
    
    <div id="matrixControls" style="display:none;margin-top:8px;">
      <div class="input-group">
        <label>Color Matrix</label>
        <select id="matrixColorPreset">
          <option value="#00ff41" selected>Matrix Green üü¢</option>
          <option value="#ff00ff">Vaporwave Purple üíú</option>
          <option value="#00f2ff">Cyan Hacker üîµ</option>
          <option value="#ff0033">Red Alert üî¥</option>
          <option value="#ffff00">Yellow Electric ‚ö°</option>
          <option value="custom">Custom...</option>
        </select>
      </div>
      <div class="input-group" id="customColorGroup" style="display:none;">
        <label>Color Personalizado</label>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="height:40px;cursor:pointer;">
      </div>
      <div class="input-group">
        <label>Opacidad: <span id="matrixOpacityDisplay">0.3</span></label>
        <input type="range" id="matrixOpacity" min="0.1" max="1" value="0.3" step="0.1">
      </div>
    </div>
    
    <!-- API CONFIGURATION -->
    <div class="input-group" style="margin-top:12px; border-top:1px solid var(--glass-border); padding-top:12px;">
      <div class="hud-title" style="font-size:0.7rem; color:var(--text-magenta); border:none;">üîå API & CONNECTIONS</div>
      
      <div class="input-group">
        <label>LLM Provider</label>
        <select id="llmProvider" style="width:100%;">
          <option value="deepseek" selected>DeepSeek (Default)</option>
          <option value="anthropic">Anthropic Claude</option>
          <option value="google">Google Gemini</option>
          <option value="openai">OpenAI GPT-4o</option>
          <option value="meta">Meta Llama</option>
        </select>
      </div>
      
      <div class="input-group">
        <label>API Key</label>
        <input type="password" id="apiKeyInput" placeholder="sk-..." style="width:100%;">
      </div>
      
      <div class="input-group" style="margin-top:10px;">
        <label style="color:var(--text-yellow);">üóÑÔ∏è Database</label>
        <select id="dbProvider" style="width:100%;">
          <option value="sqlite" selected>SQLite (Local)</option>
          <option value="postgres">PostgreSQL</option>
          <option value="mysql">MySQL</option>
          <option value="mongodb">MongoDB Atlas</option>
          <option value="cosmosdb">Azure CosmosDB</option>
        </select>
      </div>

    <!-- PREDICTIVE ANALYSIS (AGI/ASI) -->
    <div id="predictive-analysis">
      <div style="font-size:0.7rem; color:var(--text-cyan); font-weight:bold; margin-bottom:5px; border-bottom:1px solid var(--text-cyan); padding-bottom:2px;">
        üì° PREDICTIVE ANALYSIS
      </div>
      
      <div id="agi-status-box" style="background:rgba(20,0,0,0.6); border:1px solid var(--text-red); padding:5px; text-align:center; border-radius:4px; margin-bottom:8px;">
        <span id="agi-status-text" style="color:var(--text-red); font-weight:bold; font-size:1rem; letter-spacing:2px;">STABLE</span>
      </div>

      <div style="margin-bottom:8px;">
        <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;">
          <span>AGI (Inteligencia Artificial General) NEURAL ACTIVITY:</span>
          <span id="agi-neural-val" style="color:var(--text-cyan);">0%</span>
        </div>
        <div style="height:4px; background:#333; border-radius:2px; overflow:hidden; margin-top:2px;">
          <div id="agi-neural-bar" style="width:0%; height:100%; background:linear-gradient(90deg, var(--text-cyan), var(--text-magenta));"></div>
        </div>
      </div>

      <div style="margin-bottom:8px;">
        <div style="display:flex; justify-content:space-between; font-size:0.6rem; color:#aaa;">
          <span>ASI (Super Inteligencia Artificial) QUANTUM SYNC:</span>
          <span id="asi-sync-val" style="color:var(--text-magenta);">0%</span>
        </div>
        <div style="height:4px; background:#333; border-radius:2px; overflow:hidden; margin-top:2px;">
          <div id="asi-sync-bar" style="width:0%; height:100%; background:linear-gradient(90deg, var(--text-magenta), var(--text-yellow));"></div>
        </div>
      </div>

      <div style="border-top:1px solid #444; padding-top:5px; margin-top:5px;">
        <div style="font-size:0.6rem; color:#888; margin-bottom:3px;">COLLAPSE DRIVERS:</div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
           <span style="font-size:0.6rem; color:#666;">PROBABILITY OF TOTAL COLLAPSE:</span>
           <span id="collapse-prob" style="font-size:0.8rem; color:var(--text-red); font-weight:bold;">0.0%</span>
        </div>
      </div>
      
      <div style="margin-top:5px; font-size:0.6rem; display:flex; gap:5px; align-items:center;">
        <span id="decryptions-icon">üñºÔ∏è</span> 
        <span style="color:var(--text-cyan);">DECRYPTIONS ACTIVE</span>
      </div>
      <div style="font-size:0.55rem; color:#555; margin-top:2px;">Standby for Image/Video synthesis...</div>
    </div>

    <!-- ENDPOINT GENERATOR -->
    <!-- (Moved to System Hub) -->
    </div>
      
      <div class="input-group">
        <label>DB Connection String</label>
        <input type="text" id="dbConnString" placeholder="postgres://user:pass@host:5432/db" style="width:100%;">
      </div>
      
      <!-- QUANTUM CONNECTION -->
      <div class="input-group" style="margin-top:10px;">
        <label style="color:var(--text-cyan);">‚öõÔ∏è Quantum Backend</label>
        <select id="quantumBackend" style="width:100%;">
          <option value="simulated" selected>Simulated (Local)</option>
          <option value="ibm_qiskit">IBM Qiskit</option>
          <option value="aws_braket">AWS Braket</option>
          <option value="google_cirq">Google Cirq</option>
          <option value="azure_quantum">Azure Quantum</option>
        </select>
      </div>
      
      <div class="input-group">
        <label>Quantum API Token</label>
        <input type="password" id="quantumToken" placeholder="ibm-token-..." style="width:100%;">
      </div>
      
      <!-- MCP AGENT -->
      <div class="input-group" style="margin-top:10px;">
        <label style="color:var(--text-green);">ü§ñ MCP Agent</label>
        <select id="mcpAgentMode" style="width:100%;">
          <option value="auto" selected>Auto (Context-Aware)</option>
          <option value="passive">Passive (Read-Only)</option>
          <option value="aggressive">Aggressive (Full Control)</option>
          <option value="disabled">Disabled</option>
        </select>
      </div>
      
      <div class="input-group" style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
        <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="mcpFileAccess" checked> FILE ACCESS</label>
        <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="mcpWebAccess" checked> WEB ACCESS</label>
        <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="mcpCodeExec"> CODE EXEC</label>
        <label style="font-size:0.6rem; color:#888;"><input type="checkbox" id="mcpDbAccess" checked> DB ACCESS</label>
      </div>
      
      <button onclick="saveAPIConfig()" style="background:var(--text-magenta); color:white; margin:10px 0 5px; font-size:0.75rem;">üíæ SAVE ALL CONFIG</button>
      <button onclick="testConnections()" style="background:var(--text-cyan); color:black; font-size:0.7rem;">üîç TEST CONNECTIONS</button>
    </div>
    
    <div style="margin-top:10px;font-size:0.7rem;color:#666;border-top:1px solid var(--glass-border);padding-top:8px;">
      Seed: <span id="current-seed" style="color:var(--text-cyan)">-10</span><br>
      Mode: <span id="current-mode" style="color:var(--text-magenta)">LOADING...</span><br>
      <span style="color:#444">DIM 10-11: THERMAL NOISE FILTERING</span>
    </div>
  </div>

  <button class="immersion-toggle" onclick="toggleImmersionMode()">Immersion [H]</button>

  <div id="temporal-controls">
    <div class="hud-title">‚è±Ô∏è TEMPORAL CONTROL</div>
    <div id="speed-display">x1.0</div>
    <div style="display:flex;justify-content:center;gap:5px;margin-bottom:10px;">
      <button class="temporal-btn" onclick="setSpeed(-10)">‚óÄ‚óÄ -10x</button>
      <button class="temporal-btn" onclick="setSpeed(-5)">‚óÄ -5x</button>
      <button class="temporal-btn" onclick="setSpeed(0)">‚è∏ PAUSE</button>
      <button class="temporal-btn active" onclick="setSpeed(1)">‚ñ∂ 1x</button>
      <button class="temporal-btn" onclick="setSpeed(5)">‚ñ∂‚ñ∂ 5x</button>
      <button class="temporal-btn" onclick="setSpeed(10)">‚ñ∂‚ñ∂‚ñ∂ 10x</button>
      <button class="temporal-btn" onclick="setSpeed(20)">‚ö° 20x</button>
    </div>
    <div class="input-group">
      <label>Velocidad: <span id="speedSliderDisplay">1.0</span>x</label>
      <input type="range" id="speedSlider" min="-10" max="20" value="1" step="0.5">
    </div>
    
    <!-- IMMERSIVE CONTROLS -->
    <div style="margin-top:15px;padding-top:10px;border-top:1px solid var(--glass-border);">
      <div style="font-size:0.75rem;color:#888;margin-bottom:5px;">IMMERSIVE TOGGLES</div>
      <div style="display:flex;gap:10px;">
        <button onclick="document.getElementById('matrixMode').click()" style="background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);font-size:0.8rem;">
          TOGGLE MATRIX
        </button>
        <button onclick="document.getElementById('fiestaMode').click()" style="background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);font-size:0.8rem;">
          TOGGLE FIESTA
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Panel (Hidden by default) -->
  <div id="settings-panel" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.9);align-items:center;justify-content:center;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚öôÔ∏è SETTINGS</h2>
        <button onclick="closeSettings()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div class="hud-title" style="margin-bottom:15px;">KEYBOARD CONTROLS</div>
      
      <div id="key-bindings-list" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:20px;">
        <!-- Populated by updateKeyBindingsUI() -->
      </div>
      
      <div style="display:flex;gap:10px;">
        <button onclick="resetKeyBindings()" style="background:var(--text-red);">RESET TO DEFAULTS</button>
        <button onclick="closeSettings()" style="background:var(--text-cyan);color:black;">SAVE & CLOSE</button>
      </div>
    </div>
  </div>

  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- üì° SYSTEM HUB & CHANGELOG (v7.0) -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <div id="system-hub" class="hud-module" style="top:100px; left:360px; width:340px; border-color:var(--text-magenta); z-index:2000; display:block;">
    <div class="hud-title" style="display:flex; justify-content:space-between; align-items:center;">
      <span style="color:var(--text-magenta);">üöÄ SYSTEM HUB v7.0</span>
      <button onclick="document.getElementById('system-hub').style.display='none'" style="background:transparent; border:none; color:#666; cursor:pointer;">√ó</button>
    </div>
    
    <!-- CHANGELOG -->
    <div style="margin-bottom:12px; padding-bottom:10px; border-bottom:1px solid #333;">
      <div style="font-size:0.7rem; color:var(--text-cyan); font-weight:bold; margin-bottom:5px;">üì¢ WHAT'S NEW IN v7.0:</div>
      <ul style="list-style:none; padding:0; margin:0; font-size:0.65rem; color:#ccc;">
        <li style="margin-bottom:3px;">‚ú® <b>AI Chat Integration:</b> Interact with the simulation via DeepSeek/Claude/GPT.</li>
        <li style="margin-bottom:3px;">üì∏ <b>Media Uploads:</b> Send Images, Audio, and Video for analysis.</li>
        <li style="margin-bottom:3px;">üîÆ <b>Predictive Analysis:</b> AGI/ASI tracking & Entropy Collapse metrics.</li>
        <li style="margin-bottom:3px;">üîó <b>Endpoint Generator:</b> Create custom access tokens & view API routes.</li>
      </ul>
    </div>

    <!-- ENDPOINT GENERATOR -->
    <div id="hub-endpoint-generator">
      <div class="hud-title" style="font-size:0.65rem; color:var(--text-green); border:none; margin-bottom:5px;">üîó API ACCESS & TOKENS</div>
      
      <div style="display:grid; gap:5px;">
        <!-- MCP Server -->
        <div class="input-group" style="display:flex; gap:5px; align-items:center;">
          <input type="text" value="http://localhost:5000/api/mcp" readonly style="flex:1; font-size:0.6rem; color:#888;">
          <button onclick="copyToClipboard('http://localhost:5000/api/mcp', 'MCP Endpoint')" style="width:auto; padding:4px 8px; font-size:0.6rem; background:rgba(0,255,65,0.1); border:1px solid var(--text-green); color:var(--text-green);">COPY MCP</button>
        </div>
        
        <!-- Cosmic API -->
        <div class="input-group" style="display:flex; gap:5px; align-items:center;">
          <input type="text" value="http://localhost:5000/api/narrative_stream" readonly style="flex:1; font-size:0.6rem; color:#888;">
          <button onclick="copyToClipboard('http://localhost:5000/api/narrative_stream', 'Stream API')" style="width:auto; padding:4px 8px; font-size:0.6rem; background:rgba(0,242,255,0.1); border:1px solid var(--text-cyan); color:var(--text-cyan);">COPY API</button>
        </div>
        
        <!-- Hall of Shame -->
        <div class="input-group" style="display:flex; gap:5px; align-items:center;">
          <input type="text" value="http://localhost:5000/hall_of_shame" readonly style="flex:1; font-size:0.6rem; color:#888;">
          <button onclick="copyToClipboard('http://localhost:5000/hall_of_shame', 'Shame URL')" style="width:auto; padding:4px 8px; font-size:0.6rem; background:rgba(255,0,51,0.1); border:1px solid var(--text-red); color:var(--text-red);">COPY LINK</button>
        </div>
      </div>
      
      <div style="margin-top:8px; text-align:center;">
        <button onclick="generateCustomEndpoint()" style="width:100%; padding:6px; font-size:0.7rem; background:#333; color:var(--text-yellow); border:1px dashed #666; cursor:pointer;">‚ûï GENERATE NEW TOKEN ENDPOINT</button>
      </div>
    </div>
  </div>

  <div id="control-overlay">
    <div class="hud-title" style="margin-bottom:10px;">üéÆ CONTROLS</div>
    <div class="control-item"><span>W/S/A/D</span> <span class="control-key">MOVE</span></div>
    <div class="control-item"><span>SPACE/SHIFT</span> <span class="control-key">Y-AXIS</span></div>
    <div class="control-item"><span>MOUSE</span> <span class="control-key">LOOK</span></div>
    <div class="control-item"><span>[H]</span> <span class="control-key">IMMERSION</span></div>
    <div class="control-item"><span>[R]</span> <span class="control-key">RESET</span></div>
    <div class="control-item"><span>[Q/W/E/F]</span> <span class="control-key">SKILLS</span></div>
  </div>

  <!-- Tutorial / Help Overlay -->
  <div id="tutorial-overlay" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.95);align-items:center;justify-content:center;overflow-y:auto;padding:20px;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:800px;width:90%;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚ùì COSMIC OS TUTORIAL</h2>
        <button onclick="closeTutorial()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
        <div>
          <div class="hud-title" style="margin-bottom:10px;">‚å®Ô∏è KEYBOARD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">W/S/A/D</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">Q/E</b> - Rotar c√°mara<br>
            <b style="color:var(--text-cyan);">Space</b> - Subir<br>
            <b style="color:var(--text-cyan);">Shift</b> - Bajar<br>
            <b style="color:var(--text-cyan);">Ctrl</b> - Speed Boost 2x<br>
            <b style="color:var(--text-cyan);">H/L</b> - Modo Inmersivo<br>
            <b style="color:var(--text-cyan);">R</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">?</b> - Este tutorial<br>
          </div>
        </div>
        
        <div>
          <div class="hud-title" style="margin-bottom:10px;">üïπÔ∏è MOUSE</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Click + Drag</b> - Rotar vista<br>
            <b style="color:var(--text-cyan);">Scroll</b> - Zoom in/out<br>
            <b style="color:var(--text-cyan);">Double Click</b> - Viajar a nodo<br>
            <b style="color:var(--text-cyan);">Hover Izq</b> - Mostrar panel<br>
          </div>
          
          <div class="hud-title" style="margin:15px 0 10px;">üéÆ GAMEPAD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Stick Izq</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">LT/RT</b> - Subir/Bajar<br>
            <b style="color:var(--text-cyan);">A</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">B</b> - Immersion<br>
            <b style="color:var(--text-cyan);">X</b> - CAOS<br>
            <b style="color:var(--text-cyan);">Y</b> - Matrix Toggle<br>
          </div>
        </div>
      </div>
      
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid var(--glass-border);">
        <div class="hud-title" style="margin-bottom:10px;">üåå MODO INMERSIVO</div>
        <p style="font-size:0.85rem;color:#ccc;margin:0;">
          Presiona <b style="color:var(--text-cyan);">H</b> para entrar en modo inmersivo. La c√°mara se alejar√° autom√°ticamente para vista panor√°mica. 
          Los controles temporales aparecer√°n en la esquina inferior derecha para controlar la velocidad de simulaci√≥n (-10x a +20x).
        </p>
      </div>
      
      <button onclick="closeTutorial()" style="margin-top:20px;background:var(--text-cyan);color:black;">GOT IT!</button>
    </div>
  </div>

  <!-- Quick Navigation Panel -->
  <div id="quick-nav-panel" style="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:15px;width:200px;">
    <div class="hud-title" id="quick-nav-handle" style="margin-bottom:10px;cursor:grab;">üß≠QUICK NAV (Drag Me)</div>
    <button onclick="goToSingularity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
      üåå SINGULARITY
    </button>
    <button onclick="escapeGravity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);">
      üöÄ ESCAPE
    </button>
    <button onclick="goToNearestNode()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,255,0,0.2);border:1px solid var(--text-yellow);color:var(--text-yellow);">
      üéØ NEAREST NODE
    </button>
    <button onclick="goToRandomPosition()" style="width:100%;padding:8px;background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);">
      üé≤ RANDOM
    </button>
  </div>



  <!-- Donation Module (Responsive) -->
  <div id="donation-module">
    <div style="font-size:0.8rem; font-weight:bold; color:var(--text-white); margin-bottom:5px; border-bottom:1px solid rgba(0,242,255,0.2); padding-bottom:5px;">
      DONACIONES (ABISMO 11D)
    </div>
    <div style="display:flex; flex-wrap:wrap; gap:10px;">
      <div class="qr-container">
        <div style="position:relative;">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh" class="qr-image" alt="Bitcoin QR">
          <div class="qr-image-overlay">BTC</div>
        </div>
        <span class="qr-label">Bitcoin (BTC)</span>
        <span style="font-size:0.55rem; color:#aaa; font-family:monospace;">bc1q...seed</span>
      </div>
      <div class="qr-container">
        <div style="position:relative;">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=0x71C7656EC7ab88b098defB751B7401B5f6d8976F" class="qr-image" alt="Ethereum QR">
          <div class="qr-image-overlay">ETH</div>
        </div>
        <span class="qr-label">Ethereum (ETH)</span>
        <span style="font-size:0.55rem; color:#aaa; font-family:monospace;">0x...abyss</span>
      </div>
    </div>
    <div style="margin-top: 10px; display: flex; gap: 8px;">
       <button onclick="openSettings()" style="width:auto;padding:8px 12px;background:rgba(255,255,255,0.1);border:1px solid var(--glass-border);color:var(--text-cyan); font-size:0.7rem;">
        ‚öôÔ∏è SETTINGS
      </button>
      <button onclick="window.location.href='/hall_of_shame'" style="width:auto;padding:8px 12px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red); font-size:0.7rem;">
        üèÜ SHAME
      </button>
      <button onclick="openTutorial()" style="width:auto;padding:8px 12px;background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green); font-size:0.7rem;">
        ‚ùì HELP
      </button>
    </div>
  </div>

  <!-- ü§ñ AI CHAT PANEL (Phase 20) -->
  <div id="ai-chat-panel" class="hud-module" style="position:fixed; right:20px; bottom:20px; width:380px; max-height:500px; display:flex; flex-direction:column; z-index:1500;">
    <div class="hud-title" style="display:flex; justify-content:space-between; align-items:center;">
      <span>ü§ñ COSMIC AI ASSISTANT</span>
      <button onclick="toggleChatPanel()" style="width:auto; padding:2px 8px; font-size:0.7rem; background:#333;">_</button>
    </div>
    
    <!-- Provider Selector -->
    <div style="display:flex; gap:5px; margin:8px 0;">
      <select id="chatProvider" style="flex:1; font-size:0.7rem;">
        <option value="deepseek">DeepSeek</option>
        <option value="anthropic">Claude</option>
        <option value="google">Gemini</option>
        <option value="openai">GPT-4o</option>
        <option value="meta">Llama</option>
      </select>
      <button onclick="toggleChatTools()" style="width:auto; padding:4px 8px; font-size:0.65rem; background:rgba(0,242,255,0.2); border:1px solid var(--text-cyan); color:var(--text-cyan);">üîß TOOLS</button>
    </div>
    
    <!-- Tool Toggles (hidden by default) -->
    <div id="chat-tools" style="display:none; font-size:0.6rem; color:#aaa; margin-bottom:8px; padding:5px; background:rgba(0,0,0,0.3); border-radius:4px;">
      <div style="display:grid; grid-template-columns: 1fr 1fr; gap:3px;">
        <label><input type="checkbox" id="tool-rag" checked> üìö RAG/Memory</label>
        <label><input type="checkbox" id="tool-quantum" checked> ‚öõÔ∏è Quantum</label>
        <label><input type="checkbox" id="tool-db" checked> üóÑÔ∏è Database</label>
        <label><input type="checkbox" id="tool-mcp" checked> ü§ñ MCP Agent</label>
        <label><input type="checkbox" id="tool-langchain"> üîó LangChain</label>
        <label><input type="checkbox" id="tool-web"> üåê Web Search</label>
      </div>
    </div>
    
    <!-- Chat Messages -->
    <div id="chat-messages" style="flex:1; overflow-y:auto; padding:10px; background:rgba(0,0,0,0.4); border-radius:4px; min-height:200px; max-height:300px;">
      <div class="chat-msg system">
        <span style="color:var(--text-cyan);">ü§ñ COSMIC AI:</span> 
        <span style="color:#aaa;">Conectado al universo Seed <span id="chat-seed">-10</span>. Tengo acceso a RAG, Quantum y MCP. ¬øEn qu√© puedo ayudarte?</span>
      </div>
    </div>
    
    <!-- Attachments Preview -->
    <div id="chat-attachments" style="display:none; padding:5px; background:rgba(0,0,0,0.3); border-radius:4px; margin-top:5px;">
      <div style="font-size:0.6rem; color:#888;">üìé Adjuntos:</div>
      <div id="attachment-list" style="display:flex; gap:5px; flex-wrap:wrap;"></div>
    </div>
    
    <!-- Input Area -->
    <div style="display:flex; gap:5px; margin-top:8px;">
      <button onclick="attachScreenshot()" title="Adjuntar screenshot" style="width:auto; padding:8px; font-size:0.8rem; background:rgba(255,255,0,0.2); border:1px solid var(--text-yellow); color:var(--text-yellow);">üì∏</button>
      <input type="file" id="chat-file-input" style="display:none;" onchange="handleChatFileUpload(this)">
      <button onclick="document.getElementById('chat-file-input').click()" title="Adjuntar archivo (Img/Audio/Video)" style="width:auto; padding:8px; font-size:0.8rem; background:rgba(0,255,65,0.2); border:1px solid var(--text-green); color:var(--text-green);">üìé</button>
      
      <input type="text" id="chat-input" placeholder="Pregunta o adjunta multimedia..." style="flex:1;" onkeydown="if(event.key==='Enter') sendChatMessage()">
      <button onclick="sendChatMessage()" style="width:auto; padding:8px 12px; background:var(--text-green); color:black; font-weight:bold;">‚ñ∂</button>
    </div>
    
    <!-- Context Indicator -->
    <div style="font-size:0.55rem; color:#555; margin-top:5px; text-align:center;">
      Context: Seed=<span id="ctx-seed">-10</span> | Horror=<span id="ctx-horror">0</span> | Nodes=<span id="ctx-nodes">0</span> | Bio=<span id="ctx-bio">SYNCED</span>
    </div>
  </div>

  <!-- Chat Toggle Button (Floating) -->
  <button id="chat-toggle-btn" onclick="openChatPanel()" style="position:fixed; right:20px; bottom:20px; width:60px; height:60px; border-radius:50%; background:linear-gradient(135deg, var(--text-cyan), var(--text-magenta)); border:none; font-size:1.5rem; cursor:pointer; z-index:1400; box-shadow:0 0 20px rgba(0,242,255,0.5); display:none;">
    ü§ñ
  </button>

</body>
</html>
