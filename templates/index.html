<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>âš¡ COSMIC OS v3.3 - CONTROL TOTAL âš¡</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    :root {
      --bg-black: #000000;
      --glass-bg: rgba(0, 0, 0, 0.75);
      --glass-border: rgba(0, 242, 255, 0.3);
      --text-cyan: #00f2ff;
      --text-magenta: #ff00ff;
      --text-yellow: #ffff00;
      --text-red: #ff0033;
      --text-green: #00ff41;
    }
    
    /* Dark Glucose / Dark Matter Background */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(255, 0, 255, 0.12) 0%, transparent 50%);
      animation: breathe 8s ease-in-out infinite, drift 20s linear infinite;
      pointer-events:none;
      z-index:0;
    }
    
    @keyframes breathe {
      0%, 100% { opacity:0.3; transform:scale(1); }
      50% { opacity:0.6; transform:scale(1.1); }
    }
    
    @keyframes drift {
      0% { background-position: 0% 0%, 100% 100%, 50% 50%; }
      100% { background-position: 100% 100%, 0% 0%, 150% 150%; }
    }
    
    body, html { margin:0; padding:0; overflow:hidden; background:var(--bg-black); font-family:'Inter',sans-serif; color:white; }
    #canvas-container { position:absolute; inset:0; z-index:1; }
    #intro-overlay {
      position:fixed; inset:0; background:black; z-index:10000; display:flex;
      align-items:center; justify-content:center; cursor:pointer;
    }
    #loading-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:9000; display:none;
      align-items:center; justify-content:center; color:var(--text-cyan); font-size:2rem;
    }
    .hud-module {
      position:absolute; background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto; z-index:10;
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    }
    .hud-title { font-weight:700; font-size:0.9rem; letter-spacing:2px; color:var(--text-cyan); text-transform:uppercase; border-bottom:1px solid var(--glass-border); padding-bottom:5px; }
    
    /* Config Module - Collapsible from left */
    #config-module {
      bottom:20px; left:-280px; width:300px;
      transform:translateX(0);
      opacity:0.3;
    }
    #config-module:hover,
    #config-module:focus-within {
      transform:translateX(280px);
      opacity:1;
    }
    #config-module::before {
      content:'â˜°';
      position:absolute;
      right:-30px;
      top:50%;
      transform:translateY(-50%);
      background:var(--glass-bg);
      border:1px solid var(--glass-border);
      border-left:none;
      border-radius:0 8px 8px 0;
      padding:10px 8px;
      color:var(--text-cyan);
      font-size:1.2rem;
      cursor:pointer;
      pointer-events:auto;
    }
    .input-group { margin-bottom:12px; }
    .input-group label { display:block; font-size:0.75rem; color:#888; margin-bottom:5px; }
    .input-group input, .input-group select { width:100%; background:rgba(0,242,255,0.05); border:1px solid var(--glass-border); color:var(--text-cyan); padding:8px; border-radius:4px; }
    button { width:100%; padding:10px; border:none; border-radius:4px; font-weight:bold; cursor:pointer; text-transform:uppercase; }
    button:hover { filter:brightness(1.2); transform:scale(1.02); }
    .immersion-toggle { 
      position:fixed; top:20px; right:20px; z-index:2000; 
      background:rgba(0,255,136,0.2); border:1px solid var(--text-cyan); 
      color:var(--text-cyan); padding:8px 12px; cursor:pointer;
      transition: opacity 0.3s ease;
    }
    .immersion-toggle:hover {
      background:rgba(0,255,136,0.4);
      opacity:1 !important;
    }
    
    /* Temporal Controls */
    #temporal-controls {
      position:fixed; bottom:20px; right:20px; z-index:10;
      background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto;
      min-width:350px;
      display:none; /* Oculto por defecto, solo en immersive mode */
    }
    .temporal-btn {
      width:auto; padding:8px 15px; margin:0 3px;
      background:rgba(0,242,255,0.1); border:1px solid var(--glass-border);
      color:var(--text-cyan); font-size:0.9rem;
    }
    .temporal-btn.active { background:var(--text-cyan); color:black; }
    #speed-display {
      font-size:1.5rem; font-weight:bold; color:var(--text-cyan);
      text-align:center; margin:10px 0;
    }
    
    /* Titan Panel - Stats Bar */
    #titan-panel {
      position:fixed;
      top:0;
      left:0;
      right:0;
      height:40px;
      background:var(--glass-bg);
      backdrop-filter:blur(20px);
      border-bottom:1px solid var(--glass-border);
      box-shadow:0 2px 20px rgba(0,242,255,0.2);
      z-index:10000;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 20px;
      font-size:0.85rem;
      pointer-events:auto;
    }
    
    .titan-stat {
      display:flex;
      align-items:center;
      gap:8px;
      color:#888;
    }
    
    .titan-stat-label {
      color:#666;
      font-size:0.75rem;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    
    .titan-stat-value {
      color:var(--text-cyan);
      font-weight:bold;
      font-size:0.9rem;
    }
    
    .titan-stat-value.warning {
      color:var(--text-yellow);
    }
    
    .titan-stat-value.danger {
      color:var(--text-red);
    }
    
    .titan-divider {
      width:1px;
      height:20px;
      background:var(--glass-border);
    }
    
    /* Toast Animations */
    @keyframes slideIn {
      from { transform:translateX(400px); opacity:0; }
      to { transform:translateX(0); opacity:1; }
    }
    @keyframes slideOut {
      from { transform:translateX(0); opacity:1; }
      to { transform:translateX(400px); opacity:0; }
    }
  </style>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ”¥ DEFINIR FUNCIONES ANTES DEL HTML (FIX enterCosmicOS)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Variables globales
    let scene, camera, renderer, controls;
    let centralSingularity, pointsCloud;
    let matrixLines = null; // LÃ­neas Matrix
    let currentUniverseSeed = -10;
    let isImmersionMode = false;
    let matrixModeActive = false;
    let matrixColor = 0x00ff41; // Verde Matrix por defecto
    let matrixOpacity = 0.3;
    let timeSpeed = 1.0; // Velocidad de simulaciÃ³n
    let isPaused = false;

    // AUDIO REACTIVITY (FIESTA MODE)
    let audioContext, analyser, dataArray;
    let isFiestaMode = false;
    let audioInitialized = false;

    function initAudio() {
      if (audioInitialized) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            audioInitialized = true;
            showToast('ğŸ¤ MicrÃ³fono conectado - FIESTA MODE READY');
          })
          .catch(err => {
            console.error('Error acceso microfono:', err);
            showToast('âŒ Error micrÃ³fono: ' + err.message);
            document.getElementById('fiestaMode').checked = false;
            isFiestaMode = false;
          });
      } catch (e) {
        console.error('Audio API no soportada', e);
      }
    }

    function createGargantuaSingularity() {
      const group = new THREE.Group();
      
      // 1. Event Horizon (Black Hole)
      const coreGeo = new THREE.SphereGeometry(30, 64, 64);
      const coreMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const core = new THREE.Mesh(coreGeo, coreMat);
      group.add(core);

      // 2. Photon Sphere (Glowing ring)
      const glowGeo = new THREE.SphereGeometry(32, 64, 64);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);
      group.userData.photonSphere = glow;

      // 3. Accretion Disk
      const diskGeo = new THREE.RingGeometry(40, 120, 64);
      const pos = diskGeo.attributes.position;
      const v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++){
        v3.fromBufferAttribute(pos, i);
        diskGeo.attributes.uv.setXY(i, v3.length() < 60 ? 0 : 1, 1);
      }
      
      const diskMat = new THREE.PointsMaterial({
        color: 0xffaa00,
        size: 2,
        transparent: true,
        opacity: 0.8,
        vertexColors: false,
        blending: THREE.AdditiveBlending
      });
      
      // Convert ring to points for particle effect
      const diskPointsGeo = new THREE.BufferGeometry();
      const diskPointsCount = 5000;
      const diskPositions = new Float32Array(diskPointsCount * 3);
      const diskColors = new Float32Array(diskPointsCount * 3);
      
      for(let i=0; i<diskPointsCount; i++) {
        const radius = 40 + Math.random() * 80;
        const theta = Math.random() * Math.PI * 2;
        diskPositions[i*3] = Math.cos(theta) * radius;
        diskPositions[i*3+1] = (Math.random() - 0.5) * 5; // Flat disk
        diskPositions[i*3+2] = Math.sin(theta) * radius;
        
        // Color gradient: Inner hot (white/yellow) -> Outer cool (orange/red)
        const t = (radius - 40) / 80;
        const color = new THREE.Color();
        color.setHSL(0.1 - t * 0.1, 1.0, 0.8 - t * 0.4);
        diskColors[i*3] = color.r;
        diskColors[i*3+1] = color.g;
        diskColors[i*3+2] = color.b;
      }
      
      diskPointsGeo.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3));
      diskPointsGeo.setAttribute('color', new THREE.BufferAttribute(diskColors, 3));
      
      const disk = new THREE.Points(diskPointsGeo, new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      }));
      
      group.add(disk);
      group.userData.disk = disk;

      return group;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âš™ï¸ SISTEMA DE CONTROLES CONFIGURABLES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // ConfiguraciÃ³n por defecto
    const defaultKeyBindings = {
      forward: 'w',
      back: 's',
      left: 'a',
      right: 'd',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'r'
    };

    // Cargar configuraciÃ³n guardada o usar defaults
    let keyBindings = JSON.parse(localStorage.getItem('cosmicOS_keyBindings')) || {...defaultKeyBindings};

    // Guardar configuraciÃ³n
    function saveKeyBindings() {
      localStorage.setItem('cosmicOS_keyBindings', JSON.stringify(keyBindings));
      showToast('âš™ï¸ Controles guardados');
    }

    // Resetear a defaults
    function resetKeyBindings() {
      keyBindings = {...defaultKeyBindings};
      saveKeyBindings();
      updateKeyBindingsUI();
      showToast('âš™ï¸ Controles reseteados a defaults');
    }

    // Movimiento
    const moveState = { forward:0, back:0, left:0, right:0, up:0, down:0, rotateUp:0, rotateDown:0, rotateLeft:0, rotateRight:0 };
    const velocity = new THREE.Vector3();
    let acceleration = 4.5;
    const deceleration = 0.92;
    let maxSpeed = 45;
    let speedBoost = 1.0; // Multiplicador de velocidad con Ctrl
    let rotationSpeed = 0.02; // Velocidad de rotaciÃ³n de cÃ¡mara

    const availableSeeds = Array.from({length:200}, (_,i) => -10 + i);

    async function loadUniverse(seed) {
      document.getElementById('loading-overlay').style.display = 'flex';
      const seedDisplay = document.getElementById('current-seed');
      const modeDisplay = document.getElementById('current-mode');
      const seedDisplayTop = document.getElementById('current-seed-display');
      const modeDisplayTop = document.getElementById('current-mode-display');
      
      if (seedDisplay) seedDisplay.textContent = seed;
      if (seedDisplayTop) seedDisplayTop.textContent = seed;

      try {
        const res = await fetch(`web/data_seed_${seed}.json`);
        if (!res.ok) throw new Error("404");
        const data = await res.json();

        // Limpiar escena
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) scene.remove(centralSingularity);

        // ğŸŒŒ GARGANTUA SINGULARITY v9.4.0
        centralSingularity = createGargantuaSingularity();
        scene.add(centralSingularity);

        // Nodos
        if (data.nodes) {
          const pos = new Float32Array(data.nodes.length * 3);
          data.nodes.forEach((n,i) => {
            const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
            pos[i*3] = p[0]; pos[i*3+1] = p[1]; pos[i*3+2] = p[2];
          });
          const g = new THREE.BufferGeometry();
          g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          pointsCloud = new THREE.Points(g, new THREE.PointsMaterial({color:0x00ffff, size:8}));
          scene.add(pointsCloud);
        }

        const modoText = data.modo || "DOLPHIN";
        if (modeDisplay) modeDisplay.textContent = modoText;
        if (modeDisplayTop) modeDisplayTop.textContent = modoText;
        
        // Update Titan Panel
        const titanMode = document.getElementById('titan-mode');
        const titanSeed = document.getElementById('titan-seed');
        const titanHorror = document.getElementById('titan-horror');
        if (titanMode) titanMode.textContent = modoText;
        if (titanSeed) titanSeed.textContent = seed;
        if (titanHorror && data.horror_total) {
          titanHorror.textContent = Math.round(data.horror_total).toLocaleString();
        }
      } catch (e) {
        console.error("Error:", e);
        if (modeDisplay) modeDisplay.textContent = "ERROR";
        if (modeDisplayTop) modeDisplayTop.textContent = "ERROR";
      }

      document.getElementById('loading-overlay').style.display = 'none';
    }

    function initEngine() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000);
      camera.position.set(0, 500, 1500);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(innerWidth, innerHeight);
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // MOVED: Double click listener added here to ensure renderer exists
      renderer.domElement.addEventListener('dblclick', (event) => {
        const mouse = new THREE.Vector2(
          (event.clientX / window.innerWidth) * 2 - 1,
          -(event.clientY / window.innerHeight) * 2 + 1
        );
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);

        const intersectables = [];
        if (centralSingularity) intersectables.push(centralSingularity);
        if (pointsCloud) intersectables.push(pointsCloud);

        const intersects = raycaster.intersectObjects(intersectables, true);
        if (intersects.length > 0) {
          const target = intersects[0].point;
          const startPos = camera.position.clone();
          const distance = 200;
          const direction = new THREE.Vector3().subVectors(camera.position, target).normalize();
          const endPos = target.clone().add(direction.multiplyScalar(distance));

          gsap.to(camera.position, {
            x: endPos.x, y: endPos.y, z: endPos.z, duration: 1.5, ease: 'power2.inOut',
            onUpdate: () => { controls.target.copy(target); controls.update(); },
            onComplete: () => { console.log('ğŸš€ Viaje completado a:', target); }
          });
          console.log('ğŸš€ Viajando a nodo/agujero negro...');
        }
      });

      loadUniverse(currentUniverseSeed);
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      // Control temporal
      if (isPaused) {
        renderer.render(scene, camera);
        return;
      }

      const speedMultiplier = timeSpeed;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

      const accel = new THREE.Vector3();
      if (moveState.forward) accel.addScaledVector(dir, acceleration * speedMultiplier);
      if (moveState.back) accel.addScaledVector(dir, -acceleration * speedMultiplier);
      // FIXED: Swapped signs for correct Left/Right strafing
      if (moveState.left) accel.addScaledVector(side, acceleration * speedMultiplier);
      if (moveState.right) accel.addScaledVector(side, -acceleration * speedMultiplier);
      if (moveState.up) accel.y += acceleration * speedMultiplier;
      if (moveState.down) accel.y -= acceleration * speedMultiplier;

      velocity.add(accel);
      velocity.multiplyScalar(deceleration);
      if (velocity.length() > maxSpeed) velocity.setLength(maxSpeed);

      camera.position.add(velocity);
      controls.target.add(velocity);
      
      // RotaciÃ³n de cÃ¡mara con flechas (360Â°)
      if (moveState.rotateLeft) {
        camera.rotation.y += rotationSpeed * speedMultiplier;
      }
      if (moveState.rotateRight) {
        camera.rotation.y -= rotationSpeed * speedMultiplier;
      }
      if (moveState.rotateUp) {
        camera.rotation.x += rotationSpeed * speedMultiplier;
      }
      if (moveState.rotateDown) {
        camera.rotation.x -= rotationSpeed * speedMultiplier;
      }
      
      // SOLO actualizar OrbitControls si NO estamos en modo inmersivo
      // Esto permite rotaciÃ³n libre de 360Â° sin que OrbitControls la sobrescriba
      if (!isImmersionMode) {
        controls.update();
      }

      if (centralSingularity) {
        // Rotate accretion disk
        if (centralSingularity.userData.disk) {
          centralSingularity.userData.disk.rotation.y += 0.005 * speedMultiplier;
        }
        // Pulse photon sphere
        if (centralSingularity.userData.photonSphere) {
          const pulse = Math.sin(Date.now() * 0.001) * 0.05 + 0.15;
          centralSingularity.userData.photonSphere.material.opacity = pulse;
        }
      }

      // Animar lÃ­neas Matrix si estÃ¡n activas
      if (matrixLines && matrixModeActive) {
        matrixLines.rotation.y += 0.001 * speedMultiplier;
        
        if (isFiestaMode && audioInitialized && analyser) {
          // FIESTA MODE: React to audio
          analyser.getByteFrequencyData(dataArray);
          
          // Calculate average volume (bass focused)
          let sum = 0;
          const bassRange = 20; // First 20 bins
          for(let i = 0; i < bassRange; i++) {
            sum += dataArray[i];
          }
          const average = sum / bassRange;
          const normalizedVol = average / 255; // 0.0 to 1.0
          
          // Modulate color and opacity based on volume
          // Bass kicks -> shift hue drastically
          // Volume -> Brightness/Opacity
          
          const time = Date.now() * 0.002;
          const hue = (time + normalizedVol * 0.5) % 1; 
          const saturation = 0.8 + (normalizedVol * 0.2);
          const lightness = 0.3 + (normalizedVol * 0.7); // Beat flashes brighter
          
          matrixLines.material.color.setHSL(hue, saturation, lightness);
          matrixLines.material.opacity = 0.2 + (normalizedVol * 0.8); // Beat makes it opaque
          
        } else {
          // DMX MODE (Default): Dynamic color cycling based on "ion flow"
          const time = Date.now() * 0.0005;
          const hue = (time % 1); // 0.0 to 1.0
          const saturation = 0.8;
          const lightness = 0.5;
          matrixLines.material.color.setHSL(hue, saturation, lightness);
          matrixLines.material.opacity = matrixOpacity;
        }
      }

      // Update Titan Panel stats
      updateTitanPanel();

      renderer.render(scene, camera);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ¨ THEME SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const themeSelect = document.getElementById('uxTheme');
    if (themeSelect) {
      themeSelect.addEventListener('change', (e) => {
        setTheme(e.target.value);
      });
    }

    function setTheme(theme) {
      console.log(`ğŸ¨ Theme changed to: ${theme}`);
      
      const nodes = pointsCloud ? pointsCloud.geometry : null;
      
      switch(theme) {
        case 'PHOTON':
          // MODO FOTÃ“N: Cyan electric, bright, high contrast
          document.documentElement.style.setProperty('--text-cyan', '#00ffff');
          document.body.style.background = '#000000';
          
          if (pointsCloud) {
            pointsCloud.material.size = 6;
            pointsCloud.material.opacity = 0.9;
            pointsCloud.material.color = new THREE.Color(0x00ffff);
            pointsCloud.material.vertexColors = false; // Override vertex colors
          }
          
          // Matrix lines bright
          if (matrixLines) {
            matrixLines.material.color = new THREE.Color(0xffffff);
            matrixLines.material.opacity = 0.5;
          }
          
          showToast('âš¡ MODO FOTÃ“N ACTIVADO');
          break;
          
        case 'PARADOX':
          // MODO 666 PARADOX: Fire, Red/Orange/Yellow, Hellish
          document.documentElement.style.setProperty('--text-cyan', '#ff4500'); // OrangeRed
          document.body.style.background = '#1a0500'; // Dark red/brown
          
          if (pointsCloud) {
            pointsCloud.material.size = 10;
            pointsCloud.material.opacity = 1.0;
            pointsCloud.material.vertexColors = true;
            
            // Recolor nodes to fire gradient
            const count = nodes.attributes.position.count;
            const colors = nodes.attributes.color.array;
            
            for (let i = 0; i < count; i++) {
              const r = Math.random() * 0.5 + 0.5; // 0.5-1.0 (Red)
              const g = Math.random() * 0.5;       // 0-0.5 (Green -> Orange/Yellow)
              const b = 0;                         // No blue
              
              colors[i * 3] = r;
              colors[i * 3 + 1] = g;
              colors[i * 3 + 2] = b;
            }
            nodes.attributes.color.needsUpdate = true;
          }
          
          // Singularity becomes a burning sun
          if (centralSingularity) {
            const children = centralSingularity.children;
            children.forEach(child => {
              if (child.isMesh && child.geometry.type === 'SphereGeometry') {
                 // Core becomes bright yellow/white
                 if (child.geometry.parameters.radius === 30) {
                   child.material.color.setHex(0xffff00);
                 }
                 // Glow becomes orange
                 if (child.geometry.parameters.radius === 45) {
                   child.material.color.setHex(0xff4500);
                   child.material.opacity = 0.4;
                 }
              }
            });
          }
          
          showToast('ğŸ”¥ 666 PARADOX ACTIVADO');
          break;
          
        case 'COSMIC':
        default:
          // Reset to default
          document.documentElement.style.setProperty('--text-cyan', '#00f2ff');
          document.body.style.background = 'var(--bg-black)';
           
          // Restore functionality would require reloading mechanism or storing original state
          // For now, we just reset colors if possible or re-enable vertex colors
          if (pointsCloud) {
             pointsCloud.material.vertexColors = true;
             pointsCloud.material.color = new THREE.Color(0xffffff);
             pointsCloud.material.size = 8;
          }
          if (centralSingularity) {
             // Reset singularity colors
             centralSingularity.children[0].material.color.setHex(0x000000); // Core
             centralSingularity.children[1].material.color.setHex(0xffffff); // Glow
          }
          showToast('ğŸŒŒ MODO CÃ“SMICO RESTAURADO');
          break;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§  NEURAL INTERFACE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    let lastTime = performance.now();
    let fps = 60;
    let frameCount = 0;
    let lastFpsUpdate = performance.now();

    function updateTitanPanel() {
      // FPS calculation
      frameCount++;
      const now = performance.now();
      if (now - lastFpsUpdate >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = now;
        
        const fpsEl = document.getElementById('titan-fps');
        if (fpsEl) {
          fpsEl.textContent = fps;
          fpsEl.className = 'titan-stat-value';
          if (fps < 30) fpsEl.classList.add('danger');
          else if (fps < 50) fpsEl.classList.add('warning');
        }
      }

      // Node count
      const nodesEl = document.getElementById('titan-nodes');
      if (nodesEl && pointsCloud) {
        const count = pointsCloud.geometry.attributes.position.count;
        nodesEl.textContent = count.toLocaleString();
      }

      // Memory usage
      const memEl = document.getElementById('titan-memory');
      if (memEl && performance.memory) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        memEl.textContent = mb + ' MB';
      }

      // Speed
      const speedEl = document.getElementById('titan-speed');
      if (speedEl) {
        if (isPaused) {
          speedEl.textContent = 'PAUSED';
          speedEl.className = 'titan-stat-value warning';
        } else {
          speedEl.textContent = 'x' + timeSpeed.toFixed(1);
          speedEl.className = 'titan-stat-value';
        }
      }
    }

    function enterCosmicOS() {
      gsap.to("#intro-overlay", {opacity:0, duration:1.2, onComplete:() => {
        document.getElementById('intro-overlay').style.display = 'none';
        initEngine();
      }});
    }

    function invokeCaos() {
      const randomSeed = availableSeeds[Math.floor(Math.random() * availableSeeds.length)];
      currentUniverseSeed = randomSeed;
      loadUniverse(randomSeed);
    }

    function invokeFusion() {
      const seedCount = parseInt(document.getElementById('seedSlider').value);
      const seeds = [];
      for (let i = 0; i < seedCount; i++) {
        seeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
      }
      console.log('FUSION MODE:', seeds);
      loadMultipleSeeds(seeds);
    }

    async function loadMultipleSeeds(seeds) {
      document.getElementById('loading-overlay').style.display = 'flex';
      
      if (pointsCloud) scene.remove(pointsCloud);
      
      const allNodes = [];
      const offsetDistance = 2000;
      
      for (let i = 0; i < seeds.length; i++) {
        try {
          const res = await fetch(`web/data_seed_${seeds[i]}.json`);
          if (!res.ok) continue;
          const data = await res.json();
          
          if (data.nodes) {
            const angle = (i / seeds.length) * Math.PI * 2;
            const offsetX = Math.cos(angle) * offsetDistance;
            const offsetZ = Math.sin(angle) * offsetDistance;
            
            const hue = (i / seeds.length) * 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 0.8, 0.6);
            
            data.nodes.forEach(n => {
              const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
              allNodes.push({
                x: p[0] + offsetX,
                y: p[1],
                z: p[2] + offsetZ,
                r: color.r,
                g: color.g,
                b: color.b
              });
            });
          }
        } catch (e) {
          console.error(`Error loading seed ${seeds[i]}:`, e);
        }
      }
      
      const positions = new Float32Array(allNodes.length * 3);
      const colors = new Float32Array(allNodes.length * 3);
      
      allNodes.forEach((n, i) => {
        positions[i * 3] = n.x;
        positions[i * 3 + 1] = n.y;
        positions[i * 3 + 2] = n.z;
        colors[i * 3] = n.r;
        colors[i * 3 + 1] = n.g;
        colors[i * 3 + 2] = n.b;
      });
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 8,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        })
      );
      
      scene.add(pointsCloud);
      document.getElementById('loading-overlay').style.display = 'none';
      
      showToast(`${seeds.length} universos fusionados`);
    }

    function resetCamera() {
      if (camera && controls) {
        camera.position.set(0, 500, 1500);
        controls.target.set(0, 0, 0);
        velocity.set(0, 0, 0);
        controls.update();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸŸ¢ MATRIX MODE - FULL MESH INTERCONNECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function createMatrixLines() {
      if (!pointsCloud || !scene) return;
      
      removeMatrixLines(); // Limpiar lÃ­neas anteriores
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const nodeCount = positions.length / 3;
      
      // Crear todas las conexiones (full mesh)
      const linePositions = [];
      for (let i = 0; i < nodeCount; i++) {
        for (let j = i + 1; j < nodeCount; j++) {
          // LÃ­nea de nodo i a nodo j
          linePositions.push(
            positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
            positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
          );
        }
      }
      
      const lineGeometry = new THREE.BufferGeometry();
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(linePositions), 3));
      
      const lineMaterial = new THREE.LineBasicMaterial({
        color: matrixColor,
        opacity: matrixOpacity,
        transparent: true,
        linewidth: 1
      });
      
      matrixLines = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(matrixLines);
      
      console.log(`ğŸŸ¢ MATRIX MODE: ${nodeCount} nodos, ${linePositions.length / 6} lÃ­neas`);
    }

    function removeMatrixLines() {
      if (matrixLines && scene) {
        scene.remove(matrixLines);
        matrixLines.geometry.dispose();
        matrixLines.material.dispose();
        matrixLines = null;
      }
    }

    function updateMatrixColor() {
      if (matrixLines) {
        matrixLines.material.color.setHex(matrixColor);
      }
    }

    function updateMatrixOpacity() {
      if (matrixLines) {
        matrixLines.material.opacity = matrixOpacity;
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // â±ï¸ TEMPORAL SPEED CONTROL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function setSpeed(speed) {
      timeSpeed = speed;
      isPaused = (speed === 0);
      
      // Update displays
      const display = document.getElementById('speed-display');
      const sliderDisplay = document.getElementById('speedSliderDisplay');
      const slider = document.getElementById('speedSlider');
      
      if (display) {
        if (isPaused) {
          display.textContent = 'â¸ PAUSED';
          display.style.color = 'var(--text-red)';
        } else if (speed < 0) {
          display.textContent = `â—€ ${speed}x`;
          display.style.color = 'var(--text-magenta)';
        } else {
          display.textContent = `â–¶ ${speed}x`;
          display.style.color = 'var(--text-cyan)';
        }
      }
      
      if (sliderDisplay) sliderDisplay.textContent = speed.toFixed(1);
      if (slider) slider.value = speed;
      
      // Highlight active button
      document.querySelectorAll('.temporal-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      console.log(`â±ï¸ Velocidad: ${isPaused ? 'PAUSED' : speed + 'x'}`);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§­ QUICK NAVIGATION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function goToSingularity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 200,
        y: 100,
        z: 200,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('ğŸŒŒ Llegaste a la Singularidad');
        }
      });
    }

    function escapeGravity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 5000,
        y: 3000,
        z: 5000,
        duration: 3,
        ease: 'power2.out',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('ğŸš€ Escapaste de la gravedad');
        }
      });
    }

    function goToNearestNode() {
      if (!pointsCloud || !camera) return;
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const camPos = camera.position;
      
      let nearestDist = Infinity;
      let nearestPos = null;
      
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];
        
        const dist = Math.sqrt(
          Math.pow(x - camPos.x, 2) +
          Math.pow(y - camPos.y, 2) +
          Math.pow(z - camPos.z, 2)
        );
        
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestPos = { x, y, z };
        }
      }
      
      if (nearestPos) {
        const direction = new THREE.Vector3(
          camPos.x - nearestPos.x,
          camPos.y - nearestPos.y,
          camPos.z - nearestPos.z
        ).normalize();
        
        const targetPos = {
          x: nearestPos.x + direction.x * 100,
          y: nearestPos.y + direction.y * 100,
          z: nearestPos.z + direction.z * 100
        };
        
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 1.5,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(nearestPos.x, nearestPos.y, nearestPos.z);
            controls.update();
          },
          onComplete: () => {
            showToast('ğŸ¯ Nodo mÃ¡s cercano alcanzado');
          }
        });
      }
    }

    function goToRandomPosition() {
      if (!camera) return;
      
      const randomPos = {
        x: (Math.random() - 0.5) * 4000,
        y: (Math.random() - 0.5) * 2000,
        z: (Math.random() - 0.5) * 4000
      };
      
      gsap.to(camera.position, {
        x: randomPos.x,
        y: randomPos.y,
        z: randomPos.z,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('ğŸ² PosiciÃ³n aleatoria');
        }
      });
    }

    function toggleImmersionMode() {
      isImmersionMode = !isImmersionMode;
      document.body.style.cursor = isImmersionMode ? 'none' : 'default';
      
      const hud = document.querySelector('.hud-module');
      const toggle = document.querySelector('.immersion-toggle');
      const temporalControls = document.getElementById('temporal-controls');
      
      if (hud) hud.style.display = isImmersionMode ? 'none' : 'block';
      
      // Toggle siempre visible, solo cambia opacidad
      if (toggle) {
        toggle.style.opacity = isImmersionMode ? '0.5' : '1';
        toggle.textContent = isImmersionMode ? 'Exit Immersion [H]' : 'Immersion [H]';
      }
      
      // CRITICAL: Disable OrbitControls in immersive mode
      if (controls) {
        controls.enabled = !isImmersionMode;
      }
      
      // Temporal controls SOLO en modo inmersivo
      if (temporalControls) {
        temporalControls.style.display = isImmersionMode ? 'block' : 'none';
      }
      
      // ğŸŒŒ ZOOM OUT AL ENTRAR EN MODO INMERSIVO
      if (isImmersionMode && camera) {
        // Guardar posiciÃ³n actual
        const currentPos = camera.position.clone();
        
        // Calcular punto mÃ¡s lejano visible (vista panorÃ¡mica)
        const farDistance = 3000; // Distancia lejana
        const direction = new THREE.Vector3(1, 1, 1).normalize(); // Diagonal
        const farPos = direction.multiplyScalar(farDistance);
        
        // Animar cÃ¡mara hacia posiciÃ³n lejana
        gsap.to(camera.position, {
          x: farPos.x,
          y: farPos.y,
          z: farPos.z,
          duration: 2,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(0, 0, 0); // Mirar al centro
            controls.update();
          },
          onComplete: () => {
            console.log('ğŸŒŒ Vista panorÃ¡mica activada - Listo para explorar');
          }
        });
      }
      
      console.log(isImmersionMode ? 'ğŸŒŒ IMMERSION ON - Temporal controls habilitados' : 'ğŸŒŒ IMMERSION OFF');
    }

    // Event listeners (se ejecutan despuÃ©s de cargar DOM)
    document.addEventListener('DOMContentLoaded', () => {
      // Sliders
      document.getElementById('nodeSlider')?.addEventListener('input', e => {
        document.getElementById('nodeDisplay').textContent = e.target.value;
      });
      document.getElementById('seedSlider')?.addEventListener('input', e => {
        document.getElementById('seedDisplay').textContent = e.target.value;
      });

      // Matrix Mode Toggle
      document.getElementById('matrixMode')?.addEventListener('change', e => {
        matrixModeActive = e.target.checked;
        const controls = document.getElementById('matrixControls');
        if (controls) controls.style.display = matrixModeActive ? 'block' : 'none';
        
        if (matrixModeActive) {
          createMatrixLines();
        } else {
          removeMatrixLines();
        }
      });

      // Matrix Color Preset
      document.getElementById('matrixColorPreset')?.addEventListener('change', e => {
        const customGroup = document.getElementById('customColorGroup');
        if (e.target.value === 'custom') {
          customGroup.style.display = 'block';
          const picker = document.getElementById('matrixColorPicker');
          matrixColor = parseInt(picker.value.replace('#', '0x'));
        } else {
          customGroup.style.display = 'none';
          matrixColor = parseInt(e.target.value.replace('#', '0x'));
        }
        updateMatrixColor();
      });

      // Fiesta Mode Toggle
      document.getElementById('fiestaMode')?.addEventListener('change', e => {
        isFiestaMode = e.target.checked;
        if (isFiestaMode) {
          initAudio();
          // Ensure Matrix is on
          if (!matrixModeActive) {
            document.getElementById('matrixMode').click();
          }
        }
      });

      // Matrix Custom Color Picker
      document.getElementById('matrixColorPicker')?.addEventListener('input', e => {
        matrixColor = parseInt(e.target.value.replace('#', '0x'));
        updateMatrixColor();
      });

      // Matrix Opacity
      document.getElementById('matrixOpacity')?.addEventListener('input', e => {
        matrixOpacity = parseFloat(e.target.value);
        document.getElementById('matrixOpacityDisplay').textContent = matrixOpacity;
        updateMatrixOpacity();
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // â±ï¸ TEMPORAL CONTROLS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      document.getElementById('speedSlider')?.addEventListener('input', e => {
        const speed = parseFloat(e.target.value);
        setSpeed(speed);
      });

      // Teclado con controles configurables
      document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional (WASD)
        if (k === keyBindings.forward) moveState.forward = 1;
        if (k === keyBindings.back) moveState.back = 1;
        if (k === keyBindings.left) moveState.left = 1;
        if (k === keyBindings.right) moveState.right = 1;
        if (k === keyBindings.up) moveState.up = 1;
        if (k === keyBindings.down) moveState.down = 1;
        
        // RotaciÃ³n de cÃ¡mara (Flechas)
        if (k === 'arrowleft') moveState.rotateLeft = 1;
        if (k === 'arrowright') moveState.rotateRight = 1;
        if (k === 'arrowup') moveState.rotateUp = 1;
        if (k === 'arrowdown') moveState.rotateDown = 1;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 2.0;
          acceleration = 9.0;
          maxSpeed = 90;
        }
        
        // Acciones
        if (k === keyBindings.immersion || k === 'l') toggleImmersionMode();
        if (k === keyBindings.resetCamera) resetCamera();
        if (k === '?' || k === '/') openTutorial();
      });

      document.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional
        if (k === keyBindings.forward) moveState.forward = 0;
        if (k === keyBindings.back) moveState.back = 0;
        if (k === keyBindings.left) moveState.left = 0;
        if (k === keyBindings.right) moveState.right = 0;
        if (k === keyBindings.up) moveState.up = 0;
        if (k === keyBindings.down) moveState.down = 0;
        
        // RotaciÃ³n de cÃ¡mara
        if (k === 'arrowleft') moveState.rotateLeft = 0;
        if (k === 'arrowright') moveState.rotateRight = 0;
        if (k === 'arrowup') moveState.rotateUp = 0;
        if (k === 'arrowdown') moveState.rotateDown = 0;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 1.0;
          acceleration = 4.5;
          maxSpeed = 45;
        }
      });

      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸ® GAMEPAD / JOYSTICK SUPPORT
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      let gamepadConnected = false;
      let gamepadIndex = null;

      window.addEventListener('gamepadconnected', (e) => {
        gamepadConnected = true;
        gamepadIndex = e.gamepad.index;
        console.log(`ğŸ® Gamepad conectado: ${e.gamepad.id}`);
        showToast(`ğŸ® Gamepad conectado: ${e.gamepad.id}`);
      });

      window.addEventListener('gamepaddisconnected', (e) => {
        gamepadConnected = false;
        gamepadIndex = null;
        console.log('ğŸ® Gamepad desconectado');
      });

      function updateGamepad() {
        if (!gamepadConnected || gamepadIndex === null) return;

        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad) return;

        // Stick izquierdo: Movimiento horizontal/vertical
        const leftX = gamepad.axes[0]; // -1 (izq) a +1 (der)
        const leftY = gamepad.axes[1]; // -1 (arriba) a +1 (abajo)

        // Stick derecho: RotaciÃ³n cÃ¡mara
        const rightX = gamepad.axes[2];
        const rightY = gamepad.axes[3];

        // Deadzone para evitar drift
        const deadzone = 0.15;

        // Movimiento con stick izquierdo
        if (Math.abs(leftX) > deadzone) {
          moveState.left = leftX < 0 ? -leftX : 0;
          moveState.right = leftX > 0 ? leftX : 0;
        } else {
          moveState.left = 0;
          moveState.right = 0;
        }

        if (Math.abs(leftY) > deadzone) {
          moveState.forward = leftY < 0 ? -leftY : 0;
          moveState.back = leftY > 0 ? leftY : 0;
        } else {
          moveState.forward = 0;
          moveState.back = 0;
        }

        // Gatillos: Subir/Bajar
        const lt = gamepad.buttons[6]?.value || 0; // L2/LT
        const rt = gamepad.buttons[7]?.value || 0; // R2/RT
        moveState.down = lt;
        moveState.up = rt;

        // Botones de acciÃ³n
        if (gamepad.buttons[0]?.pressed) { // A/X - Reset camera
          resetCamera();
        }
        if (gamepad.buttons[1]?.pressed) { // B/Circle - Toggle immersion
          toggleImmersionMode();
        }
        if (gamepad.buttons[2]?.pressed) { // X/Square - CAOS
          invokeCaos();
        }
        if (gamepad.buttons[3]?.pressed) { // Y/Triangle - Matrix toggle
          const matrixCheckbox = document.getElementById('matrixMode');
          if (matrixCheckbox) matrixCheckbox.click();
        }
      }

      // Llamar updateGamepad en cada frame
      function gamepadLoop() {
        updateGamepad();
        requestAnimationFrame(gamepadLoop);
      }
      gamepadLoop();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // âš™ï¸ SETTINGS PANEL FUNCTIONS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function openSettings() {
        document.getElementById('settings-panel').style.display = 'flex';
        updateKeyBindingsUI();
      }

      function closeSettings() {
        document.getElementById('settings-panel').style.display = 'none';
        saveKeyBindings();
      }

      function openTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'flex';
      }

      function closeTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'none';
      }

      function updateKeyBindingsUI() {
        const container = document.getElementById('key-bindings-list');
        const labels = {
          forward: 'Adelante',
          back: 'AtrÃ¡s',
          left: 'Izquierda',
          right: 'Derecha',
          up: 'Subir',
          down: 'Bajar',
          rotateLeft: 'Rotar Izq',
          rotateRight: 'Rotar Der',
          speedBoost: 'Speed Boost',
          immersion: 'Immersion',
          resetCamera: 'Reset CÃ¡mara'
        };

        container.innerHTML = '';
        for (const [action, key] of Object.entries(keyBindings)) {
          const div = document.createElement('div');
          div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(0,242,255,0.05);border:1px solid var(--glass-border);border-radius:4px;';
          div.innerHTML = `
            <span style="color:#888;">${labels[action] || action}</span>
            <button onclick="rebindKey('${action}')" style="width:auto;padding:5px 15px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);text-transform:uppercase;">
              ${keyBindings[action] === ' ' ? 'SPACE' : keyBindings[action].toUpperCase()}
            </button>
          `;
          container.appendChild(div);
        }
      }

      let rebindingAction = null;

      function rebindKey(action) {
        rebindingAction = action;
        showToast('âŒ¨ï¸ Presiona la nueva tecla para ' + action, 5000);
        
        const listener = (e) => {
          e.preventDefault();
          const newKey = e.key.toLowerCase();
          keyBindings[action] = newKey;
          updateKeyBindingsUI();
          rebindingAction = null;
          document.removeEventListener('keydown', listener);
          showToast(`âœ… ${action} â†’ ${newKey === ' ' ? 'SPACE' : newKey.toUpperCase()}`);
        };
        
        document.addEventListener('keydown', listener);
      }

      // Toast notification helper
      function showToast(message, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.cssText = `
          position:fixed; top:80px; right:20px; z-index:10000;
          background:rgba(0,242,255,0.2); border:1px solid var(--text-cyan);
          padding:15px 20px; border-radius:8px; color:var(--text-cyan);
          font-size:0.9rem; pointer-events:none;
          animation: slideIn 0.3s ease-out;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      window.addEventListener('resize', () => {
        if (camera) {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(innerWidth, innerHeight);
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ğŸš€ DOUBLE CLICK TO TRAVEL (Teleport to node/black hole)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Init logic when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
       if (typeof updateKeyBindingsUI === 'function') updateKeyBindingsUI();
    });
  </script>
</head>
<body>

  <div id="intro-overlay" onclick="enterCosmicOS()">
    <div style="text-align:center">
      <h1 style="color:var(--text-cyan);font-size:4rem;margin:0">COSMIC OS</h1>
      <p style="color:var(--text-magenta);letter-spacing:6px">v3.3 CONTROL TOTAL</p>
      <div style="margin-top:30px;color:#555">[ CLICK TO ENTER ]</div>
    </div>
  </div>

  <div id="loading-overlay">SYNCHRONIZING IONIC CHANNELS...</div>

  <div id="canvas-container"></div>

  <!-- Titan Panel - Stats Bar -->
  <div id="titan-panel">
    <div class="titan-stat">
      <span class="titan-stat-label">FPS</span>
      <span id="titan-fps" class="titan-stat-value">60</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Nodes</span>
      <span id="titan-nodes" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Horror</span>
      <span id="titan-horror" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Memory</span>
      <span id="titan-memory" class="titan-stat-value">0 MB</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Speed</span>
      <span id="titan-speed" class="titan-stat-value">x1.0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Mode</span>
      <span id="titan-mode" class="titan-stat-value">LOADING</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Seed</span>
      <span id="titan-seed" class="titan-stat-value">-10</span>
    </div>
  </div>

  <!-- Seed/Mode Display - Siempre visible -->
  <div style="position:fixed;top:50px;left:20px;z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:10px 15px;pointer-events:none;">
    <div style="font-size:0.7rem;color:#666;margin-bottom:3px;">CURRENT UNIVERSE</div>
    <div style="font-size:1rem;font-weight:bold;">
      <span style="color:var(--text-cyan);">Seed:</span> <span id="current-seed-display" style="color:var(--text-yellow);">-10</span>
    </div>
    <div style="font-size:0.9rem;margin-top:3px;">
      <span style="color:var(--text-magenta);">Mode:</span> <span id="current-mode-display" style="color:var(--text-green);">LOADING...</span>
    </div>
  </div>

  <div id="config-module" class="hud-module">
    <div class="hud-title">ğŸ§  NEURAL CONFIG</div>
    <div class="input-group">
      <label>Nodos: <span id="nodeDisplay">1500</span></label>
      <input type="range" id="nodeSlider" min="50" max="26000" value="1500" step="50">
    </div>
    <div class="input-group">
      <label>Multi-Seed: <span id="seedDisplay">3</span></label>
      <input type="range" id="seedSlider" min="1" max="10" value="3" step="1">
    </div>
    <div class="input-group">
      <label>VisualizaciÃ³n</label>
      <select id="vizMode">
        <option value="ORBITAL" selected>Ã“RBITA MULTI-SEED ğŸŒŒ</option>
        <option value="ENTITY">ENTE VIAJERO ğŸ‘¾</option>
        <option value="BICAMERAL">CEREBRO BICAMERAL ğŸ§ </option>
        <option value="FUSION">FUSIÃ“N MULTIVERSAL ğŸ§¬</option>
      </select>
    </div>
    <div class="input-group">
      <label>Meta-Tema</label>
      <select id="uxTheme">
        <option value="COSMIC" selected>ABISMO CÃ“SMICO ğŸŒŒ</option>
        <option value="MAPUCHE">MAPUCHE-CÃ“SMICO ğŸ”ï¸</option>
        <option value="CRISTAL">CRISTAL ğŸ’</option>
        <option value="MANDA">MANDALA ğŸŒ€</option>
        <option value="NAVE">NAVE ESPACIAL ğŸš€</option>
        <option value="PHOTON">MODO FOTÃ“N âš¡</option>
        <option value="PARADOX">666 PARADOX ğŸ”¥</option>
      </select>
    </div>
    <button onclick="invokeCaos()" style="background:var(--text-magenta);color:white">CAOS</button>
    <button onclick="invokeFusion()" style="background:var(--text-cyan);color:black">FUSIÃ“N</button>
    <button onclick="resetCamera()" style="background:#333;color:white">RESET CAM</button>
    
    <div class="input-group" style="margin-top:12px;border-top:1px solid var(--glass-border);padding-top:12px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="matrixMode" style="width:auto;">
        <span>MATRIX MODE ğŸŸ¢</span>
      </label>
      <label style="display:flex;align-items:center;gap:8px;margin-top:5px;">
        <input type="checkbox" id="fiestaMode" style="width:auto;">
        <span>FIESTA MODE (MIC) ğŸ¤</span>
      </label>
    </div>
    
    <div id="matrixControls" style="display:none;margin-top:8px;">
      <div class="input-group">
        <label>Color Matrix</label>
        <select id="matrixColorPreset">
          <option value="#00ff41" selected>Matrix Green ğŸŸ¢</option>
          <option value="#ff00ff">Vaporwave Purple ğŸ’œ</option>
          <option value="#00f2ff">Cyan Hacker ğŸ”µ</option>
          <option value="#ff0033">Red Alert ğŸ”´</option>
          <option value="#ffff00">Yellow Electric âš¡</option>
          <option value="custom">Custom...</option>
        </select>
      </div>
      <div class="input-group" id="customColorGroup" style="display:none;">
        <label>Color Personalizado</label>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="height:40px;cursor:pointer;">
      </div>
      <div class="input-group">
        <label>Opacidad: <span id="matrixOpacityDisplay">0.3</span></label>
        <input type="range" id="matrixOpacity" min="0.1" max="1" value="0.3" step="0.1">
      </div>
    </div>
    
    <div style="margin-top:10px;font-size:0.7rem;color:#666;border-top:1px solid var(--glass-border);padding-top:8px;">
      Seed: <span id="current-seed" style="color:var(--text-cyan)">-10</span><br>
      Mode: <span id="current-mode" style="color:var(--text-magenta)">LOADING...</span>
    </div>
  </div>

  <button class="immersion-toggle" onclick="toggleImmersionMode()">Immersion [H]</button>

  <div id="temporal-controls">
    <div class="hud-title">â±ï¸ TEMPORAL CONTROL</div>
    <div id="speed-display">x1.0</div>
    <div style="display:flex;justify-content:center;gap:5px;margin-bottom:10px;">
      <button class="temporal-btn" onclick="setSpeed(-10)">â—€â—€ -10x</button>
      <button class="temporal-btn" onclick="setSpeed(-5)">â—€ -5x</button>
      <button class="temporal-btn" onclick="setSpeed(0)">â¸ PAUSE</button>
      <button class="temporal-btn active" onclick="setSpeed(1)">â–¶ 1x</button>
      <button class="temporal-btn" onclick="setSpeed(5)">â–¶â–¶ 5x</button>
      <button class="temporal-btn" onclick="setSpeed(10)">â–¶â–¶â–¶ 10x</button>
      <button class="temporal-btn" onclick="setSpeed(20)">âš¡ 20x</button>
    </div>
    <div class="input-group">
      <label>Velocidad: <span id="speedSliderDisplay">1.0</span>x</label>
      <input type="range" id="speedSlider" min="-10" max="20" value="1" step="0.5">
    </div>
    
    <!-- IMMERSIVE CONTROLS -->
    <div style="margin-top:15px;padding-top:10px;border-top:1px solid var(--glass-border);">
      <div style="font-size:0.75rem;color:#888;margin-bottom:5px;">IMMERSIVE TOGGLES</div>
      <div style="display:flex;gap:10px;">
        <button onclick="document.getElementById('matrixMode').click()" style="background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);font-size:0.8rem;">
          TOGGLE MATRIX
        </button>
        <button onclick="document.getElementById('fiestaMode').click()" style="background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);font-size:0.8rem;">
          TOGGLE FIESTA
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Panel (Hidden by default) -->
  <div id="settings-panel" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.9);align-items:center;justify-content:center;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">âš™ï¸ SETTINGS</h2>
        <button onclick="closeSettings()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div class="hud-title" style="margin-bottom:15px;">KEYBOARD CONTROLS</div>
      
      <div id="key-bindings-list" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:20px;">
        <!-- Populated by updateKeyBindingsUI() -->
      </div>
      
      <div style="display:flex;gap:10px;">
        <button onclick="resetKeyBindings()" style="background:var(--text-red);">RESET TO DEFAULTS</button>
        <button onclick="closeSettings()" style="background:var(--text-cyan);color:black;">SAVE & CLOSE</button>
      </div>
    </div>
  </div>

  <!-- Tutorial / Help Overlay -->
  <div id="tutorial-overlay" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.95);align-items:center;justify-content:center;overflow-y:auto;padding:20px;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:800px;width:90%;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">â“ COSMIC OS TUTORIAL</h2>
        <button onclick="closeTutorial()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
        <div>
          <div class="hud-title" style="margin-bottom:10px;">âŒ¨ï¸ KEYBOARD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">W/S/A/D</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">Q/E</b> - Rotar cÃ¡mara<br>
            <b style="color:var(--text-cyan);">Space</b> - Subir<br>
            <b style="color:var(--text-cyan);">Shift</b> - Bajar<br>
            <b style="color:var(--text-cyan);">Ctrl</b> - Speed Boost 2x<br>
            <b style="color:var(--text-cyan);">H/L</b> - Modo Inmersivo<br>
            <b style="color:var(--text-cyan);">R</b> - Reset CÃ¡mara<br>
            <b style="color:var(--text-cyan);">?</b> - Este tutorial<br>
          </div>
        </div>
        
        <div>
          <div class="hud-title" style="margin-bottom:10px;">ğŸ•¹ï¸ MOUSE</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Click + Drag</b> - Rotar vista<br>
            <b style="color:var(--text-cyan);">Scroll</b> - Zoom in/out<br>
            <b style="color:var(--text-cyan);">Double Click</b> - Viajar a nodo<br>
            <b style="color:var(--text-cyan);">Hover Izq</b> - Mostrar panel<br>
          </div>
          
          <div class="hud-title" style="margin:15px 0 10px;">ğŸ® GAMEPAD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Stick Izq</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">LT/RT</b> - Subir/Bajar<br>
            <b style="color:var(--text-cyan);">A</b> - Reset CÃ¡mara<br>
            <b style="color:var(--text-cyan);">B</b> - Immersion<br>
            <b style="color:var(--text-cyan);">X</b> - CAOS<br>
            <b style="color:var(--text-cyan);">Y</b> - Matrix Toggle<br>
          </div>
        </div>
      </div>
      
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid var(--glass-border);">
        <div class="hud-title" style="margin-bottom:10px;">ğŸŒŒ MODO INMERSIVO</div>
        <p style="font-size:0.85rem;color:#ccc;margin:0;">
          Presiona <b style="color:var(--text-cyan);">H</b> para entrar en modo inmersivo. La cÃ¡mara se alejarÃ¡ automÃ¡ticamente para vista panorÃ¡mica. 
          Los controles temporales aparecerÃ¡n en la esquina inferior derecha para controlar la velocidad de simulaciÃ³n (-10x a +20x).
        </p>
      </div>
      
      <button onclick="closeTutorial()" style="margin-top:20px;background:var(--text-cyan);color:black;">GOT IT!</button>
    </div>
  </div>

  <!-- Quick Navigation Panel -->
  <div style="position:fixed;bottom:100px;left:20px;z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:15px;width:200px;">
    <div class="hud-title" style="margin-bottom:10px;">ğŸ§­QUICK NAV</div>
    <button onclick="goToSingularity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
      ğŸŒŒ SINGULARITY
    </button>
    <button onclick="escapeGravity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);">
      ğŸš€ ESCAPE
    </button>
    <button onclick="goToNearestNode()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,255,0,0.2);border:1px solid var(--text-yellow);color:var(--text-yellow);">
      ğŸ¯ NEAREST NODE
    </button>
    <button onclick="goToRandomPosition()" style="width:100%;padding:8px;background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);">
      ğŸ² RANDOM
    </button>
  </div>

  <!-- Settings Toggle Button -->
  <button onclick="openSettings()" style="position:fixed;bottom:20px;left:20px;z-index:1000;width:auto;padding:10px 15px;background:rgba(255,255,255,0.1);border:1px solid var(--glass-border);color:var(--text-cyan);">
    âš™ï¸ SETTINGS
  </button>

  <button onclick="window.location.href='/hall_of_shame'" style="position:fixed;bottom:20px;left:140px;z-index:1000;width:auto;padding:10px 15px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
    ğŸ† HALL OF SHAME
  </button>

  <button onclick="openTutorial()" style="position:fixed;bottom:20px;left:320px;z-index:1000;width:auto;padding:10px 15px;background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);">
    â“ HELP
  </button>

</body>
</html>
