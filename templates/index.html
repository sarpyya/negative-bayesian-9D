<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‚ö° COSMIC 11D - CONTROL TOTAL ‚ö°</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Post-processing -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    :root {
      --bg-black: #000000;
      --glass-bg: rgba(0, 0, 0, 0.75);
      --glass-border: rgba(0, 242, 255, 0.3);
      --text-cyan: #00f2ff;
      --text-magenta: #ff00ff;
      --text-yellow: #ffff00;
      --text-red: #ff0033;
      --text-green: #00ff41;
    }
    
    /* Dark Glucose / Dark Matter Background */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(255, 0, 255, 0.12) 0%, transparent 50%);
      animation: breathe 8s ease-in-out infinite, drift 20s linear infinite;
      pointer-events:none;
      z-index:0;
    }
    
    @keyframes breathe {
      0%, 100% { opacity:0.3; transform:scale(1); }
      50% { opacity:0.6; transform:scale(1.1); }
    }
    
    @keyframes drift {
      0% { background-position: 0% 0%, 100% 100%, 50% 50%; }
      100% { background-position: 100% 100%, 0% 0%, 150% 150%; }
    }
    
    body, html { margin:0; padding:0; overflow:hidden; background:var(--bg-black); font-family:'Inter',sans-serif; color:white; }
    #canvas-container { position:absolute; inset:0; z-index:1; }
    #intro-overlay {
      position:fixed; inset:0; background:black; z-index:10000; display:flex;
      align-items:center; justify-content:center; cursor:pointer;
    }
    #loading-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:9000; display:none;
      align-items:center; justify-content:center; color:var(--text-cyan); font-size:2rem;
    }
    .hud-module {
      position:absolute; background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto; z-index:10;
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    }
    .hud-title { font-weight:700; font-size:0.9rem; letter-spacing:2px; color:var(--text-cyan); text-transform:uppercase; border-bottom:1px solid var(--glass-border); padding-bottom:5px; }
    
    /* Config Module - Collapsible from left */
    #config-module {
      bottom:300px; left:-280px; width:300px;
      transform:translateX(0);
      opacity:0.3;
    }
    #config-module:hover,
    #config-module:focus-within {
      transform:translateX(280px);
      opacity:1;
    }
    #config-module::before {
      content:'‚ò∞';
      position:absolute;
      right:-30px;
      top:50%;
      transform:translateY(-50%);
      background:var(--glass-bg);
      border:1px solid var(--glass-border);
      border-left:none;
      border-radius:0 8px 8px 0;
      padding:10px 8px;
      color:var(--text-cyan);
      font-size:1.2rem;
      cursor:pointer;
      pointer-events:auto;
    }
    .input-group { margin-bottom:12px; }
    .input-group label { display:block; font-size:0.75rem; color:#888; margin-bottom:5px; }
    .input-group input, .input-group select { width:100%; background:rgba(0,242,255,0.05); border:1px solid var(--glass-border); color:var(--text-cyan); padding:8px; border-radius:4px; }
    button { width:100%; padding:10px; border:none; border-radius:4px; font-weight:bold; cursor:pointer; text-transform:uppercase; }
    button:hover { filter:brightness(1.2); transform:scale(1.02); }
    .immersion-toggle { 
      position:fixed; top:20px; right:20px; z-index:2000; 
      background:rgba(0,255,136,0.2); border:1px solid var(--text-cyan); 
      color:var(--text-cyan); padding:8px 12px; cursor:pointer;
      transition: opacity 0.3s ease;
    }
    .immersion-toggle:hover {
      background:rgba(0,255,136,0.4);
      opacity:1 !important;
    }
    
    /* Temporal Controls */
    #temporal-controls {
      position:fixed; bottom:20px; right:20px; z-index:10;
      background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto;
      min-width:350px;
      display:none; /* Oculto por defecto, solo en immersive mode */
    }
    .temporal-btn {
      width:auto; padding:8px 15px; margin:0 3px;
      background:rgba(0,242,255,0.1); border:1px solid var(--glass-border);
      color:var(--text-cyan); font-size:0.9rem;
    }
    .temporal-btn.active { background:var(--text-cyan); color:black; }
    #speed-display {
      font-size:1.5rem; font-weight:bold; color:var(--text-cyan);
      text-align:center; margin:10px 0;
    }
    
    /* Titan Panel - Stats Bar */
    #titan-panel {
      position:fixed;
      top:0;
      left:0;
      right:0;
      height:40px;
      background:var(--glass-bg);
      backdrop-filter:blur(20px);
      border-bottom:1px solid var(--glass-border);
      box-shadow:0 2px 20px rgba(0,242,255,0.2);
      z-index:10000;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 20px;
      font-size:0.85rem;
      pointer-events:auto;
    }
    
    .titan-stat {
      display:flex;
      align-items:center;
      gap:8px;
      color:#888;
    }
    
    .titan-stat-label {
      color:#666;
      font-size:0.75rem;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    
    .titan-stat-value {
      color:var(--text-cyan);
      font-weight:bold;
      font-size:0.9rem;
    }
    
    .titan-stat-value.warning {
      color:var(--text-yellow);
    }
    
    .titan-stat-value.danger {
      color:var(--text-red);
    }
    
    .titan-divider {
      width:1px;
      height:20px;
      background:var(--glass-border);
    }
    
    /* Toast Animations */
    @keyframes slideIn {
      from { transform:translateX(400px); opacity:0; }
      to { transform:translateX(0); opacity:1; }
    }
    @keyframes slideOut {
      from { transform:translateX(0); opacity:1; }
      to { transform:translateX(400px); opacity:0; }
    }
  </style>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üî• DEFINIR FUNCIONES ANTES DEL HTML (FIX enterCosmicOS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // üöÄ ENTER COSMIC OS
    function enterCosmicOS() {
        if (typeof initEngine === 'function') {
            initEngine();
            const intro = document.getElementById('intro-overlay');
            if (intro) {
                gsap.to(intro, {
                    opacity: 0,
                    duration: 1,
                    onComplete: () => intro.style.display = 'none'
                });
            }
        }
    }

    // Variables globales
    let scene, camera, renderer, controls, composer;
    let bloomPass;
    let centralSingularity, pointsCloud;
    let matrixLines = null; // L√≠neas Matrix
    let ionLines = null;    // L√≠neas I√≥nicas (Channels)
    let orbitalIons = null; // Part√≠culas de flujo orbital
    let currentUniverseSeed = -10;
    let isImmersionMode = false;
    let matrixModeActive = false;
    let matrixColor = 0x00ff41; // Verde Matrix por defecto
    let matrixOpacity = 0.3;
    let timeSpeed = 1.0; // Velocidad de simulaci√≥n
    let isPaused = false;

    // AUDIO REACTIVITY (FIESTA MODE)
    let audioContext, analyser, dataArray;
    let isFiestaMode = false;
    let audioInitialized = false;
    let currentMode = "ORBITAL"; // Fallback narrative mode
    let currentUniverseData = { modo: "LOADING", modo_info: { physics: { gravity: 1000 } } }; 
    let frameCount = 0;
    
    // Performance Optimization Globals
    const CHUNK_SIZE = 10000; // Process 10k nodes per frame
    let currentChunk = 0;
    let totalNodes = 50000;
    
    // Debounce state
    let sliderTimeout = null;

    function initAudio() {
      if (audioInitialized) {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('üîä AudioContext resumed');
            showToast('üîä Audio Reactivado');
          });
        }
        return;
      }

      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API no soportada');

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            audioInitialized = true;
            if (audioContext.state === 'suspended') audioContext.resume();
            showToast('üé§ Micr√≥fono ACTIVO - Habla o pon m√∫sica');
            console.log('üé§ Audio Stream Connected');
          })
          .catch(err => {
            console.error('Error acceso microfono:', err);
            let msg = '‚ùå Error Micr√≥fono: ' + err.message;
            if (err.name === 'NotAllowedError') msg = '‚ùå Permiso denegado';
            if (err.name === 'NotFoundError') msg = '‚ùå No mic encontrado';
            showToast(msg, 5000);
            // Fallback inmediato a sim
            isFiestaMode = true;
            document.getElementById('fiestaMode').checked = true;
            showToast('‚ö†Ô∏è Activando SIMULACI√ìN AUDIO', 4000);
            console.log('‚ö†Ô∏è Audio simulation enabled');
            simulateAudioData(); // Init sim
          });
      } catch (e) {
        console.error('Audio Setup Error', e);
        showToast('‚ùå Error Audio: ' + e.message);
        // Fallback si try falla
        isFiestaMode = true;
        document.getElementById('fiestaMode').checked = true;
        simulateAudioData();
      }
    }

    // üéπ SYNTHETIC AUDIO GENERATOR (FIESTA RANDOM)
    function simulateAudioData() {
        if (!dataArray) {
             // Create dummy array if context failed completely
             dataArray = new Uint8Array(256);
        }
        
        const time = Date.now() * 0.001;
        // BPM based on seed (Random but deterministic per universe)
        const bpm = 120 + (Math.abs(currentUniverseSeed) % 60); 
        const freq = bpm / 60;
        
        // 1. Bass / Kick (Sharp Impulse)
        // sin wave raised to high power to create sharp beats
        const beatPhase = (time * freq) % 1.0;
        const kickEnvelope = Math.pow(1.0 - beatPhase, 4); // decay
        const kickVal = kickEnvelope * 255;
        
        // 2. Mids / Melan (Wobble)
        const wobble = (Math.sin(time * 3) + 1) / 2;
        
        // 3. Highs (Shimmer)
        
        // Fill Data Array with "Virtual" Sound
        for(let i=0; i<dataArray.length; i++) {
             if (i < 5) { // Deep Bass
                 dataArray[i] = kickVal; 
             } else if (i < 20) { // Bass
                 dataArray[i] = kickVal * 0.8;
             } else if (i < 100) { // Mids
                 dataArray[i] = wobble * 100 + (Math.random() * 50);
             } else { // Highs
                 dataArray[i] = (Math.sin(time * 10 + i) + 1) * 30 * kickEnvelope + (Math.random() * 20);
             }
        }
    }

    // üóø MAPUCHE PONEGLYPH TEXTURE GENERATOR
    function createPoneglyphTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 1. Background: Cosmic Stone Gradient (Cyan to Purple)
        const gradient = ctx.createLinearGradient(0, 0, size, size);
        gradient.addColorStop(0, '#003333'); // Deep Cyan
        gradient.addColorStop(1, '#1a0033'); // Deep Cosmic Purple
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        // 2. Stone Noise (Gritty texture)
        for (let i = 0; i < 60000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const val = Math.random() * 60;
            ctx.fillStyle = `rgba(${val},${val},${val + 40},0.15)`;
            ctx.fillRect(x, y, 2, 2);
        }

        // 3. Mapudungun Cosmic Symbols (Procedural Glyphs)
        ctx.strokeStyle = '#00ffff'; // Electric Cyan
        ctx.fillStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#00ffff';

        const cols = 4;
        const rows = 4;
        const cell = size / cols;

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (Math.random() > 0.65) continue; // Some empty spaces for weathered look

                const cx = x * cell + cell / 2;
                const cy = y * cell + cell / 2;
                const r = cell / 3;

                ctx.beginPath();
                const type = Math.floor(Math.random() * 6);

                if (type === 0) { // MEW (Kultrun Diamond)
                    ctx.moveTo(cx, cy - r);
                    ctx.lineTo(cx + r, cy);
                    ctx.lineTo(cx, cy + r);
                    ctx.lineTo(cx - r, cy);
                    ctx.closePath();
                    ctx.stroke();
                     // Central dot
                    ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
                } else if (type === 1) { // CIRCLES (Cycles)
                    ctx.arc(cx, cy, r * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (type === 2) { // STEP FRET (Greca / Stairs)
                    const s = r * 0.6;
                    ctx.moveTo(cx - s, cy + s);
                    ctx.lineTo(cx - s, cy);
                    ctx.lineTo(cx, cy);
                    ctx.lineTo(cx, cy - s);
                    ctx.lineTo(cx + s, cy - s);
                    ctx.stroke();
                } else if (type === 3) { // COSMIC CROSS
                   ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
                   ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
                   ctx.stroke();
                } else if (type === 4) { // ZIG ZAG (Lightning/Snake)
                   ctx.moveTo(cx - r, cy - r/2);
                   ctx.lineTo(cx - r/3, cy + r/2);
                   ctx.lineTo(cx + r/3, cy - r/2);
                   ctx.lineTo(cx + r, cy + r/2);
                   ctx.stroke();
                } else { // TEXT GLYPH
                   ctx.font = 'bold 30px monospace';
                   ctx.textAlign = 'center';
                   ctx.textBaseline = 'middle';
                   ctx.fillText(Math.random() > 0.5 ? 'MAPU' : 'ANTU', cx, cy);
                }
            }
        }
        
        // Border Frame
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 15;
        ctx.strokeRect(0, 0, size, size);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    function createGargantuaSingularity() {
      const group = new THREE.Group();
      
      // 1. PONEGLYPH CORE (Ancient Cosmic Cube)
      // Replaces the black sphere. Now it is a relic.
      const geometry = new THREE.BoxGeometry(70, 70, 70); // Slightly larger than prev sphere
      const texture = createPoneglyphTexture();
      
      const material = new THREE.MeshPhysicalMaterial({
          map: texture,
          color: 0xffffff,
          roughness: 0.2,
          metalness: 0.8,
          emissive: 0x00ffff,
          emissiveIntensity: 2.0,
          bumpMap: texture,
          bumpScale: 5,
          transmission: 0.1
      });
      
      const poneglyph = new THREE.Mesh(geometry, material);
      group.add(poneglyph);
      group.userData.poneglyph = poneglyph; // Ref for animation

      // 2. Photon Sphere (Glowing ring)
      const glowGeo = new THREE.SphereGeometry(60, 64, 64); // Adjusted size
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.05, // Lowered for Bloom safety
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);
      group.userData.photonSphere = glow;

      // 3. Accretion Disk
      const diskGeo = new THREE.RingGeometry(80, 200, 64);
      const pos = diskGeo.attributes.position;
      const v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++){
        v3.fromBufferAttribute(pos, i);
        // UV mapping for ring texture if we had one, or noise
        diskGeo.attributes.uv.setXY(i, v3.length() < 120 ? 0 : 1, 1);
      }
      
      // Particle System for Disk
      const diskPointsGeo = new THREE.BufferGeometry();
      const diskPointsCount = 8000; // Increased density
      const diskPositions = new Float32Array(diskPointsCount * 3);
      const diskColors = new Float32Array(diskPointsCount * 3);
      
      for(let i=0; i<diskPointsCount; i++) {
        const radius = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        
        // Spiral arms
        const spiralOffset = theta + (radius * 0.05);
        
        diskPositions[i*3] = Math.cos(spiralOffset) * radius;
        diskPositions[i*3+1] = (Math.random() - 0.5) * 10; // Volume
        diskPositions[i*3+2] = Math.sin(spiralOffset) * radius;
        
        // Color gradient: Inner hot (Cyan/White) -> Outer cool (Blue/Purple)
        const t = (radius - 80) / 120;
        const color = new THREE.Color();
        color.setHSL(0.5 + t * 0.1, 0.8, 0.7 - t * 0.4); // Cyan range
        diskColors[i*3] = color.r;
        diskColors[i*3+1] = color.g;
        diskColors[i*3+2] = color.b;
      }
      
      diskPointsGeo.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3));
      diskPointsGeo.setAttribute('color', new THREE.BufferAttribute(diskColors, 3));
      
      const disk = new THREE.Points(diskPointsGeo, new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      }));
      
      group.add(disk);
      group.userData.disk = disk;

      return group;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öôÔ∏è SISTEMA DE CONTROLES CONFIGURABLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Configuraci√≥n por defecto
    const defaultKeyBindings = {
      forward: 'w',
      back: 's',
      left: 'a',
      right: 'd',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'r'
    };

    // Cargar configuraci√≥n guardada o usar defaults
    let keyBindings = JSON.parse(localStorage.getItem('cosmicOS_keyBindings')) || {...defaultKeyBindings};

    // Guardar configuraci√≥n
    function saveKeyBindings() {
      localStorage.setItem('cosmicOS_keyBindings', JSON.stringify(keyBindings));
      showToast('‚öôÔ∏è Controles guardados');
    }

    // Resetear a defaults
    function resetKeyBindings() {
      keyBindings = {...defaultKeyBindings};
      saveKeyBindings();
      updateKeyBindingsUI();
      showToast('‚öôÔ∏è Controles reseteados a defaults');
    }

    // Movimiento
    const moveState = { forward:0, back:0, left:0, right:0, up:0, down:0, rotateUp:0, rotateDown:0, rotateLeft:0, rotateRight:0 };
    const velocity = new THREE.Vector3();
    let acceleration = 4.5;
    const deceleration = 0.92;
    let maxSpeed = 45;
    let speedBoost = 1.0; // Multiplicador de velocidad con Ctrl
    let rotationSpeed = 0.02; // Velocidad de rotaci√≥n de c√°mara

    const availableSeeds = Array.from({length:200}, (_,i) => -10 + i);

    async function loadUniverse(seed) {
      document.getElementById('loading-overlay').style.display = 'flex';
      const seedDisplay = document.getElementById('current-seed');
      const modeDisplay = document.getElementById('current-mode');
      const seedDisplayTop = document.getElementById('current-seed-display');
      const modeDisplayTop = document.getElementById('current-mode-display');
      
      if (seedDisplay) seedDisplay.textContent = seed;
      if (seedDisplayTop) seedDisplayTop.textContent = seed;

      try {
        const res = await fetch(`/web/data_seed_${seed}.json`);
        let data;
        if (!res.ok) {
           console.warn(`‚ö†Ô∏è Seed ${seed} not found (404). Generating emergency nodes.`);
           data = {
             nodes: [],
             modo: "EMERGENCY_RECOVERY",
             horror_total: 666,
             modo_info: { emoji: "üÜò", desc: "Suministro de emergencia activado" }
           };
            for(let i=0; i<50000; i++) {
              // Spherical Distribution for "Bien 360"
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const r = 500 + Math.random() * 1500;
              
              const x = r * Math.sin(phi) * Math.cos(theta);
              const y = r * Math.sin(phi) * Math.sin(theta);
              const z = r * Math.cos(phi);

              data.nodes.push({
                id: `E${i}`,
                position: [x, y, z],
                color: 0xff0033
              });
            }
        } else {
           data = await res.json();
        }
        currentUniverseData = data;

        // Limpiar escena
        if (pointsCloud) { scene.remove(pointsCloud); pointsCloud = null; }
        if (centralSingularity) { scene.remove(centralSingularity); centralSingularity = null; }

        // üåå GARGANTUA SINGULARITY v9.4.0
        centralSingularity = createGargantuaSingularity();
        scene.add(centralSingularity);

        // Nodos
        if (data.nodes) {
          const count = data.nodes.length;
          const pos = new Float32Array(count * 3);
          const colors = new Float32Array(count * 3);
          const originalColors = new Float32Array(count * 3);
          
          data.nodes.forEach((n,i) => {
            const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
            pos[i*3] = p[0]; pos[i*3+1] = p[1]; pos[i*3+2] = p[2];
            
            // Generate base color (from n.color or deterministic random)
            const c = new THREE.Color();
            if (n.color) {
               c.set(n.color);
            } else {
               const hue = ((Math.abs(seed) % 10) / 10 + (i/count)*0.1) % 1;
               c.setHSL(hue, 0.8, 0.5);
            }
            colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            originalColors[i*3] = c.r; originalColors[i*3+1] = c.g; originalColors[i*3+2] = c.b;
          });
          
          const g = new THREE.BufferGeometry();
          g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          g.userData.originalColors = originalColors; // Preserve for luminosity logic
          
          pointsCloud = new THREE.Points(g, new THREE.PointsMaterial({
              vertexColors: true, 
              size: 2, // Optimized for 50k nodes
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending
          }));
          scene.add(pointsCloud);
        }

        const modoText = data.modo || "DOLPHIN";
        if (modeDisplay) modeDisplay.textContent = modoText;
        if (modeDisplayTop) modeDisplayTop.textContent = modoText;
        
        // Update Titan Panel
        const titanMode = document.getElementById('titan-mode');
        const titanSeed = document.getElementById('titan-seed');
        const titanHorror = document.getElementById('titan-horror');
        if (titanMode) titanMode.textContent = modoText;
        if (titanSeed) titanSeed.textContent = seed;
        if (titanHorror && data.horror_total) {
          titanHorror.textContent = Math.round(data.horror_total).toLocaleString();
        }
      } catch (e) {
        console.error("Error:", e);
        if (modeDisplay) modeDisplay.textContent = "ERROR";
        if (modeDisplayTop) modeDisplayTop.textContent = "ERROR";
      }

      document.getElementById('loading-overlay').style.display = 'none';
    }

    function initEngine() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000);
      camera.position.set(0, 500, 1500);

      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
      renderer.setSize(innerWidth, innerHeight);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // WebGL Resilience
      renderer.domElement.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          console.warn('‚ö†Ô∏è WebGL Context Lost! Stabilizing...');
          showToast('‚ö†Ô∏è GPU OVERLOAD: RECOVERING...');
      }, false);

      renderer.domElement.addEventListener('webglcontextrestored', () => {
          console.log('‚úÖ WebGL Context Restored');
          loadUniverse(currentUniverseSeed);
      }, false);

      // 1. Post-processing setup
      const renderScene = new THREE.RenderPass(scene, camera);
      bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.5, 0.4, 0.85);
      bloomPass.threshold = 0.21;
      bloomPass.strength = 1.2;
      bloomPass.radius = 0.55;

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // 2. Lights (Essential for MeshStandardMaterial depth)
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x00ffff, 2, 500);
      pointLight.position.set(0, 0, 0); // Inside the Poneglyph
      scene.add(pointLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      scene.add(directionalLight);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // MOVED: Double click listener added here to ensure renderer exists
      // Viz Mode Change
      document.getElementById('vizMode')?.addEventListener('change', e => {
         const mode = e.target.value;
         if (mode === 'MANDALA') {
            createMandalaUniverse();
            // Ensure audio is on for Mandala reactivity, but don't force Matrix
            if (!isFiestaMode) {
              isFiestaMode = true;
              const fCheckbox = document.getElementById('fiestaMode');
              if (fCheckbox) fCheckbox.checked = true;
              initAudio();
            }
         } else if (mode === 'FUSION') {
            invokeFusion();
         } else if (mode === 'LASER') {
            createLaserUniverse();
         } else if (mode === 'BUBBLE') {
            createBubbleUniverse();
         } else if (mode === 'LANIAKEA') {
            createLaniakeaUniverse();
         } else if (mode === 'NEGATIVE_RGB') {
            createNegativeRGBUniverse();
         } else {
            loadUniverse(currentUniverseSeed); 
         }
      });
      
      // Initialize Sine Graph
      initSineGraph();
      
      // Ion Channels Toggle
      document.getElementById('ionChannelsToggle')?.addEventListener('change', e => {
         if(e.target.checked) createIonChannels();
         else removeIonChannels();
      });


      loadUniverse(currentUniverseSeed);
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (!scene || !camera) return;

      const time = Date.now() * 0.001;
      const speedMultiplier = timeSpeed;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

      const accel = new THREE.Vector3();
      if (moveState.forward) accel.addScaledVector(dir, acceleration * speedMultiplier);
      if (moveState.back) accel.addScaledVector(dir, -acceleration * speedMultiplier);
      if (moveState.left) accel.addScaledVector(side, acceleration * speedMultiplier);
      if (moveState.right) accel.addScaledVector(side, -acceleration * speedMultiplier);
      if (moveState.up) accel.y += acceleration * speedMultiplier;
      if (moveState.down) accel.y -= acceleration * speedMultiplier;

      velocity.add(accel);
      velocity.multiplyScalar(deceleration);
      if (velocity.length() > maxSpeed) velocity.setLength(maxSpeed);

      camera.position.add(velocity);
      controls.target.add(velocity);
      
      if (moveState.rotateLeft) camera.rotation.y += rotationSpeed * speedMultiplier;
      if (moveState.rotateRight) camera.rotation.y -= rotationSpeed * speedMultiplier;
      if (moveState.rotateUp) camera.rotation.x += rotationSpeed * speedMultiplier;
      if (moveState.rotateDown) camera.rotation.x -= rotationSpeed * speedMultiplier;
      
      if (!isImmersionMode && controls) controls.update();

      // 1. UPDATE AUDIO DATA ONCE PER FRAME
      if (isFiestaMode) {
        if (audioInitialized && analyser && dataArray) {
          analyser.getByteFrequencyData(dataArray);
        } else {
          simulateAudioData();
        }
      }

      // 2. ANIMATE CENTRAL SINGULARITY
      if (centralSingularity) {
        const ud = centralSingularity.userData;
        if (ud?.disk) ud.disk.rotation.y += 0.002 * speedMultiplier;

        if (ud?.poneglyph?.material) {
          const pg = ud.poneglyph;
          pg.rotation.y -= 0.005 * speedMultiplier;
          pg.rotation.x += 0.003 * speedMultiplier;
          pg.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
        }

        if (ud?.photonSphere?.material) {
          ud.photonSphere.material.opacity = Math.sin(Date.now() * 0.001) * 0.05 + 0.15;
        }
      }

      // 3. ANIMATE MATRIX LINES
      if (matrixLines?.material) {
        matrixLines.rotation.y += 0.001 * speedMultiplier;

        if (matrixModeActive) {
          if (isFiestaMode && dataArray && currentUniverseData) {
             const gravityFactor = Math.abs(currentUniverseData?.modo_info?.physics?.gravity || 1000) / 10000;
             const flowSpeed = 0.002 * (1 + gravityFactor); 
             const timeAt = Date.now();
             const bass = dataArray[4] || 0; 
             const normBass = bass / 255.0;
             const hue = (timeAt * flowSpeed + normBass * 0.1) % 1; 
             
             matrixLines.material.color?.setHSL(hue, 1.0, 0.3 + normBass * 0.7);
             matrixLines.material.opacity = (matrixOpacity || 0.3) + (normBass * 0.5);
             
             if (ionLines?.material?.color) {
                 ionLines.material.color.setHSL((hue + 0.5) % 1, 1.0, 0.5 + normBass*0.5);
                 ionLines.material.opacity = 0.4 + normBass * 0.4;
                 ionLines.rotation.y -= 0.02; 
             }
          } else {
             const timeAt = Date.now() * 0.0005;
             const hue = (timeAt % 1); 
             matrixLines.material.color?.setHSL(hue, 0.8, 0.5);
             matrixLines.material.opacity = matrixOpacity || 0.3;
          }
        }
      }

      // 4. ANIMATE ION LINES (CHANNELS)
      if (ionLines?.material) {
        ionLines.rotation.y -= 0.002 * speedMultiplier; 
        ionLines.rotation.x += 0.001 * speedMultiplier;
        
        if (isFiestaMode && dataArray) {
           const mid = dataArray[20] || 0;
           const normMid = mid / 255.0;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + (normMid * 0.5), 1.0, 0.6 + (normMid * 0.4));
           ionLines.material.opacity = 0.4 + (normMid * 0.6);
           const scale = 1.0 + (normMid * 0.5); 
           ionLines.scale.set(scale, scale, scale);
        } else {
           const timeAt = Date.now() * 0.002;
           const pulse = 0.3 + Math.sin(timeAt) * 0.2;
           ionLines.material.opacity = pulse;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + Math.sin(timeAt*0.5)*0.1, 1.0, 0.5);
           ionLines.scale.set(1,1,1);
        }
      }
      
      // 5. ANIMATE ORBITAL IONS
      if (orbitalIons && orbitalIons.material) {
          orbitalIons.rotation.y += 0.0015 * speedMultiplier * (isFiestaMode ? 4 : 1);
          orbitalIons.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
      }

      // 6. ANIMATE MANDALA / POINTS CLOUD
      const pc = pointsCloud;
      if (pc && pc.geometry && pc.geometry.attributes && pc.geometry.attributes.position) {
        if (pc.userData && pc.userData.isMandala) {
          pc.rotation.z += 0.001 * speedMultiplier;
          pc.rotation.y += 0.002 * speedMultiplier;

          if (isFiestaMode && dataArray) {
            if (frameCount % 2 === 0) {
              const positions = pc.geometry.attributes.position.array;
              const original = pc.geometry.userData.originalPositions;
              const layerIndices = pc.geometry.userData.layerIndices;
              const scales = pc.geometry.userData.scales;
              
                if (original && layerIndices && scales) {
                  const count = positions.length / 3;
                  const start = currentChunk * CHUNK_SIZE;
                  const end = Math.min(start + CHUNK_SIZE, count);

                  for(let i = start; i < end; i++) {
                    const layer = layerIndices[i];
                    const audioIdx = Math.floor((layer * 5) % dataArray.length);
                    const audioVal = dataArray[audioIdx] || 0;
                    const targetScale = 1.0 + (audioVal * 0.015);
                    scales[i] = scales[i] + (targetScale - scales[i]) * 0.3;

                    const idx3 = i*3;
                    positions[idx3]   = original[idx3] * scales[i];
                    positions[idx3+1] = original[idx3+1] * scales[i];
                    positions[idx3+2] = original[idx3+2] * scales[i];
                  }
                  pc.geometry.attributes.position.needsUpdate = true;
                }
            }
          }
        }
        
        // Gravitational Redshift Simulation (Universal)
        if (pc.geometry.userData.originalColors && frameCount % 2 === 0) {
            const colorAttr = pc.geometry.attributes.color;
            if (colorAttr) {
                const colors = colorAttr.array;
                const orig = pc.geometry.userData.originalColors;
                const positions = pc.geometry.attributes.position.array;
                const count = colorAttr.count;
                
                const start = currentChunk * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, count);

                for (let i = start; i < end; i++) {
                    const x = positions[i*3], y = positions[i*3+1], z = positions[i*3+2];
                    const d = Math.sqrt(x*x + y*y + z*z);
                    const grav = Math.max(0.0, 1.0 - (d / 3500));
                    const boost = 1.0 + Math.pow(grav, 3) * 25.0; 
                    colors[i*3]   = orig[i*3] * boost;
                    colors[i*3+1] = orig[i*3+1] * boost;
                    colors[i*3+2] = orig[i*3+2] * boost;
                }
                colorAttr.needsUpdate = true;
                
                // Advance chunk for next frame
                currentChunk = (currentChunk + 1) % Math.ceil(count / CHUNK_SIZE);
            }
        }
      }

      updateTitanPanel();
      if (composer) composer.render();
      else renderer.render(scene, camera);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé® THEME SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const themeSelect = document.getElementById('uxTheme');
    if (themeSelect) {
      themeSelect.addEventListener('change', (e) => {
        setTheme(e.target.value);
      });
    }

    function setTheme(theme) {
      console.log(`üé® Theme changed to: ${theme}`);
      
      const nodes = pointsCloud ? pointsCloud.geometry : null;
      
      switch(theme) {
        case 'PHOTON':
          // MODO FOT√ìN: Cyan electric, bright, high contrast
          document.documentElement.style.setProperty('--text-cyan', '#00ffff');
          document.body.style.background = '#000000';
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 6;
            pointsCloud.material.opacity = 0.9;
            pointsCloud.material.color = new THREE.Color(0x00ffff);
            pointsCloud.material.vertexColors = false; 
          }
          
          // Matrix lines bright
          if (matrixLines && matrixLines.material) {
            matrixLines.material.color = new THREE.Color(0xffffff);
            matrixLines.material.opacity = 0.5;
          }
          
          showToast('‚ö° MODO FOT√ìN ACTIVADO');
          break;
          
        case 'PARADOX':
          // MODO 666 PARADOX: Fire, Red/Orange/Yellow, Hellish
          document.documentElement.style.setProperty('--text-cyan', '#ff4500'); // OrangeRed
          document.body.style.background = '#1a0500'; // Dark red/brown
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 10;
            pointsCloud.material.opacity = 1.0;
            pointsCloud.material.vertexColors = true;
            
            // Recolor nodes to fire gradient
            const count = nodes.attributes.position.count;
            const colors = nodes.attributes.color.array;
            
            for (let i = 0; i < count; i++) {
              const r = Math.random() * 0.5 + 0.5; // 0.5-1.0 (Red)
              const g = Math.random() * 0.5;       // 0-0.5 (Green -> Orange/Yellow)
              const b = 0;                         // No blue
              
              colors[i * 3] = r;
              colors[i * 3 + 1] = g;
              colors[i * 3 + 2] = b;
            }
            nodes.attributes.color.needsUpdate = true;
          }
          
          // Singularity becomes a burning sun
          if (centralSingularity) {
            const children = centralSingularity.children;
            children.forEach(child => {
              if (child.isMesh && child.geometry.type === 'SphereGeometry' && child.material) {
                 // Core becomes bright yellow/white
                 if (child.geometry.parameters.radius === 30) {
                   child.material.color.setHex(0xffff00);
                 }
                 // Glow becomes orange
                 if (child.geometry.parameters.radius === 45) {
                   child.material.color.setHex(0xff4500);
                   child.material.opacity = 0.4;
                 }
              }
            });
          }
          
          showToast('üî• 666 PARADOX ACTIVADO');
          break;
          
        case 'COSMIC':
        default:
          // Reset to default
          document.documentElement.style.setProperty('--text-cyan', '#00f2ff');
          document.body.style.background = 'var(--bg-black)';
           
          // Restore functionality would require reloading mechanism or storing original state
          // For now, we just reset colors if possible or re-enable vertex colors
          if (pointsCloud && pointsCloud.material) {
             pointsCloud.material.vertexColors = true;
             pointsCloud.material.color = new THREE.Color(0xffffff);
             pointsCloud.material.size = 8;
          }
          if (centralSingularity && centralSingularity.children) {
             // Reset singularity colors
             if (centralSingularity.children[0] && centralSingularity.children[0].material) {
                centralSingularity.children[0].material.color.setHex(0x000000); // Core
             }
             if (centralSingularity.children[1] && centralSingularity.children[1].material) {
                centralSingularity.children[1].material.color.setHex(0xffffff); // Glow
             }
          }
          showToast('üåå MODO C√ìSMICO RESTAURADO');
          break;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß† NEURAL INTERFACE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let lastTime = performance.now();
    let fps = 60;
    frameCount = 0;
    let lastFpsUpdate = performance.now();

    function updateTitanPanel() {
      // FPS calculation
      frameCount++;
      const now = performance.now();
      if (now - lastFpsUpdate >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = now;
        
        const fpsEl = document.getElementById('titan-fps');
        if (fpsEl) {
          fpsEl.textContent = fps;
          fpsEl.className = 'titan-stat-value';
          if (fps < 30) fpsEl.classList.add('danger');
          else if (fps < 50) fpsEl.classList.add('warning');
        }
      }

      // Node count
      const nodesEl = document.getElementById('titan-nodes');
      if (nodesEl && pointsCloud) {
        const count = pointsCloud.geometry.attributes.position.count;
        nodesEl.textContent = count.toLocaleString();
      }

      // Memory usage
      const memEl = document.getElementById('titan-memory');
      if (memEl && performance.memory) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        memEl.textContent = mb + ' MB';
      }

      // Speed
      const speedEl = document.getElementById('titan-speed');
      if (speedEl) {
        if (isPaused) {
          speedEl.textContent = 'PAUSED';
          speedEl.className = 'titan-stat-value warning';
        } else {
          speedEl.textContent = 'x' + timeSpeed.toFixed(1);
          speedEl.className = 'titan-stat-value';
        }
      }
    }

    function enterCosmicOS() {
      gsap.to("#intro-overlay", {opacity:0, duration:1.2, onComplete:() => {
        document.getElementById('intro-overlay').style.display = 'none';
        initEngine();
      }});
    }

    function invokeCaos() {
      const randomSeed = availableSeeds[Math.floor(Math.random() * availableSeeds.length)];
      currentUniverseSeed = randomSeed;
      loadUniverse(randomSeed);
    }

    function invokeFusion() {
      const seedCount = parseInt(document.getElementById('seedSlider').value);
      const seeds = [];
      for (let i = 0; i < seedCount; i++) {
        seeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
      }
      console.log('FUSION MODE:', seeds);
      loadMultipleSeeds(seeds);
    }

    async function loadMultipleSeeds(seeds) {
      document.getElementById('loading-overlay').style.display = 'flex';
      
      if (pointsCloud) scene.remove(pointsCloud);
      
      const allNodes = [];
      const offsetDistance = 2000;
      
      for (let i = 0; i < seeds.length; i++) {
        try {
          const res = await fetch(`/web/data_seed_${seeds[i]}.json`);
          if (!res.ok) continue;
          const data = await res.json();
          
          if (data.nodes) {
            const angle = (i / seeds.length) * Math.PI * 2;
            const offsetX = Math.cos(angle) * offsetDistance;
            const offsetZ = Math.sin(angle) * offsetDistance;
            
            const hue = (i / seeds.length) * 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 0.8, 0.6);
            
            data.nodes.forEach(n => {
              const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
              allNodes.push({
                x: p[0] + offsetX,
                y: p[1],
                z: p[2] + offsetZ,
                r: color.r,
                g: color.g,
                b: color.b
              });
            });
          }
        } catch (e) {
          console.error(`Error loading seed ${seeds[i]}:`, e);
        }
      }
      
      const positions = new Float32Array(allNodes.length * 3);
      const colors = new Float32Array(allNodes.length * 3);
      
      allNodes.forEach((n, i) => {
        positions[i * 3] = n.x;
        positions[i * 3 + 1] = n.y;
        positions[i * 3 + 2] = n.z;
        colors[i * 3] = n.r;
        colors[i * 3 + 1] = n.g;
        colors[i * 3 + 2] = n.b;
      });
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 8,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        })
      );
      
      scene.add(pointsCloud);
      document.getElementById('loading-overlay').style.display = 'none';
      
      showToast(`${seeds.length} universos fusionados`);
    }

    // üå∏ MANDALA UNIVERSE (FRACTAL & AUDIO REACTIVE)
    function createMandalaUniverse() {
      if (pointsCloud) scene.remove(pointsCloud);
      if (centralSingularity) {
        scene.remove(centralSingularity);
        centralSingularity.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        centralSingularity = null;
      }

      const particleCount = 50000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const layerIndices = new Float32Array(particleCount);
      const scales = new Float32Array(particleCount); // New: para lerp smooth

      const layers = 12;
      let particleIdx = 0;

      for(let l = 0; l < layers; l++) {
        const layerCount = Math.floor(particleCount / layers);
        const radius = 200 + (l * 150);

        for(let i = 0; i < layerCount; i++) {
          if (particleIdx >= particleCount) break;

          const theta = i * 2.39996;
          const phi = Math.acos(1 - 2 * (i + 0.5) / layerCount);

          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);

          positions[particleIdx * 3] = x;
          positions[particleIdx * 3 + 1] = y;
          positions[particleIdx * 3 + 2] = z;

          const color = new THREE.Color().setHSL(l / layers, 1.0, 0.5);
          colors[particleIdx * 3] = color.r;
          colors[particleIdx * 3 + 1] = color.g;
          colors[particleIdx * 3 + 2] = color.b;

          layerIndices[particleIdx] = l;
          scales[particleIdx] = 1.0; // Init scale

          particleIdx++;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      geometry.userData.originalPositions = positions.slice();
      geometry.userData.layerIndices = layerIndices;
      geometry.userData.scales = scales;
      geometry.userData.originalColors = colors.slice(); // Fix for redshift simulation

      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 2, // Optimized for 50k nodes
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        })
      );

      pointsCloud.userData.isMandala = true;
      scene.add(pointsCloud);
      showToast('üå∏ UNIVERSO MANDALA ACTIVADO');
    }

    function resetCamera() {
      if (camera && controls) {
        camera.position.set(0, 500, 1500);
        controls.target.set(0, 0, 0);
        velocity.set(0, 0, 0);
        controls.update();
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - FULL MESH INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - SAFEGUARDED INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createMatrixLines() {
      if (!pointsCloud || !scene) return;
      
      removeMatrixLines(); 
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const nodeCount = positions.length / 3;
      
      const linePositions = [];
      const MAX_TOTAL_LINES = 300000; // Hard limit for WebGL buffer safety
      
      // Smart Logic: If too many nodes, use K-Nearest or Random Neighbors instead of Full Mesh
      if (nodeCount > 800) { 
        // Optimization for large datasets (O(N*K))
        console.warn('‚ö° High node count detected. Optimizing Matrix connections (Nearest Neighbors)...');
        
        for (let i = 0; i < nodeCount; i++) {
           // Connect to 5 random neighbors instead of everyone
           // (Approximation of "Matrix" look without O(N^2))
           for (let k = 0; k < 6; k++) {
              if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
              
              const j = Math.floor(Math.random() * nodeCount);
              if (i === j) continue;
              
              // Only connect if somewhat close (optional, but pure random is chaotic enough for noise)
              // To make it look structured, we could check distance, but that is expensive.
              // Fast alternative: Spatial hashing or just simple random for visual "noise".
              
              linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
           }
        }
      } else {
         // Full Mesh for small datasets
         for (let i = 0; i < nodeCount; i++) {
            for (let j = i + 1; j < nodeCount; j++) {
               if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
               linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
            }
         }
      }
      
      const lineGeometry = new THREE.BufferGeometry();
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(linePositions), 3));
      
      const lineMaterial = new THREE.LineBasicMaterial({
        color: matrixColor,
        opacity: matrixOpacity,
        transparent: true,
        linewidth: 1
      });
      
      matrixLines = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(matrixLines);
      
      console.log(`üü¢ MATRIX MODE SAFE: ${nodeCount} nodes, ${linePositions.length / 6} lines`);
    }

    // ... (removeMatrixLines, updateMatrixColor, etc. remain the same, ensure they are kept or I will break them if I overwrite)
    function removeMatrixLines() {
      if (matrixLines && scene) {
        scene.remove(matrixLines);
        if(matrixLines.geometry) matrixLines.geometry.dispose();
        if(matrixLines.material) matrixLines.material.dispose();
        matrixLines = null;
      }
    }
    
    function updateMatrixColor() { if (matrixLines && matrixLines.material) matrixLines.material.color.setHex(matrixColor); }
    function updateMatrixOpacity() { if (matrixLines && matrixLines.material) matrixLines.material.opacity = matrixOpacity; }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåå NEW UNIVERSES (Laser, Bubble, Laniakea)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. LASER UNIVERSE (Grid / Linear Energy)
    function createLaserUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
             // Grid distribution
             const range = 2000;
             if (i < particleCount * 0.8) {
                 // PLANES
                 positions[i*3] = (Math.random() - 0.5) * range;
                 positions[i*3+1] = (Math.floor(Math.random() * 10) - 5) * 200; // Quantized Y layers
                 positions[i*3+2] = (Math.random() - 0.5) * range;
             } else {
                 // BEAMS (Vertical)
                 positions[i*3] = (Math.floor(Math.random() * 20) - 10) * 200;
                 positions[i*3+1] = (Math.random() - 0.5) * range;
                 positions[i*3+2] = (Math.floor(Math.random() * 20) - 10) * 200;
             }
             
             // NEON COLORS (Red/Blue/Laser)
             const color = new THREE.Color();
             Math.random() > 0.5 ? color.setHex(0xff0055) : color.setHex(0x0055ff);
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, blending: THREE.AdditiveBlending }));
        scene.add(pointsCloud);
        showToast('‚ö° UNIVERSO LASER ACTIVADO');
    }

    // 2. BUBBLE UNIVERSE (Multiverse Foam)
    function createBubbleUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        const bubbleCenters = [];
        for(let j=0; j<50; j++) bubbleCenters.push({
            x: (Math.random()-0.5)*3000, 
            y: (Math.random()-0.5)*3000, 
            z: (Math.random()-0.5)*3000, 
            r: 100 + Math.random()*300
        });

        for (let i = 0; i < particleCount; i++) {
             const bubble = bubbleCenters[Math.floor(Math.random() * bubbleCenters.length)];
             
             // Surface of sphere
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos(2 * Math.random() - 1);
             
             const x = bubble.x + bubble.r * Math.sin(phi) * Math.cos(theta);
             const y = bubble.y + bubble.r * Math.sin(phi) * Math.sin(theta);
             const z = bubble.z + bubble.r * Math.cos(phi);
             
             positions[i*3] = x;
             positions[i*3+1] = y;
             positions[i*3+2] = z;
             
             const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6); // Rainbow bubbles
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent:true, opacity:0.6 }));
        scene.add(pointsCloud);
        showToast('üõÅ UNIVERSO BURBUJA ACTIVADO');
    }

    // 3. LANIAKEA UNIVERSE (Cosmic Web / Filaments)
    function createLaniakeaUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        // Laniakea has a Great Attractor! Keep Singularity but make it Golden
        if (!centralSingularity) {
            centralSingularity = createGargantuaSingularity();
            scene.add(centralSingularity);
        }
        
        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        // Simulating filaments using strange Attractors or Perlin noise curves
        // Simplified: Multiple sine waves paths
        
        for (let i = 0; i < particleCount; i++) {
            const t = Math.random() * 100; // path pos
            const filamentIdx = Math.floor(Math.random() * 20); // 20 main filaments
            
            // Parametric curves spiraling into center
            const angle = t * 0.1 + (filamentIdx * (Math.PI*2/20));
            const radius = t * 20 + 200; // expanding out
            const height = Math.sin(t * 0.5) * 500 * (Math.random()-0.5);
            
            // Add noise
            const spread = 50 + t;
            
            positions[i*3] = Math.cos(angle) * radius + (Math.random()-0.5)*spread;
            positions[i*3+1] = height + (Math.random()-0.5)*spread;
            positions[i*3+2] = Math.sin(angle) * radius + (Math.random()-0.5)*spread;
            
            // Golden / White colors
            const color = new THREE.Color().setHSL(0.1 + Math.random()*0.1, 0.8, 0.6); // Gold/Orange
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true }));
        scene.add(pointsCloud);
        showToast('üåå LANIAKEA SUPERCLUSTER DETECTADO');
    }

    // 4. NEGATIVE RGB LIGHT UNIVERSE (Operates -255 to 0)
    function createNegativeRGBUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        let idx = 0;
        
        // Explicit logic: "Desde lo negativo -255 hasta 0"
        // We will generate particles in batches mapping this negative range to position/color
        
        const range = 5000;
        
        for (let n = -255; n <= 0; n += 0.005) { // Updated for 50k nodes
            if(idx >= particleCount) break;
            
            // Negative Math for Position: (-255 to 0)
            // Map -255..0 to Space
            // Use random distribution but influenced by 'n'
            
            // Burst in all directions
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            // Radius depends on 'n' (inverted: -255 is CORE, 0 is EDGE)
            // n goes -255 -> 0. 
            // Normalized: (255 - abs(n)) / 255 => 0 to 1
            const rNorm = (255 - Math.abs(n)) / 255; 
            const r = rNorm * 2000; 

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            positions[idx*3] = x;
            positions[idx*3+1] = y;
            positions[idx*3+2] = z;
            
            // COLOR LOGIC: "RGB es facil 0 255 pero desde lo negativo -255 hasta 0"
            // Interpreted: Value = n + 255.
            // If n = -255, val = 0 (Black/Core).
            // If n = 0, val = 255 (Max Color).
            
            // R, G, B channels vary with different "negative frequencies"
            const rVal = 255 + (Math.random() > 0.5 ? n : -255); // Mix
            const gVal = 255 + (n); 
            const bVal = 255 + (Math.sin(n)*255 - 255)/2; // Oscillate
            
            const color = new THREE.Color(
                Math.max(0, rVal + Math.random()*50)/255, 
                Math.max(0, gVal + Math.random()*50)/255,
                Math.max(0, bVal + Math.random()*50)/255
            );
            
            colors[idx*3] = color.r;
            colors[idx*3+1] = color.g;
            colors[idx*3+2] = color.b;
            
            idx++;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        // Additive Blending for "Light"
        pointsCloud = new THREE.Points(
            geometry, 
            new THREE.PointsMaterial({ 
                size: 2, // Optimized for 50k nodes
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                transparent: true, 
                opacity: 0.8 
            })
        );
        scene.add(pointsCloud);
        showToast('üí° UNIVERSO LUZ RGB NEGATIVA ACTIVADO');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üìà SINE WAVE ANALYSIS (Real-Time Graph)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let sineCanvas, sineCtx;
    
    function initSineGraph() {
        sineCanvas = document.createElement('canvas');
        sineCanvas.id = 'sine-graph';
        sineCanvas.width = 400;
        sineCanvas.height = 100;
        sineCanvas.style.cssText = `
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid var(--text-cyan);
            border-radius: 8px;
            z-index: 50;
            pointer-events: none;
        `;
        document.body.appendChild(sineCanvas);
        sineCtx = sineCanvas.getContext('2d');
        
        // Add Label
        const label = document.createElement('div');
        label.innerText = 'REAL-TIME DATA SINE ANALYSIS';
        label.style.cssText = `
            position: fixed;
            bottom: 185px;
            left: 20px;
            color: var(--text-cyan);
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 51;
        `;
        document.body.appendChild(label);
        
        updateSineGraph();
    }
    
    function updateSineGraph() {
        requestAnimationFrame(updateSineGraph);
        if(!sineCtx || !sineCanvas) return;
        
        sineCtx.fillStyle = 'rgba(0,0,0,0.2)'; // Fade effect
        sineCtx.fillRect(0,0, sineCanvas.width, sineCanvas.height);
        
        const t = Date.now() * 0.002;
        
        // Data sources: Audio, Time, Position, Entropy (Random)
        // We mix "Greatest Amount of Data" -> 3-4 Waves overlay
        
        // 1. Audio / Energy Wave (Red/Magenta)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ff00ff';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
            const y = 50 + Math.sin(x*0.05 + t*2) * 20 * (isFiestaMode ? 1.5 : 0.5);
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 2. Cosmic Entropy (Cyan - High Fast)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#00ffff';
        sineCtx.lineWidth = 1;
        for(let x=0; x<sineCanvas.width; x++) {
            // Complex Harmonics
            const y = 50 + Math.sin(x*0.1 - t*3) * 15 + Math.cos(x*0.3 + t) * 5;
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 3. Gravity/Mass (Yellow - Slow Heavy)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ffff00';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
             const y = 50 + Math.sin(x*0.02 + t*0.5) * 30;
             if(x===0) sineCtx.moveTo(x,y); else sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
    }

    // Call initSineGraph in initEngine logic (later)

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öõÔ∏è ION CHANNELS (CONCENTRIC CONNECTIONS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createIonChannels() {
      if (!pointsCloud || !scene) return;
      removeIonChannels();

      const positions = pointsCloud.geometry.attributes.position.array;
      const count = positions.length / 3;
      
      // 1. DENSE ION LINES (The "Highways")
      const connections = [];
      const shells = {}; 
      
      for(let i=0; i<count; i++) {
         const x = positions[i*3];
         const y = positions[i*3+1];
         const z = positions[i*3+2];
         const dist = Math.sqrt(x*x + y*y + z*z);
         const shellIdx = Math.floor(dist / 150); // Smaller shells = More layers
         
         if(!shells[shellIdx]) shells[shellIdx] = [];
         shells[shellIdx].push(i);
      }
      
      // Connect nodes within shells
      const shellKeys = Object.keys(shells);
      for(let k = 0; k < shellKeys.length; k++) {
        const shellKey = shellKeys[k];
        const indices = shells[shellKey];
        // COMPLEXITY CAP: Limit connections per shell to avoid O(n^2) web
        const limit = Math.min(indices.length, 300); 
        
        for(let i=0; i<limit; i++) {
           const idxA = indices[i];
           const idxB = indices[(i+1) % limit];
           const idxC = indices[(i+2) % limit];
           
           const ax = positions[idxA*3], ay = positions[idxA*3+1], az = positions[idxA*3+2];
           const bx = positions[idxB*3], by = positions[idxB*3+1], bz = positions[idxB*3+2];
           const cx = positions[idxC*3], cy = positions[idxC*3+1], cz = positions[idxC*3+2];
           
           connections.push(ax, ay, az, bx, by, bz);
           connections.push(ax, ay, az, cx, cy, cz);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(connections), 3));
      
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      
      ionLines = new THREE.LineSegments(geometry, material);
      ionLines.userData.isIon = true;
      scene.add(ionLines);


      // 2. ORBITAL ION FLOW (The "Traffic")
      // Particles that will rotate physically to simulate flow along the shells
      const ionCount = 15000;
      const ionPos = new Float32Array(ionCount * 3);
      const ionSizes = new Float32Array(ionCount);
      
      for(let i=0; i<ionCount; i++) {
          // Spawn on existing shells
          const shellKeys = Object.keys(shells);
          const rKey = shellKeys[Math.floor(Math.random() * shellKeys.length)];
          const nodesInShell = shells[rKey];
          if(!nodesInShell) continue;
          
          // Pick a random node as base
          const nodeIdx = nodesInShell[Math.floor(Math.random() * nodesInShell.length)];
          const px = positions[nodeIdx*3];
          const py = positions[nodeIdx*3+1];
          const pz = positions[nodeIdx*3+2];
          
          // Add random spread to create a "Cloud" around the shell highway
          ionPos[i*3] = px + (Math.random()-0.5)*50;
          ionPos[i*3+1] = py + (Math.random()-0.5)*10; // Flat spread
          ionPos[i*3+2] = pz + (Math.random()-0.5)*50;
          
          ionSizes[i] = Math.random() * 3;
      }
      
      const ionGeo = new THREE.BufferGeometry();
      ionGeo.setAttribute('position', new THREE.BufferAttribute(ionPos, 3));
      ionGeo.setAttribute('size', new THREE.BufferAttribute(ionSizes, 1)); // Custom attribute if shader supported, else ignored or mapped
      
      const ionMat = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 2,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
      });
      
      orbitalIons = new THREE.Points(ionGeo, ionMat);
      scene.add(orbitalIons);

      console.log(`‚öõÔ∏è ORBITAL SYSTEM CREATED: ${connections.length/6} lines + ${ionCount} flowing ions`);
    }

    function removeIonChannels() {
      if (ionLines && scene) {
        scene.remove(ionLines);
        ionLines.geometry?.dispose();
        ionLines.material?.dispose();
        ionLines = null;
      }
      if (orbitalIons && scene) {
        scene.remove(orbitalIons);
        orbitalIons.geometry?.dispose();
        orbitalIons.material?.dispose();
        orbitalIons = null;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚è±Ô∏è TEMPORAL SPEED CONTROL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function setSpeed(speed) {
      timeSpeed = speed;
      isPaused = (speed === 0);
      
      // Update displays
      const display = document.getElementById('speed-display');
      const sliderDisplay = document.getElementById('speedSliderDisplay');
      const slider = document.getElementById('speedSlider');
      
      if (display) {
        if (isPaused) {
          display.textContent = '‚è∏ PAUSED';
          display.style.color = 'var(--text-red)';
        } else if (speed < 0) {
          display.textContent = `‚óÄ ${speed}x`;
          display.style.color = 'var(--text-magenta)';
        } else {
          display.textContent = `‚ñ∂ ${speed}x`;
          display.style.color = 'var(--text-cyan)';
        }
      }
      
      if (sliderDisplay) sliderDisplay.textContent = speed.toFixed(1);
      if (slider) slider.value = speed;
      
      // Highlight active button
      document.querySelectorAll('.temporal-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      console.log(`‚è±Ô∏è Velocidad: ${isPaused ? 'PAUSED' : speed + 'x'}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß≠ QUICK NAVIGATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function goToSingularity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 200,
        y: 100,
        z: 200,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üåå Llegaste a la Singularidad');
        }
      });
    }

    function escapeGravity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 5000,
        y: 3000,
        z: 5000,
        duration: 3,
        ease: 'power2.out',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üöÄ Escapaste de la gravedad');
        }
      });
    }

    function goToNearestNode() {
      if (!pointsCloud || !camera) return;
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const camPos = camera.position;
      
      let nearestDist = Infinity;
      let nearestPos = null;
      
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];
        
        const dist = Math.sqrt(
          Math.pow(x - camPos.x, 2) +
          Math.pow(y - camPos.y, 2) +
          Math.pow(z - camPos.z, 2)
        );
        
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestPos = { x, y, z };
        }
      }
      
      if (nearestPos) {
        const direction = new THREE.Vector3(
          camPos.x - nearestPos.x,
          camPos.y - nearestPos.y,
          camPos.z - nearestPos.z
        ).normalize();
        
        const targetPos = {
          x: nearestPos.x + direction.x * 100,
          y: nearestPos.y + direction.y * 100,
          z: nearestPos.z + direction.z * 100
        };
        
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 1.5,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(nearestPos.x, nearestPos.y, nearestPos.z);
            controls.update();
          },
          onComplete: () => {
            showToast('üéØ Nodo m√°s cercano alcanzado');
          }
        });
      }
    }

    function goToRandomPosition() {
      if (!camera) return;
      
      const randomPos = {
        x: (Math.random() - 0.5) * 4000,
        y: (Math.random() - 0.5) * 2000,
        z: (Math.random() - 0.5) * 4000
      };
      
      gsap.to(camera.position, {
        x: randomPos.x,
        y: randomPos.y,
        z: randomPos.z,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üé≤ Posici√≥n aleatoria');
        }
      });
    }

    function toggleImmersionMode() {
      isImmersionMode = !isImmersionMode;
      document.body.style.cursor = isImmersionMode ? 'none' : 'default';
      
      const hud = document.querySelector('.hud-module');
      const toggle = document.querySelector('.immersion-toggle');
      const temporalControls = document.getElementById('temporal-controls');
      
      if (hud) hud.style.display = isImmersionMode ? 'none' : 'block';
      
      // Toggle siempre visible, solo cambia opacidad
      if (toggle) {
        toggle.style.opacity = isImmersionMode ? '0.5' : '1';
        toggle.textContent = isImmersionMode ? 'Exit Immersion [H]' : 'Immersion [H]';
      }
      
      // CRITICAL: Disable OrbitControls in immersive mode
      if (controls) {
        controls.enabled = !isImmersionMode;
      }
      
      // Temporal controls SOLO en modo inmersivo
      if (temporalControls) {
        temporalControls.style.display = isImmersionMode ? 'block' : 'none';
      }
      
      // üåå ZOOM OUT AL ENTRAR EN MODO INMERSIVO
      if (isImmersionMode && camera) {
        // Guardar posici√≥n actual
        const currentPos = camera.position.clone();
        
        // Calcular punto m√°s lejano visible (vista panor√°mica)
        const farDistance = 3000; // Distancia lejana
        const direction = new THREE.Vector3(1, 1, 1).normalize(); // Diagonal
        const farPos = direction.multiplyScalar(farDistance);
        
        // Animar c√°mara hacia posici√≥n lejana
        gsap.to(camera.position, {
          x: farPos.x,
          y: farPos.y,
          z: farPos.z,
          duration: 2,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(0, 0, 0); // Mirar al centro
            controls.update();
          },
          onComplete: () => {
            console.log('üåå Vista panor√°mica activada - Listo para explorar');
          }
        });
      }
      
      console.log(isImmersionMode ? 'üåå IMMERSION ON - Temporal controls habilitados' : 'üåå IMMERSION OFF');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üñ±Ô∏è INTERACTION & RAYCASTING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Expand/Fly to Node
    function onDocumentMouseClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        if (!camera || !mouse) return;
        raycaster.setFromCamera(mouse, camera);
        
        // 1. Check Singularity
        if (centralSingularity) {
            const intersectsSingularity = raycaster.intersectObjects(centralSingularity.children);
            if (intersectsSingularity.length > 0) {
                goToSingularity();
                return;
            }
        }
        
        // 2. Check Nodes
        if (pointsCloud) {
            // Threshold for points (hitbox)
            raycaster.params.Points.threshold = 15; 
            const intersects = raycaster.intersectObject(pointsCloud);
            
            if (intersects.length > 0) {
                const index = intersects[0].index;
                const pos = pointsCloud.geometry.attributes.position;
                
                const targetPos = {
                    x: pos.getX(index),
                    y: pos.getY(index),
                    z: pos.getZ(index)
                };
                
                // "THE FORMULA TO EXPAND" interaction
                // 1. Fly to it
                flyToPosition(targetPos);
                
                // 2. Expand/Highlight (Pulse effect)
                highlightNode(index);
                
                showToast(`üî≠ Nodo #${index} Analizado`);
            }
        }
    }
    
    function flyToPosition(target) {
        if (!camera) return;
        
        // Offset to stop before hitting it
        const offset = 100;
        // Direction from current cam to target
        const direction = new THREE.Vector3(target.x - camera.position.x, target.y - camera.position.y, target.z - camera.position.z).normalize();
        
        const finalPos = {
            x: target.x - direction.x * offset,
            y: target.y - direction.y * offset,
            z: target.z - direction.z * offset
        };

        gsap.to(camera.position, {
            x: finalPos.x,
            y: finalPos.y,
            z: finalPos.z,
            duration: 1.5,
            ease: "power2.inOut",
            onUpdate: () => {
                controls.target.set(target.x, target.y, target.z);
                controls.update();
            }
        });
    }
    
    function highlightNode(index) {
        if (!pointsCloud || !pointsCloud.geometry || !pointsCloud.geometry.attributes.position) return;
        
        const pos = pointsCloud.geometry.attributes.position;
        const x = pos.getX(index);
        const y = pos.getY(index);
        const z = pos.getZ(index);
        
        const glowGeo = new THREE.SphereGeometry(2, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        glowMesh.position.set(x, y, z);
        scene.add(glowMesh);
        
        // Animate Expansion "Explosion"
        gsap.to(glowMesh.scale, { x: 20, y: 20, z: 20, duration: 0.5, ease: "back.out(1.7)" });
        gsap.to(glowMesh.material, { opacity: 0, duration: 0.5, onComplete: () => scene.remove(glowMesh) });
    }

    window.addEventListener('click', onDocumentMouseClick, false);

    // Event listeners (se ejecutan despu√©s de cargar DOM)
    document.addEventListener('DOMContentLoaded', () => {
      // Sliders
      // Sliders with Debounce
      let pendingSliderUpdate = false;
      document.getElementById('nodeSlider')?.addEventListener('input', e => {
        const val = e.target.value;
        const display = document.getElementById('nodeDisplay');
        if (display) display.textContent = val;
        
        if (!pendingSliderUpdate) {
            pendingSliderUpdate = true;
            requestAnimationFrame(() => {
                // Future-proof: add logic here if sliders trigger re-renders
                pendingSliderUpdate = false;
            });
        }
      });
      document.getElementById('seedSlider')?.addEventListener('input', e => {
        if (document.getElementById('seedDisplay')) document.getElementById('seedDisplay').textContent = e.target.value;
      });

      // Matrix Mode Toggle
      document.getElementById('matrixMode')?.addEventListener('change', e => {
        matrixModeActive = e.target.checked;
        const controls = document.getElementById('matrixControls');
        if (controls) controls.style.display = matrixModeActive ? 'block' : 'none';
        
        if (matrixModeActive) {
          createMatrixLines();
        } else {
          removeMatrixLines();
        }
      });

      // Matrix Color Preset
      document.getElementById('matrixColorPreset')?.addEventListener('change', e => {
        const customGroup = document.getElementById('customColorGroup');
        if (e.target.value === 'custom') {
          customGroup.style.display = 'block';
          const picker = document.getElementById('matrixColorPicker');
          matrixColor = parseInt(picker.value.replace('#', '0x'));
        } else {
          customGroup.style.display = 'none';
          matrixColor = parseInt(e.target.value.replace('#', '0x'));
        }
        updateMatrixColor();
      });

      // Fiesta Mode Toggle
      document.getElementById('fiestaMode')?.addEventListener('change', e => {
        isFiestaMode = e.target.checked;
        if (isFiestaMode) {
          initAudio();
          // Solo auto-clic Matrix si estamos en el modo Orbitador por defecto
          const currentViz = document.getElementById('vizMode')?.value;
          if (currentViz === 'ORBITAL' && !matrixModeActive) {
            document.getElementById('matrixMode').click();
          }
        }
      });

      // Matrix Custom Color Picker
      document.getElementById('matrixColorPicker')?.addEventListener('input', e => {
        matrixColor = parseInt(e.target.value.replace('#', '0x'));
        updateMatrixColor();
      });

      // Matrix Opacity
      document.getElementById('matrixOpacity')?.addEventListener('input', e => {
        matrixOpacity = parseFloat(e.target.value);
        document.getElementById('matrixOpacityDisplay').textContent = matrixOpacity;
        updateMatrixOpacity();
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚è±Ô∏è TEMPORAL CONTROLS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      document.getElementById('speedSlider')?.addEventListener('input', e => {
        const speed = parseFloat(e.target.value);
        setSpeed(speed);
      });

      // Teclado con controles configurables
      document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional (WASD)
        if (k === keyBindings.forward) moveState.forward = 1;
        if (k === keyBindings.back) moveState.back = 1;
        if (k === keyBindings.left) moveState.left = 1;
        if (k === keyBindings.right) moveState.right = 1;
        if (k === keyBindings.up) moveState.up = 1;
        if (k === keyBindings.down) moveState.down = 1;
        
        // Rotaci√≥n de c√°mara (Flechas)
        if (k === 'arrowleft') moveState.rotateLeft = 1;
        if (k === 'arrowright') moveState.rotateRight = 1;
        if (k === 'arrowup') moveState.rotateUp = 1;
        if (k === 'arrowdown') moveState.rotateDown = 1;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 2.0;
          acceleration = 9.0;
          maxSpeed = 90;
        }
        
        // Acciones
        if (k === keyBindings.immersion || k === 'l') toggleImmersionMode();
        if (k === keyBindings.resetCamera) resetCamera();
        if (k === '?' || k === '/') openTutorial();
      });

      document.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional
        if (k === keyBindings.forward) moveState.forward = 0;
        if (k === keyBindings.back) moveState.back = 0;
        if (k === keyBindings.left) moveState.left = 0;
        if (k === keyBindings.right) moveState.right = 0;
        if (k === keyBindings.up) moveState.up = 0;
        if (k === keyBindings.down) moveState.down = 0;
        
        // Rotaci√≥n de c√°mara
        if (k === 'arrowleft') moveState.rotateLeft = 0;
        if (k === 'arrowright') moveState.rotateRight = 0;
        if (k === 'arrowup') moveState.rotateUp = 0;
        if (k === 'arrowdown') moveState.rotateDown = 0;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 1.0;
          acceleration = 4.5;
          maxSpeed = 45;
        }
      });

      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéÆ GAMEPAD / JOYSTICK SUPPORT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      let gamepadConnected = false;
      let gamepadIndex = null;

      window.addEventListener('gamepadconnected', (e) => {
        gamepadConnected = true;
        gamepadIndex = e.gamepad.index;
        console.log(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
        showToast(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
      });

      window.addEventListener('gamepaddisconnected', (e) => {
        gamepadConnected = false;
        gamepadIndex = null;
        console.log('üéÆ Gamepad desconectado');
      });

      function updateGamepad() {
        if (!gamepadConnected || gamepadIndex === null) return;

        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad) return;

        // Stick izquierdo: Movimiento horizontal/vertical
        const leftX = gamepad.axes[0]; // -1 (izq) a +1 (der)
        const leftY = gamepad.axes[1]; // -1 (arriba) a +1 (abajo)

        // Stick derecho: Rotaci√≥n c√°mara
        const rightX = gamepad.axes[2];
        const rightY = gamepad.axes[3];

        // Deadzone para evitar drift
        const deadzone = 0.15;

        // Movimiento con stick izquierdo
        if (Math.abs(leftX) > deadzone) {
          moveState.left = leftX < 0 ? -leftX : 0;
          moveState.right = leftX > 0 ? leftX : 0;
        } else {
          moveState.left = 0;
          moveState.right = 0;
        }

        if (Math.abs(leftY) > deadzone) {
          moveState.forward = leftY < 0 ? -leftY : 0;
          moveState.back = leftY > 0 ? leftY : 0;
        } else {
          moveState.forward = 0;
          moveState.back = 0;
        }

        // Gatillos: Subir/Bajar
        const lt = gamepad.buttons[6]?.value || 0; // L2/LT
        const rt = gamepad.buttons[7]?.value || 0; // R2/RT
        moveState.down = lt;
        moveState.up = rt;

        // Botones de acci√≥n
        if (gamepad.buttons[0]?.pressed) { // A/X - Reset camera
          resetCamera();
        }
        if (gamepad.buttons[1]?.pressed) { // B/Circle - Toggle immersion
          toggleImmersionMode();
        }
        if (gamepad.buttons[2]?.pressed) { // X/Square - CAOS
          invokeCaos();
        }
        if (gamepad.buttons[3]?.pressed) { // Y/Triangle - Matrix toggle
          const matrixCheckbox = document.getElementById('matrixMode');
          if (matrixCheckbox) matrixCheckbox.click();
        }
      }

      // Llamar updateGamepad en cada frame
      function gamepadLoop() {
        updateGamepad();
        requestAnimationFrame(gamepadLoop);
      }
      gamepadLoop();

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚öôÔ∏è SETTINGS PANEL FUNCTIONS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      function openSettings() {
        document.getElementById('settings-panel').style.display = 'flex';
        updateKeyBindingsUI();
      }

      function closeSettings() {
        document.getElementById('settings-panel').style.display = 'none';
        saveKeyBindings();
      }

      function openTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'flex';
      }

      function closeTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'none';
      }

      function updateKeyBindingsUI() {
        const container = document.getElementById('key-bindings-list');
        const labels = {
          forward: 'Adelante',
          back: 'Atr√°s',
          left: 'Izquierda',
          right: 'Derecha',
          up: 'Subir',
          down: 'Bajar',
          rotateLeft: 'Rotar Izq',
          rotateRight: 'Rotar Der',
          speedBoost: 'Speed Boost',
          immersion: 'Immersion',
          resetCamera: 'Reset C√°mara'
        };

        container.innerHTML = '';
        for (const [action, key] of Object.entries(keyBindings)) {
          const div = document.createElement('div');
          div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(0,242,255,0.05);border:1px solid var(--glass-border);border-radius:4px;';
          div.innerHTML = `
            <span style="color:#888;">${labels[action] || action}</span>
            <button onclick="rebindKey('${action}')" style="width:auto;padding:5px 15px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);text-transform:uppercase;">
              ${keyBindings[action] === ' ' ? 'SPACE' : keyBindings[action].toUpperCase()}
            </button>
          `;
          container.appendChild(div);
        }
      }

      let rebindingAction = null;

      function rebindKey(action) {
        rebindingAction = action;
        showToast('‚å®Ô∏è Presiona la nueva tecla para ' + action, 5000);
        
        const listener = (e) => {
          e.preventDefault();
          const newKey = e.key.toLowerCase();
          keyBindings[action] = newKey;
          updateKeyBindingsUI();
          rebindingAction = null;
          document.removeEventListener('keydown', listener);
          showToast(`‚úÖ ${action} ‚Üí ${newKey === ' ' ? 'SPACE' : newKey.toUpperCase()}`);
        };
        
        document.addEventListener('keydown', listener);
      }

      // Toast notification helper
      function showToast(message, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.cssText = `
          position:fixed; top:80px; right:20px; z-index:10000;
          background:rgba(0,242,255,0.2); border:1px solid var(--text-cyan);
          padding:15px 20px; border-radius:8px; color:var(--text-cyan);
          font-size:0.9rem; pointer-events:none;
          animation: slideIn 0.3s ease-out;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      window.addEventListener('resize', () => {
        if (camera) {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(innerWidth, innerHeight);
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üöÄ DOUBLE CLICK TO TRAVEL (Teleport to node/black hole)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Init logic when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
       if (typeof updateKeyBindingsUI === 'function') updateKeyBindingsUI();
       initQuickNavDrag();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öîÔ∏è RPG ACTION BAR LOGIC & UI INJECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. Inject CSS
    const actionBarStyle = document.createElement('style');
    actionBarStyle.textContent = `
      #action-bar {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 10001;
        background: rgba(0, 0, 0, 0.6);
        padding: 5px;
        border: 1px solid var(--glass-border);
        border-radius: 6px;
        backdrop-filter: blur(10px);
      }
      .action-slot {
        width: 50px;
        height: 50px;
        position: relative;
        background: rgba(0, 20, 20, 0.8);
        border: 1px solid #444;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .action-slot:hover {
        border-color: var(--text-cyan);
        box-shadow: 0 0 10px rgba(0,242,255,0.3);
      }
      .action-slot.active {
        background: rgba(0, 242, 255, 0.2);
        border-color: var(--text-magenta);
      }
      .action-key {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 0.7rem;
        color: var(--text-yellow);
        font-weight: bold;
      }
      .action-icon {
        font-size: 1.5rem;
      }
    `;
    document.head.appendChild(actionBarStyle);

    // 2. Inject HTML
    // Wait for body to be ready if not already (safeguard)
    if (document.body) {
        injectActionBar();
    } else {
        document.addEventListener('DOMContentLoaded', injectActionBar);
    }

    function injectActionBar() {
        if(document.getElementById('action-bar')) return;
        const bar = document.createElement('div');
        bar.id = 'action-bar';
        bar.innerHTML = `
          <div class="action-slot" onclick="triggerAction('Q')" title="Toggle Matrix">
            <span class="action-key">Q</span>
            <span class="action-icon">üü¢</span>
          </div>
          <div class="action-slot" onclick="triggerAction('W')" title="Toggle Ion Channels">
            <span class="action-key">W</span>
            <span class="action-icon">‚öõÔ∏è</span>
          </div>
          <div class="action-slot" onclick="triggerAction('E')" title="Warp / Fly">
            <span class="action-key">E</span>
            <span class="action-icon">üöÄ</span>
          </div>
          <div class="action-slot" onclick="triggerAction('R')" title="Reset Camera">
            <span class="action-key">R</span>
            <span class="action-icon">üé•</span>
          </div>
          <div class="action-slot" onclick="triggerAction('F')" title="FIESTA MODE (Rainbow)">
            <span class="action-key">F</span>
            <span class="action-icon">üåà</span>
          </div>
        `;
        document.body.appendChild(bar);
    }
    
    // 3. Logic
    const rpgKeyBindings = {
      forward: 'arrowup',
      back: 'arrowdown',
      left: 'arrowleft',
      right: 'arrowright', 
      skill_q: 'q',
      skill_w: 'w',
      skill_e: 'e',
      skill_r: 'r',
      skill_f: 'f',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'x'
    };
    
    // Merge RPG bindings into active bindings
    Object.assign(keyBindings, rpgKeyBindings);

    function triggerAction(key) {
       const slot = Array.from(document.querySelectorAll('.action-key')).find(el => el.textContent === key)?.parentElement;
       if(slot) {
           slot.classList.add('active');
           setTimeout(() => slot.classList.remove('active'), 200);
       }
       
       switch(key) {
           case 'Q': 
               const mat = document.getElementById('matrixMode');
               if(mat) mat.click(); 
               showToast('Q: Matrix Toggle');
               break;
           case 'W':
               const ion = document.getElementById('ionChannelsToggle');
               if(ion) ion.click();
               showToast('W: Ion Channels Toggle');
               break;
           case 'E':
               if(centralSingularity) {
                  controls.target.copy(centralSingularity.position);
                  camera.position.set(0, 200, 500); 
                  showToast('E: Warp Core');
               }
               break;
           case 'R':
               resetCamera();
               showToast('R: Camera Reset');
               break;
           case 'F':
               const fiesta = document.getElementById('fiestaMode');
               if(fiesta) {
                   fiesta.click(); // This toggles checked state and fires change event
                   showToast('F: üî• FIESTA MODE TOGGLE üî•');
               }
               break;
       }
    }

    // Init Quick Nav Drag (Preserved)
    function initQuickNavDrag() {
       // ... (rest of function as before)
       const panel = document.getElementById('quick-nav-panel');
       const handle = document.getElementById('quick-nav-handle');
       if (!panel || !handle) return;
       // ... 
       // Only partial replace to keep code short? 
       // No, I must include the full function if I replace the block.
       // I'll assume the original 'initQuickNavDrag' is the target to keep or I put it before closing script.
       
       let isDragging = false;
       let startX, startY, initialLeft, initialTop;

       handle.addEventListener('mousedown', (e) => {
         e.preventDefault();
         isDragging = true;
         startX = e.clientX;
         startY = e.clientY;
         const rect = panel.getBoundingClientRect();
         initialLeft = rect.left;
         initialTop = rect.top;
         panel.style.transform = 'none';
         panel.style.bottom = 'auto';
         panel.style.left = initialLeft + 'px';
         panel.style.top = initialTop + 'px';
         handle.style.cursor = 'grabbing';
       });

       document.addEventListener('mousemove', (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const dx = e.clientX - startX;
         const dy = e.clientY - startY;
         panel.style.left = (initialLeft + dx) + 'px';
         panel.style.top = (initialTop + dy) + 'px';
       });
       
       document.addEventListener('mouseup', () => {
         if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
         }
       });
    }

    // KEY LISTENER UPDATE for Skills
    document.addEventListener('keydown', e => {
         // ... (existing listeners might conflict if I don't remove them or merge)
         // Since I am replacing the block at end of generic script, I might be outside the main listener scope.
         // Wait, the original code had the listener inside the main script block.
         // I am INJECTING this at the end of the file/script?
         // The `view_file` showed 'initQuickNavDrag' near the end.
         // I will simply add a NEW listener for the Skills to avoid messing with the complex existing one for now,
         // OR I should have modified the `defaultKeyBindings` definition at the top.
         // But I am rewriting `initQuickNavDrag` as anchor.
         
         const k = e.key.toLowerCase();
         if(k === 'q' && !e.repeat) triggerAction('Q');
         if(k === 'w' && !e.repeat) triggerAction('W');
         if(k === 'e' && !e.repeat) triggerAction('E');
         if(k === 'r' && !e.repeat) triggerAction('R');
         if(k === 'f' && !e.repeat) triggerAction('F');
    });
    
  </script>
</head>
<body>

  <div id="intro-overlay" onclick="enterCosmicOS()">
    <div style="text-align:center">
      <h1 style="color:var(--text-cyan);font-size:4rem;margin:0">COSMIC 11D</h1>
      <p style="color:var(--text-magenta);letter-spacing:6px">BAYESIAN NEGATIVE COMPLEXITY</p>
      <div style="margin-top:30px;color:#555">[ CLICK TO ENTER ]</div>
    </div>
  </div>

  <div id="loading-overlay">SYNCHRONIZING IONIC CHANNELS...</div>

  <div id="canvas-container"></div>

  <!-- Titan Panel - Stats Bar -->
  <div id="titan-panel">
    <div class="titan-stat">
      <span class="titan-stat-label">FPS</span>
      <span id="titan-fps" class="titan-stat-value">60</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Nodes</span>
      <span id="titan-nodes" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Horror</span>
      <span id="titan-horror" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Memory</span>
      <span id="titan-memory" class="titan-stat-value">0 MB</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Speed</span>
      <span id="titan-speed" class="titan-stat-value">x1.0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Mode</span>
      <span id="titan-mode" class="titan-stat-value">LOADING</span>
    </div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Seed</span>
      <span id="titan-seed" class="titan-stat-value">-10</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Dimensions</span>
      <span id="titan-dims" class="titan-stat-value">11D</span>
    </div>
  </div>

  <!-- Seed/Mode Display - Siempre visible -->
  <div style="position:fixed;top:50px;left:20px;z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:10px 15px;pointer-events:none;">
    <div style="font-size:0.7rem;color:#666;margin-bottom:3px;">CURRENT UNIVERSE</div>
    <div style="font-size:1rem;font-weight:bold;">
      <span style="color:var(--text-cyan);">Seed:</span> <span id="current-seed-display" style="color:var(--text-yellow);">-10</span>
    </div>
    <div style="font-size:0.9rem;margin-top:3px;">
      <span style="color:var(--text-magenta);">Mode:</span> <span id="current-mode-display" style="color:var(--text-green);">LOADING...</span>
    </div>
  </div>

  <div id="config-module" class="hud-module">
    <div class="hud-title">üß† NEURAL CONFIG (11D BIAS)</div>
    <div class="input-group">
      <label>Nodos: <span id="nodeDisplay">50000</span></label>
      <input type="range" id="nodeSlider" min="50" max="50000" value="50000" step="50">
    </div>
    <div class="input-group">
      <label>Multi-Seed: <span id="seedDisplay">3</span></label>
      <input type="range" id="seedSlider" min="1" max="10" value="3" step="1">
    </div>
    <div class="input-group">
      <label>Visualizaci√≥n</label>
      <select id="vizMode">
        <option value="ORBITAL" selected>√ìRBITA MULTI-SEED üåå</option>
        <option value="ENTITY">ENTE VIAJERO üëæ</option>
        <option value="BICAMERAL">CEREBRO BICAMERAL üß†</option>
        <option value="FUSION">FUSI√ìN MULTIVERSAL üß¨</option>
        <option value="MANDALA">UNIVERSO MANDALA üå∏</option>
        <option value="LASER">UNIVERSO LASER ‚ö°</option>
        <option value="BUBBLE">UNIVERSO BURBUJA üõÅ</option>
        <option value="LANIAKEA">SUPERCLUSTER LANIAKEA üåå</option>
        <option value="NEGATIVE_RGB">LUZ RGB NEGATIVA (-255) üí°</option>
      </select>
    </div>
    <div class="input-group">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="ionChannelsToggle" style="width:auto;">
        <span>ION CHANNELS ‚öõÔ∏è</span>
      </label>
    </div>
    <div class="input-group">
      <label>Meta-Tema</label>
      <select id="uxTheme">
        <option value="COSMIC" selected>ABISMO C√ìSMICO üåå</option>
        <option value="MAPUCHE">MAPUCHE-C√ìSMICO üèîÔ∏è</option>
        <option value="CRISTAL">CRISTAL üíé</option>
        <option value="MANDA">MANDALA üåÄ</option>
        <option value="NAVE">NAVE ESPACIAL üöÄ</option>
        <option value="PHOTON">MODO FOT√ìN ‚ö°</option>
        <option value="PARADOX">666 PARADOX üî•</option>
      </select>
    </div>
    <button onclick="invokeCaos()" style="background:var(--text-magenta);color:white">CAOS</button>
    <button onclick="invokeFusion()" style="background:var(--text-cyan);color:black">FUSI√ìN</button>
    <button onclick="resetCamera()" style="background:#333;color:white">RESET CAM</button>
    
    <div class="input-group" style="margin-top:12px;border-top:1px solid var(--glass-border);padding-top:12px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="matrixMode" style="width:auto;">
        <span>MATRIX MODE üü¢</span>
      </label>
      <label style="display:flex;align-items:center;gap:8px;margin-top:5px;">
        <input type="checkbox" id="fiestaMode" style="width:auto;">
        <span>FIESTA MODE (MIC) üé§</span>
      </label>
    </div>
    
    <div id="matrixControls" style="display:none;margin-top:8px;">
      <div class="input-group">
        <label>Color Matrix</label>
        <select id="matrixColorPreset">
          <option value="#00ff41" selected>Matrix Green üü¢</option>
          <option value="#ff00ff">Vaporwave Purple üíú</option>
          <option value="#00f2ff">Cyan Hacker üîµ</option>
          <option value="#ff0033">Red Alert üî¥</option>
          <option value="#ffff00">Yellow Electric ‚ö°</option>
          <option value="custom">Custom...</option>
        </select>
      </div>
      <div class="input-group" id="customColorGroup" style="display:none;">
        <label>Color Personalizado</label>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="height:40px;cursor:pointer;">
      </div>
      <div class="input-group">
        <label>Opacidad: <span id="matrixOpacityDisplay">0.3</span></label>
        <input type="range" id="matrixOpacity" min="0.1" max="1" value="0.3" step="0.1">
      </div>
    </div>
    
    <div style="margin-top:10px;font-size:0.7rem;color:#666;border-top:1px solid var(--glass-border);padding-top:8px;">
      Seed: <span id="current-seed" style="color:var(--text-cyan)">-10</span><br>
      Mode: <span id="current-mode" style="color:var(--text-magenta)">LOADING...</span><br>
      <span style="color:#444">DIM 10-11: THERMAL NOISE FILTERING</span>
    </div>
  </div>

  <button class="immersion-toggle" onclick="toggleImmersionMode()">Immersion [H]</button>

  <div id="temporal-controls">
    <div class="hud-title">‚è±Ô∏è TEMPORAL CONTROL</div>
    <div id="speed-display">x1.0</div>
    <div style="display:flex;justify-content:center;gap:5px;margin-bottom:10px;">
      <button class="temporal-btn" onclick="setSpeed(-10)">‚óÄ‚óÄ -10x</button>
      <button class="temporal-btn" onclick="setSpeed(-5)">‚óÄ -5x</button>
      <button class="temporal-btn" onclick="setSpeed(0)">‚è∏ PAUSE</button>
      <button class="temporal-btn active" onclick="setSpeed(1)">‚ñ∂ 1x</button>
      <button class="temporal-btn" onclick="setSpeed(5)">‚ñ∂‚ñ∂ 5x</button>
      <button class="temporal-btn" onclick="setSpeed(10)">‚ñ∂‚ñ∂‚ñ∂ 10x</button>
      <button class="temporal-btn" onclick="setSpeed(20)">‚ö° 20x</button>
    </div>
    <div class="input-group">
      <label>Velocidad: <span id="speedSliderDisplay">1.0</span>x</label>
      <input type="range" id="speedSlider" min="-10" max="20" value="1" step="0.5">
    </div>
    
    <!-- IMMERSIVE CONTROLS -->
    <div style="margin-top:15px;padding-top:10px;border-top:1px solid var(--glass-border);">
      <div style="font-size:0.75rem;color:#888;margin-bottom:5px;">IMMERSIVE TOGGLES</div>
      <div style="display:flex;gap:10px;">
        <button onclick="document.getElementById('matrixMode').click()" style="background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);font-size:0.8rem;">
          TOGGLE MATRIX
        </button>
        <button onclick="document.getElementById('fiestaMode').click()" style="background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);font-size:0.8rem;">
          TOGGLE FIESTA
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Panel (Hidden by default) -->
  <div id="settings-panel" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.9);align-items:center;justify-content:center;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚öôÔ∏è SETTINGS</h2>
        <button onclick="closeSettings()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div class="hud-title" style="margin-bottom:15px;">KEYBOARD CONTROLS</div>
      
      <div id="key-bindings-list" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:20px;">
        <!-- Populated by updateKeyBindingsUI() -->
      </div>
      
      <div style="display:flex;gap:10px;">
        <button onclick="resetKeyBindings()" style="background:var(--text-red);">RESET TO DEFAULTS</button>
        <button onclick="closeSettings()" style="background:var(--text-cyan);color:black;">SAVE & CLOSE</button>
      </div>
    </div>
  </div>

  <!-- Tutorial / Help Overlay -->
  <div id="tutorial-overlay" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.95);align-items:center;justify-content:center;overflow-y:auto;padding:20px;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:800px;width:90%;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚ùì COSMIC OS TUTORIAL</h2>
        <button onclick="closeTutorial()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
        <div>
          <div class="hud-title" style="margin-bottom:10px;">‚å®Ô∏è KEYBOARD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">W/S/A/D</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">Q/E</b> - Rotar c√°mara<br>
            <b style="color:var(--text-cyan);">Space</b> - Subir<br>
            <b style="color:var(--text-cyan);">Shift</b> - Bajar<br>
            <b style="color:var(--text-cyan);">Ctrl</b> - Speed Boost 2x<br>
            <b style="color:var(--text-cyan);">H/L</b> - Modo Inmersivo<br>
            <b style="color:var(--text-cyan);">R</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">?</b> - Este tutorial<br>
          </div>
        </div>
        
        <div>
          <div class="hud-title" style="margin-bottom:10px;">üïπÔ∏è MOUSE</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Click + Drag</b> - Rotar vista<br>
            <b style="color:var(--text-cyan);">Scroll</b> - Zoom in/out<br>
            <b style="color:var(--text-cyan);">Double Click</b> - Viajar a nodo<br>
            <b style="color:var(--text-cyan);">Hover Izq</b> - Mostrar panel<br>
          </div>
          
          <div class="hud-title" style="margin:15px 0 10px;">üéÆ GAMEPAD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Stick Izq</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">LT/RT</b> - Subir/Bajar<br>
            <b style="color:var(--text-cyan);">A</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">B</b> - Immersion<br>
            <b style="color:var(--text-cyan);">X</b> - CAOS<br>
            <b style="color:var(--text-cyan);">Y</b> - Matrix Toggle<br>
          </div>
        </div>
      </div>
      
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid var(--glass-border);">
        <div class="hud-title" style="margin-bottom:10px;">üåå MODO INMERSIVO</div>
        <p style="font-size:0.85rem;color:#ccc;margin:0;">
          Presiona <b style="color:var(--text-cyan);">H</b> para entrar en modo inmersivo. La c√°mara se alejar√° autom√°ticamente para vista panor√°mica. 
          Los controles temporales aparecer√°n en la esquina inferior derecha para controlar la velocidad de simulaci√≥n (-10x a +20x).
        </p>
      </div>
      
      <button onclick="closeTutorial()" style="margin-top:20px;background:var(--text-cyan);color:black;">GOT IT!</button>
    </div>
  </div>

  <!-- Quick Navigation Panel -->
  <div id="quick-nav-panel" style="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:15px;width:200px;">
    <div class="hud-title" id="quick-nav-handle" style="margin-bottom:10px;cursor:grab;">üß≠QUICK NAV (Drag Me)</div>
    <button onclick="goToSingularity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
      üåå SINGULARITY
    </button>
    <button onclick="escapeGravity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);">
      üöÄ ESCAPE
    </button>
    <button onclick="goToNearestNode()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,255,0,0.2);border:1px solid var(--text-yellow);color:var(--text-yellow);">
      üéØ NEAREST NODE
    </button>
    <button onclick="goToRandomPosition()" style="width:100%;padding:8px;background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);">
      üé≤ RANDOM
    </button>
  </div>



  <!-- Settings Toggle Button -->
  <button onclick="openSettings()" style="position:fixed;bottom:20px;left:20px;z-index:1000;width:auto;padding:10px 15px;background:rgba(255,255,255,0.1);border:1px solid var(--glass-border);color:var(--text-cyan);">
    ‚öôÔ∏è SETTINGS
  </button>

  <button onclick="window.location.href='/hall_of_shame'" style="position:fixed;bottom:20px;left:140px;z-index:1000;width:auto;padding:10px 15px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
    üèÜ HALL OF SHAME
  </button>

  <button onclick="openTutorial()" style="position:fixed;bottom:20px;left:320px;z-index:1000;width:auto;padding:10px 15px;background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);">
    ‚ùì HELP
  </button>

</body>
</html>
