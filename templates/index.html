<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‚ö° COSMIC 11D - CONTROL TOTAL ‚ö°</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  
  <!-- Post-processing -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <style>
    :root {
      --bg-black: #000000;
      --glass-bg: rgba(0, 0, 0, 0.75);
      --glass-border: rgba(0, 242, 255, 0.3);
      --text-cyan: #00f2ff;
      --text-magenta: #ff00ff;
      --text-yellow: #ffff00;
      --text-red: #ff0033;
      --text-green: #00ff41;
    }
    
    /* Dark Glucose / Dark Matter Background */
    body::before {
      content:'';
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 20% 50%, rgba(138, 43, 226, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(0, 242, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 80%, rgba(255, 0, 255, 0.12) 0%, transparent 50%);
      animation: breathe 8s ease-in-out infinite, drift 20s linear infinite;
      pointer-events:none;
      z-index:0;
    }
    
    @keyframes breathe {
      0%, 100% { opacity:0.3; transform:scale(1); }
      50% { opacity:0.6; transform:scale(1.1); }
    }
    
    @keyframes drift {
      0% { background-position: 0% 0%, 100% 100%, 50% 50%; }
      100% { background-position: 100% 100%, 0% 0%, 150% 150%; }
    }
    
    body, html { margin:0; padding:0; overflow:hidden; background:var(--bg-black); font-family:'Inter',sans-serif; color:white; }
    #canvas-container { position:absolute; inset:0; z-index:1; }
    #intro-overlay {
      position:fixed; inset:0; background:black; z-index:10000; display:flex;
      align-items:center; justify-content:center; cursor:pointer;
    }
    #loading-overlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.9); z-index:9000; display:none;
      align-items:center; justify-content:center; color:var(--text-cyan); font-size:2rem;
    }
    .hud-module {
      position:absolute; background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto; z-index:10;
      transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
    }
    .hud-title { font-weight:700; font-size:0.9rem; letter-spacing:2px; color:var(--text-cyan); text-transform:uppercase; border-bottom:1px solid var(--glass-border); padding-bottom:5px; }
    
    /* Config Module - Collapsible from left (EXPANDE HACIA ARRIBA) */
    #config-module {
      bottom: 20px; /* Anclado abajo */
      left: -430px; /* Oculto (450px - 20px borde) */
      width: 450px; /* M√°s ancho */
      max-width: 90vw;
      max-height: 85vh; /* M√°ximo altura disponible */
      overflow-y: auto; /* Scroll si es necesario */
      transform: translateX(0);
      opacity: 0.4;
      z-index: 800; /* Debajo de Donation/Sine? Ajustable */
      transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.3s, z-index 0s 0.3s;
      
      /* Grid Layout Din√°mico */
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 15px;
      align-content: start;
    }
    
    #config-module:hover,
    #config-module:focus-within {
      transform: translateX(430px); /* Desliza hacia la derecha para mostrarse */
      opacity: 1;
      z-index: 2000; /* Encima de todo al interactuar */
      transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.3s, z-index 0s 0s;
    }
    
    #config-module .hud-title {
      grid-column: 1 / -1; /* T√≠tulo ocupa todo el ancho */
      text-align: center;
      margin-bottom: 10px;
    }
    
    #config-module > div[style*="grid"] {
      grid-column: 1 / -1; /* Botones de acci√≥n ocupan todo el ancho */
    }

    #config-module.dragging {
      transform: none !important; /* Desactivar transform al arrastrar */
      opacity: 1 !important;
      z-index: 2000 !important;
    }
    
    #config-module::before {
      content: '‚ò∞';
      position: absolute;
      right: -35px; /* Ajustado para el borde */
      top: 20px; 
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-left: none;
      border-radius: 0 8px 8px 0;
      padding: 12px 8px;
      color: var(--text-cyan);
      font-size: 1.4rem;
      cursor: pointer;
      pointer-events: auto;
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 5px rgba(0, 242, 255, 0.3); }
      50% { box-shadow: 0 0 15px rgba(0, 242, 255, 0.6); }
    }
    .input-group { margin-bottom:12px; }
    .input-group label { display:block; font-size:0.75rem; color:#888; margin-bottom:5px; }
    .input-group input, .input-group select { width:100%; background:rgba(0,242,255,0.05); border:1px solid var(--glass-border); color:var(--text-cyan); padding:8px; border-radius:4px; }
    button { width:100%; padding:10px; border:none; border-radius:4px; font-weight:bold; cursor:pointer; text-transform:uppercase; }
    button:hover { filter:brightness(1.2); transform:scale(1.02); }
    .immersion-toggle { 
      position:fixed; top:20px; right:20px; z-index:2000; 
      background:rgba(0,255,136,0.2); border:1px solid var(--text-cyan); 
      color:var(--text-cyan); padding:8px 12px; cursor:pointer;
      transition: opacity 0.3s ease;
    }
    .immersion-toggle:hover {
      background:rgba(0,255,136,0.4);
      opacity:1 !important;
    }
    
    /* Temporal Controls */
    #temporal-controls {
      position:fixed; bottom:20px; right:20px; z-index:10;
      background:var(--glass-bg); backdrop-filter:blur(15px);
      border:1px solid var(--glass-border); border-radius:8px; padding:15px;
      box-shadow:0 0 20px rgba(0,242,255,0.1); pointer-events:auto;
      min-width:350px;
      display:none; /* Oculto por defecto, solo en immersive mode */
    }
    .temporal-btn {
      width:auto; padding:8px 15px; margin:0 3px;
      background:rgba(0,242,255,0.1); border:1px solid var(--glass-border);
      color:var(--text-cyan); font-size:0.9rem;
    }
    .temporal-btn.active { background:var(--text-cyan); color:black; }
    #speed-display {
      font-size:1.5rem; font-weight:bold; color:var(--text-cyan);
      text-align:center; margin:10px 0;
    }
    
    /* Titan Panel - Stats Bar */
    #titan-panel {
      position:fixed;
      top:0;
      left:0;
      right:0;
      height:40px;
      background:var(--glass-bg);
      backdrop-filter:blur(20px);
      border-bottom:1px solid var(--glass-border);
      box-shadow:0 2px 20px rgba(0,242,255,0.2);
      z-index:10000;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 20px;
      font-size:0.85rem;
      pointer-events:auto;
    }
    
    .titan-stat {
      display:flex;
      align-items:center;
      gap:8px;
      color:#888;
    }
    
    .titan-stat-label {
      color:#666;
      font-size:0.75rem;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    
    .titan-stat-value {
      color:var(--text-cyan);
      font-weight:bold;
      font-size:0.9rem;
    }
    
    .titan-stat-value.warning {
      color:var(--text-yellow);
    }
    
    .titan-stat-value.danger {
      color:var(--text-red);
    }
    
    .titan-divider {
      width:1px;
      height:20px;
      background:var(--glass-border);
    }
    
    /* Titan Panel Controls */
    #titan-panel-controls {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    #titan-panel-controls button {
      background: rgba(0, 242, 255, 0.1);
      border: 1px solid var(--glass-border);
      color: var(--text-cyan);
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
      min-width: 35px;
      height: 30px;
    }
    
    #titan-panel-controls button:hover {
      background: rgba(0, 242, 255, 0.3);
      transform: scale(1.1);
      box-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
    }
    
    #titan-panel-controls button.hidden-panel {
      opacity: 0.4;
      background: rgba(255, 0, 51, 0.1);
      border-color: rgba(255, 0, 51, 0.3);
    }
    
    #titan-panel-controls button.hidden-panel:hover {
      background: rgba(255, 0, 51, 0.2);
    }
    
    /* Draggable cursor */
    .draggable {
      cursor: move;
    }
    
    .draggable.dragging {
      cursor: grabbing;
      z-index: 2000 !important;
      opacity: 0.9;
    }
    
    /* Donation Module */
    #donation-module {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: all 0.3s ease;
      max-width: 90vw;
    }
    
    @media (min-width: 800px) {
      #donation-module {
        flex-direction: row;
        align-items: center;
      }
    }
    
    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      background: rgba(255, 255, 255, 0.05);
      padding: 8px;
      border-radius: 4px;
      border: 1px solid rgba(0, 242, 255, 0.3);
      transition: all 0.3s ease;
    }
    
    .qr-container:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(0, 242, 255, 0.6);
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(0, 242, 255, 0.4);
    }
    
    .qr-image {
      width: 120px;
      height: 120px;
      /* background: white;  Removed, img src will provide content */
      border-radius: 4px;
      display: block; /* Changed from grid */
      box-shadow: 0 0 10px rgba(0, 242, 255, 0.3);
      position: relative;
    }
    
    /* Removed ::before simulation */
    
    .qr-image-overlay {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.6rem;
      font-weight: bold;
      color: #000;
      background: rgba(255, 255, 255, 0.95);
      padding: 1px 3px;
      border-radius: 2px;
      pointer-events: none;
    }
    

    
    .qr-label {
      font-size: 0.75rem;
      color: var(--text-cyan);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Sine Wave Visualization (Top Left) */
    #sine-wave-canvas {
      position: fixed;
      top: 50px; /* Debajo del Titan Panel */
      left: 10px;
      width: 300px;
      height: 150px;
      z-index: 500;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      padding: 5px;
      box-shadow: 0 0 20px rgba(0, 242, 255, 0.2);
      pointer-events: none;
      opacity: 0.8;
      transition: opacity 0.3s ease;
    }
    
    #sine-wave-canvas:hover {
      opacity: 1;
    }
    
    #sine-wave-canvas canvas {
      width: 100%;
      height: 100%;
      border-radius: 4px;
    }

    /* Toast Animations */
    @keyframes slideIn {
      from { transform:translateX(400px); opacity:0; }
      to { transform:translateX(0); opacity:1; }
    }
    @keyframes slideOut {
      from { transform:translateX(0); opacity:1; }
      to { transform:translateX(400px); opacity:0; }
    }
  </style>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üî• DEFINIR FUNCIONES ANTES DEL HTML (FIX enterCosmicOS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // üöÄ ENTER COSMIC OS
    function enterCosmicOS() {
        if (typeof initEngine === 'function') {
            initEngine();
            const intro = document.getElementById('intro-overlay');
            if (intro) {
                gsap.to(intro, {
                    opacity: 0,
                    duration: 1,
                    onComplete: () => intro.style.display = 'none'
                });
            }
        }
    }

    // Variables globales
    let scene, camera, renderer, controls, composer;
    let bloomPass;
    let centralSingularity, pointsCloud;
    let matrixLines = null; // L√≠neas Matrix
    let ionLines = null;    // L√≠neas I√≥nicas (Channels)
    let orbitalIons = null; // Part√≠culas de flujo orbital
    let currentUniverseSeed = -10;
    let isImmersionMode = false;
    let matrixModeActive = false;
    let matrixColor = 0x00ff41; // Verde Matrix por defecto
    let matrixOpacity = 0.3;
    let timeSpeed = 1.0; // Velocidad de simulaci√≥n
    let isPaused = false;

    // AUDIO REACTIVITY (FIESTA MODE)
    let audioContext, analyser, dataArray;
    let isFiestaMode = false;
    let audioInitialized = false;
    let currentMode = "ORBITAL"; // Fallback narrative mode
    let currentUniverseData = { modo: "LOADING", modo_info: { physics: { gravity: 1000 } } }; 
    let frameCount = 0;
    
    // Performance Optimization Globals (VEGA 11 OPTIMIZED)
    const CHUNK_SIZE = 15000; // 15k nodes per frame (balanced for Vega 11)
    let currentChunk = 0;
    let totalNodes = 120000; // 120k nodes max (realistic for Vega 11)
    
    // Debounce state
    let sliderTimeout = null;

    function initAudio() {
      if (audioInitialized) {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            console.log('üîä AudioContext resumed');
            showToast('üîä Audio Reactivado');
          });
        }
        return;
      }

      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) throw new Error('Web Audio API no soportada');

        audioContext = new AudioContext();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.8;
        dataArray = new Uint8Array(analyser.frequencyBinCount);

        navigator.mediaDevices.getUserMedia({ audio: true })
          .then(stream => {
            const source = audioContext.createMediaStreamSource(stream);
            source.connect(analyser);
            audioInitialized = true;
            if (audioContext.state === 'suspended') audioContext.resume();
            showToast('üé§ Micr√≥fono ACTIVO - Habla o pon m√∫sica');
            console.log('üé§ Audio Stream Connected');
          })
          .catch(err => {
            console.error('Error acceso microfono:', err);
            let msg = '‚ùå Error Micr√≥fono: ' + err.message;
            if (err.name === 'NotAllowedError') msg = '‚ùå Permiso denegado';
            if (err.name === 'NotFoundError') msg = '‚ùå No mic encontrado';
            showToast(msg, 5000);
            // Fallback inmediato a sim
            isFiestaMode = true;
            document.getElementById('fiestaMode').checked = true;
            showToast('‚ö†Ô∏è Activando SIMULACI√ìN AUDIO', 4000);
            console.log('‚ö†Ô∏è Audio simulation enabled');
            simulateAudioData(); // Init sim
          });
      } catch (e) {
        console.error('Audio Setup Error', e);
        showToast('‚ùå Error Audio: ' + e.message);
        // Fallback si try falla
        isFiestaMode = true;
        document.getElementById('fiestaMode').checked = true;
        simulateAudioData();
      }
    }

    // üéπ SYNTHETIC AUDIO GENERATOR (FIESTA RANDOM)
    function simulateAudioData() {
        if (!dataArray) {
             // Create dummy array if context failed completely
             dataArray = new Uint8Array(256);
        }
        
        const time = Date.now() * 0.001;
        // BPM based on seed (Random but deterministic per universe)
        const bpm = 120 + (Math.abs(currentUniverseSeed) % 60); 
        const freq = bpm / 60;
        
        // 1. Bass / Kick (Sharp Impulse)
        // sin wave raised to high power to create sharp beats
        const beatPhase = (time * freq) % 1.0;
        const kickEnvelope = Math.pow(1.0 - beatPhase, 4); // decay
        const kickVal = kickEnvelope * 255;
        
        // 2. Mids / Melan (Wobble)
        const wobble = (Math.sin(time * 3) + 1) / 2;
        
        // 3. Highs (Shimmer)
        
        // Fill Data Array with "Virtual" Sound
        for(let i=0; i<dataArray.length; i++) {
             if (i < 5) { // Deep Bass
                 dataArray[i] = kickVal; 
             } else if (i < 20) { // Bass
                 dataArray[i] = kickVal * 0.8;
             } else if (i < 100) { // Mids
                 dataArray[i] = wobble * 100 + (Math.random() * 50);
             } else { // Highs
                 dataArray[i] = (Math.sin(time * 10 + i) + 1) * 30 * kickEnvelope + (Math.random() * 20);
             }
        }
    }

    // üóø MAPUCHE PONEGLYPH TEXTURE GENERATOR
    function createPoneglyphTexture() {
        const size = 512;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 1. Background: Cosmic Stone Gradient (Cyan to Purple)
        const gradient = ctx.createLinearGradient(0, 0, size, size);
        gradient.addColorStop(0, '#003333'); // Deep Cyan
        gradient.addColorStop(1, '#1a0033'); // Deep Cosmic Purple
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);

        // 2. Stone Noise (Gritty texture)
        for (let i = 0; i < 60000; i++) {
            const x = Math.random() * size;
            const y = Math.random() * size;
            const val = Math.random() * 60;
            ctx.fillStyle = `rgba(${val},${val},${val + 40},0.15)`;
            ctx.fillRect(x, y, 2, 2);
        }

        // 3. Mapudungun Cosmic Symbols (Procedural Glyphs)
        ctx.strokeStyle = '#00ffff'; // Electric Cyan
        ctx.fillStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 8;
        ctx.shadowColor = '#00ffff';

        const cols = 4;
        const rows = 4;
        const cell = size / cols;

        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                if (Math.random() > 0.65) continue; // Some empty spaces for weathered look

                const cx = x * cell + cell / 2;
                const cy = y * cell + cell / 2;
                const r = cell / 3;

                ctx.beginPath();
                const type = Math.floor(Math.random() * 6);

                if (type === 0) { // MEW (Kultrun Diamond)
                    ctx.moveTo(cx, cy - r);
                    ctx.lineTo(cx + r, cy);
                    ctx.lineTo(cx, cy + r);
                    ctx.lineTo(cx - r, cy);
                    ctx.closePath();
                    ctx.stroke();
                     // Central dot
                    ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
                } else if (type === 1) { // CIRCLES (Cycles)
                    ctx.arc(cx, cy, r * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(cx, cy, r * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else if (type === 2) { // STEP FRET (Greca / Stairs)
                    const s = r * 0.6;
                    ctx.moveTo(cx - s, cy + s);
                    ctx.lineTo(cx - s, cy);
                    ctx.lineTo(cx, cy);
                    ctx.lineTo(cx, cy - s);
                    ctx.lineTo(cx + s, cy - s);
                    ctx.stroke();
                } else if (type === 3) { // COSMIC CROSS
                   ctx.moveTo(cx - r, cy); ctx.lineTo(cx + r, cy);
                   ctx.moveTo(cx, cy - r); ctx.lineTo(cx, cy + r);
                   ctx.stroke();
                } else if (type === 4) { // ZIG ZAG (Lightning/Snake)
                   ctx.moveTo(cx - r, cy - r/2);
                   ctx.lineTo(cx - r/3, cy + r/2);
                   ctx.lineTo(cx + r/3, cy - r/2);
                   ctx.lineTo(cx + r, cy + r/2);
                   ctx.stroke();
                } else { // TEXT GLYPH
                   ctx.font = 'bold 30px monospace';
                   ctx.textAlign = 'center';
                   ctx.textBaseline = 'middle';
                   ctx.fillText(Math.random() > 0.5 ? 'MAPU' : 'ANTU', cx, cy);
                }
            }
        }
        
        // Border Frame
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 15;
        ctx.strokeRect(0, 0, size, size);

        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }

    function createGargantuaSingularity() {
      const group = new THREE.Group();
      
      // 1. PONEGLYPH CORE (Ancient Cosmic Cube)
      // Replaces the black sphere. Now it is a relic.
      const geometry = new THREE.BoxGeometry(70, 70, 70); // Slightly larger than prev sphere
      const texture = createPoneglyphTexture();
      
      const material = new THREE.MeshPhysicalMaterial({
          map: texture,
          color: 0xffffff,
          roughness: 0.2,
          metalness: 0.8,
          emissive: 0x00ffff,
          emissiveIntensity: 2.0,
          bumpMap: texture,
          bumpScale: 5,
          transmission: 0.1
      });
      
      const poneglyph = new THREE.Mesh(geometry, material);
      group.add(poneglyph);
      group.userData.poneglyph = poneglyph; // Ref for animation

      // 2. Photon Sphere (Glowing ring)
      const glowGeo = new THREE.SphereGeometry(60, 64, 64); // Adjusted size
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.05, // Lowered for Bloom safety
        side: THREE.BackSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      group.add(glow);
      group.userData.photonSphere = glow;

      // 3. Accretion Disk
      const diskGeo = new THREE.RingGeometry(80, 200, 64);
      const pos = diskGeo.attributes.position;
      const v3 = new THREE.Vector3();
      for (let i = 0; i < pos.count; i++){
        v3.fromBufferAttribute(pos, i);
        // UV mapping for ring texture if we had one, or noise
        diskGeo.attributes.uv.setXY(i, v3.length() < 120 ? 0 : 1, 1);
      }
      
      // Particle System for Disk
      const diskPointsGeo = new THREE.BufferGeometry();
      const diskPointsCount = 8000; // Increased density
      const diskPositions = new Float32Array(diskPointsCount * 3);
      const diskColors = new Float32Array(diskPointsCount * 3);
      
      for(let i=0; i<diskPointsCount; i++) {
        const radius = 80 + Math.random() * 120;
        const theta = Math.random() * Math.PI * 2;
        
        // Spiral arms
        const spiralOffset = theta + (radius * 0.05);
        
        diskPositions[i*3] = Math.cos(spiralOffset) * radius;
        diskPositions[i*3+1] = (Math.random() - 0.5) * 10; // Volume
        diskPositions[i*3+2] = Math.sin(spiralOffset) * radius;
        
        // Color gradient: Inner hot (Cyan/White) -> Outer cool (Blue/Purple)
        const t = (radius - 80) / 120;
        const color = new THREE.Color();
        color.setHSL(0.5 + t * 0.1, 0.8, 0.7 - t * 0.4); // Cyan range
        diskColors[i*3] = color.r;
        diskColors[i*3+1] = color.g;
        diskColors[i*3+2] = color.b;
      }
      
      diskPointsGeo.setAttribute('position', new THREE.BufferAttribute(diskPositions, 3));
      diskPointsGeo.setAttribute('color', new THREE.BufferAttribute(diskColors, 3));
      
      const disk = new THREE.Points(diskPointsGeo, new THREE.PointsMaterial({
        size: 3,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      }));
      
      group.add(disk);
      group.userData.disk = disk;

      return group;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåä SINE WAVE VISUALIZATION (TOP LEFT)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function initSineWave() {
      const canvas = document.getElementById('sine-canvas');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      let phase = 0;
      
      function drawSineWave() {
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Background gradient
        const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
        bgGradient.addColorStop(0, 'rgba(0, 20, 40, 0.3)');
        bgGradient.addColorStop(1, 'rgba(0, 10, 20, 0.5)');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, width, height);
        
        // Get audio data if available
        let audioFactor = 1.0;
        if (isFiestaMode && dataArray) {
          const avgAudio = dataArray.slice(0, 50).reduce((a, b) => a + b, 0) / 50;
          audioFactor = 1.0 + (avgAudio / 255) * 2; // 1.0 - 3.0
        }
        
        // Draw multiple sine waves
        const waves = [
          { amplitude: 20, frequency: 0.02, color: 'rgba(0, 242, 255, 0.8)', offset: 0 },
          { amplitude: 15, frequency: 0.03, color: 'rgba(255, 0, 255, 0.6)', offset: Math.PI / 2 },
          { amplitude: 10, frequency: 0.04, color: 'rgba(0, 255, 65, 0.4)', offset: Math.PI }
        ];
        
        waves.forEach(wave => {
          ctx.beginPath();
          ctx.strokeStyle = wave.color;
          ctx.lineWidth = 2;
          
          for (let x = 0; x < width; x++) {
            const y = height / 2 + 
                     Math.sin((x * wave.frequency) + phase + wave.offset) * 
                     wave.amplitude * audioFactor;
            
            if (x === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          ctx.stroke();
        });
        
        // Draw FPS indicator
        ctx.fillStyle = 'rgba(0, 242, 255, 0.6)';
        ctx.font = '10px monospace';
        ctx.fillText(`WAVE ${Math.round(phase * 10)}`, 5, 12);
        
        // Update phase
        phase += 0.05 * timeSpeed;
        if (phase > Math.PI * 2) phase = 0;
        
        requestAnimationFrame(drawSineWave);
      }
      
      drawSineWave();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öôÔ∏è SISTEMA DE CONTROLES CONFIGURABLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Configuraci√≥n por defecto
    const defaultKeyBindings = {
      forward: 'w',
      back: 's',
      left: 'a',
      right: 'd',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'r'
    };

    // Cargar configuraci√≥n guardada o usar defaults
    let keyBindings = JSON.parse(localStorage.getItem('cosmicOS_keyBindings')) || {...defaultKeyBindings};

    // Guardar configuraci√≥n
    function saveKeyBindings() {
      localStorage.setItem('cosmicOS_keyBindings', JSON.stringify(keyBindings));
      showToast('‚öôÔ∏è Controles guardados');
    }

    // Resetear a defaults
    function resetKeyBindings() {
      keyBindings = {...defaultKeyBindings};
      saveKeyBindings();
      updateKeyBindingsUI();
      showToast('‚öôÔ∏è Controles reseteados a defaults');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ SISTEMA DRAGGABLE UNIVERSAL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function makeDraggable(elementId, handleSelector = null) {
      const element = document.getElementById(elementId);
      if (!element) return;
      
      const handle = handleSelector ? element.querySelector(handleSelector) : element;
      if (!handle) return;
      
      let isDragging = false;
      let startX, startY, initialLeft, initialTop;
      
      handle.style.cursor = 'move';
      element.classList.add('draggable');
      
      handle.addEventListener('mousedown', (e) => {
        // Ignorar si es el bot√≥n hamburguesa del config-module
        if (e.target.matches('#config-module::before')) return;
        
        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        const rect = element.getBoundingClientRect();
        initialLeft = rect.left;
        initialTop = rect.top;
        
        // Convertir a posicionamiento absoluto
        element.style.position = 'fixed';
        element.style.bottom = 'auto';
        element.style.right = 'auto';
        element.style.transform = 'none';
        element.style.left = initialLeft + 'px';
        element.style.top = initialTop + 'px';
        
        element.classList.add('dragging');
        handle.style.cursor = 'grabbing';
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        const newLeft = initialLeft + dx;
        const newTop = initialTop + dy;
        
        element.style.left = newLeft + 'px';
        element.style.top = newTop + 'px';
      });
      
      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          element.classList.remove('dragging');
          handle.style.cursor = 'move';
          
          // Guardar posici√≥n
          savePosition(elementId, element.style.left, element.style.top);
        }
      });
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üíæ SISTEMA DE PERSISTENCIA DE PANELES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const panelStates = {
      'config-module': { visible: true, defaultPos: { top: '50%', left: '-280px', transform: 'translateY(-50%)' } },
      'temporal-controls': { visible: false, defaultPos: { bottom: '20px', right: '20px' } },
      'quick-nav-panel': { visible: true, defaultPos: { bottom: '20px', left: '50%', transform: 'translateX(-50%)' } },
      'donation-module': { visible: true, defaultPos: { bottom: '20px', left: '20px' } }
    };
    
    function savePosition(panelId, left, top) {
      const positions = JSON.parse(localStorage.getItem('cosmicOS_panelPositions') || '{}');
      positions[panelId] = { left, top };
      localStorage.setItem('cosmicOS_panelPositions', JSON.stringify(positions));
    }
    
    function restorePositions() {
      const positions = JSON.parse(localStorage.getItem('cosmicOS_panelPositions') || '{}');
      Object.keys(positions).forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (panel && positions[panelId]) {
          panel.style.position = 'fixed';
          panel.style.left = positions[panelId].left;
          panel.style.top = positions[panelId].top;
          panel.style.bottom = 'auto';
          panel.style.right = 'auto';
          panel.style.transform = 'none';
        }
      });
      
      // Restaurar estados de visibilidad
      const states = JSON.parse(localStorage.getItem('cosmicOS_panelStates') || '{}');
      Object.keys(states).forEach(panelId => {
        if (states[panelId] !== undefined && states[panelId].visible !== undefined) {
          panelStates[panelId].visible = states[panelId].visible;
          const panel = document.getElementById(panelId);
          if (panel) {
            panel.style.display = states[panelId].visible ? '' : 'none';
          }
          // Actualizar bot√≥n
          updatePanelButton(panelId, states[panelId].visible);
        }
      });
    }
    
    function togglePanel(panelId) {
      const panel = document.getElementById(panelId);
      if (!panel) return;
      
      // If it's the config module, we don't want to hide it completely (display:none)
      // because that kills the hover handle. We just want to "collapse" it.
      if (panelId === 'config-module') {
         // Check if it's currently expanded "programmatically" (e.g. dragging or pinned?)
         // Actually, our CSS handles the collapse (left: -430px). 
         // "Toggle" button might just be for "Focus" or "Hide completely"?
         // User says "without pressing button".
         // Let's make the button mostly irrelevant -> it just ensures it's in default state.
         
         const isHidden = panel.classList.contains('force-hidden');
         
         if (isHidden) {
             panel.classList.remove('force-hidden');
             panel.style.display = ''; 
             showToast('üëÅÔ∏è Panel Neural Restaurado');
         } else {
             // If user really wants to hide it?
             // Maybe just flash it?
             // Let's assume the button should "Reset" it to peeking state if it was hidden.
             panel.classList.remove('force-hidden');
             panel.style.display = '';
             showToast('üß† Panel Neural Listo (Desliza mouse al borde izquierdo)');
         }
         // Update button state
         updatePanelButton(panelId, true);
         return;
      }

      const isVisible = panel.style.display !== 'none';
      panel.style.display = isVisible ? 'none' : '';
      panelStates[panelId].visible = !isVisible;
      
      // Actualizar bot√≥n
      updatePanelButton(panelId, !isVisible);
      
      // Guardar estado
      const states = JSON.parse(localStorage.getItem('cosmicOS_panelStates') || '{}');
      states[panelId] = { visible: !isVisible };
      localStorage.setItem('cosmicOS_panelStates', JSON.stringify(states));
      
      showToast(`${isVisible ? 'üôà' : 'üëÅÔ∏è'} Panel ${isVisible ? 'ocultado' : 'restaurado'}`);
    }
    
    function updatePanelButton(panelId, isVisible) {
      const btn = document.querySelector(`[data-panel="${panelId}"]`);
      if (btn) {
        if (isVisible) {
          btn.classList.remove('hidden-panel');
        } else {
          btn.classList.add('hidden-panel');
        }
      }
    }
    
    function resetAllPanels() {
      Object.keys(panelStates).forEach(panelId => {
        const panel = document.getElementById(panelId);
        if (!panel) return;
        
        const defaultPos = panelStates[panelId].defaultPos;
        panel.style.position = 'fixed';
        Object.keys(defaultPos).forEach(prop => {
          panel.style[prop] = defaultPos[prop];
        });
        
        // Resetear otras propiedades
        panel.style.display = '';
        panel.style.bottom = defaultPos.bottom || 'auto';
        panel.style.right = defaultPos.right || 'auto';
        panel.style.left = defaultPos.left || 'auto';
        panel.style.top = defaultPos.top || 'auto';
        
        panelStates[panelId].visible = true;
        updatePanelButton(panelId, true);
      });
      
      // Limpiar localStorage
      localStorage.removeItem('cosmicOS_panelStates');
      localStorage.removeItem('cosmicOS_panelPositions');
      
      showToast('üîÑ Vista restaurada a defaults');
    }


    // Movimiento (EXTREME SPEED MODE)
    const moveState = { forward:0, back:0, left:0, right:0, up:0, down:0, rotateUp:0, rotateDown:0, rotateLeft:0, rotateRight:0 };
    const velocity = new THREE.Vector3();
    let acceleration = 9.0; // 2x faster acceleration
    const deceleration = 0.94; // Smoother deceleration
    let maxSpeed = 90; // 2x max speed
    let speedBoost = 2.5; // 2.5x boost with Ctrl (was 1.0)
    let rotationSpeed = 0.04; // 2x rotation speed

    const availableSeeds = Array.from({length:500}, (_,i) => -10 + i); // 500 seeds (2.5x upgrade)

    async function loadUniverse(seed) {
      document.getElementById('loading-overlay').style.display = 'flex';
      const seedDisplay = document.getElementById('current-seed');
      const modeDisplay = document.getElementById('current-mode');
      const seedDisplayTop = document.getElementById('current-seed-display');
      const modeDisplayTop = document.getElementById('current-mode-display');
      
      if (seedDisplay) seedDisplay.textContent = seed;
      if (seedDisplayTop) seedDisplayTop.textContent = seed;

      try {
        const res = await fetch(`/web/data_seed_${seed}.json`);
        let data;
        if (!res.ok) {
           console.warn(`‚ö†Ô∏è Seed ${seed} not found (404). Generating emergency nodes.`);
           data = {
             nodes: [],
             modo: "EMERGENCY_RECOVERY",
             horror_total: 666,
             modo_info: { emoji: "üÜò", desc: "Suministro de emergencia activado" }
           };
            const sliderCount = parseInt(document.getElementById('nodeSlider')?.value || 50000);
            for(let i=0; i<sliderCount; i++) {
              // Spherical Distribution for "Bien 360"
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos(2 * Math.random() - 1);
              const r = 500 + Math.random() * 1500;
              
              const x = r * Math.sin(phi) * Math.cos(theta);
              const y = r * Math.sin(phi) * Math.sin(theta);
              const z = r * Math.cos(phi);

              data.nodes.push({
                id: `E${i}`,
                position: [x, y, z],
                color: 0xff0033
              });
            }
        } else {
           data = await res.json();
        }
        currentUniverseData = data;

        // Limpiar escena
        if (pointsCloud) { scene.remove(pointsCloud); pointsCloud = null; }
        if (centralSingularity) { scene.remove(centralSingularity); centralSingularity = null; }

        // üåå GARGANTUA SINGULARITY v9.4.0
        centralSingularity = createGargantuaSingularity();
        scene.add(centralSingularity);

        // Nodos
        // Nodos
        const sliderTarget = parseInt(document.getElementById('nodeSlider')?.value || 50000);
        const jsonCount = data.nodes ? data.nodes.length : 0;
        const totalCount = Math.max(jsonCount, sliderTarget);
        
        if (totalCount > 0) {
          const pos = new Float32Array(totalCount * 3);
          const colors = new Float32Array(totalCount * 3);
          const originalColors = new Float32Array(totalCount * 3);
          const sizes = new Float32Array(totalCount); // Variable sizes
          
          // 1. Cargar nodos del JSON (Estructura Real)
          if (data.nodes) {
              data.nodes.forEach((n,i) => {
                const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
                pos[i*3] = p[0]; pos[i*3+1] = p[1]; pos[i*3+2] = p[2];
                
                // Color base
                const c = new THREE.Color();
                if (n.color) {
                   c.set(n.color);
                } else {
                   const hue = ((Math.abs(seed) % 10) / 10 + (i/jsonCount)*0.1) % 1;
                   c.setHSL(hue, 0.8, 0.5);
                }
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                originalColors[i*3] = c.r; originalColors[i*3+1] = c.g; originalColors[i*3+2] = c.b;
                sizes[i] = 2.0; // Nodos estructurales m√°s grandes
              });
          }
          
          // 2. Generar nodos procedimentales (Materia Oscura / Polvo C√≥smico) para llenar hasta el slider
          if (totalCount > jsonCount) {
             const geometryType = document.getElementById('vizMode')?.value || "ORBITAL";
             
             for (let i = jsonCount; i < totalCount; i++) {
                let x, y, z;
                
                // Distribuci√≥n basada en el modo actual
                if (geometryType === 'MANDALA') {
                    const r = 800 + Math.random() * 2000;
                    const theta = (i / totalCount) * Math.PI * 2 * 34; // Golden angle-ish
                    const phi = Math.random() * Math.PI;
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = (Math.random() - 0.5) * 600;
                } else {
                    // Distribuci√≥n Esf√©rica Expandida (Halo)
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = 1000 + Math.random() * 3000; // Radio m√°s amplio
                    
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                
                pos[i*3] = x; pos[i*3+1] = y; pos[i*3+2] = z;
                
                // Color tenue para el fondo (Background noise)
                const c = new THREE.Color();
                // Usar color del tema o variaci√≥n
                const modeColor = data.modo_info?.color || "#00ffff";
                c.set(modeColor);
                // Oscurecer y variar ligeramente
                c.offsetHSL(Math.random()*0.1, -0.2, -0.3); 
                
                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
                originalColors[i*3] = c.r; originalColors[i*3+1] = c.g; originalColors[i*3+2] = c.b;
                sizes[i] = 0.8 + Math.random() * 0.8; // M√°s peque√±os
             }
          }
          
          const g = new THREE.BufferGeometry();
          g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
          g.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          g.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); // Necesita soporte en shader o sizeAttenuation manual
          g.userData.originalColors = originalColors;
          
          pointsCloud = new THREE.Points(g, new THREE.PointsMaterial({
              vertexColors: true, 
              size: 1.2, 
              transparent: true,
              opacity: 0.6,
              blending: THREE.AdditiveBlending,
              sizeAttenuation: true
          }));
          scene.add(pointsCloud);
          
          // Actualizar contador real
          const tNodes = document.getElementById('titan-nodes');
          if (tNodes) tNodes.textContent = totalCount.toLocaleString();
        }

        const modoText = data.modo || "DOLPHIN";
        if (modeDisplay) modeDisplay.textContent = modoText;
        if (modeDisplayTop) modeDisplayTop.textContent = modoText;
        
        // Update Titan Panel
        const titanMode = document.getElementById('titan-mode');
        const titanSeed = document.getElementById('titan-seed');
        const titanHorror = document.getElementById('titan-horror');
        if (titanMode) titanMode.textContent = modoText;
        if (titanSeed) titanSeed.textContent = seed;
        if (titanHorror && data.horror_total) {
          titanHorror.textContent = Math.round(data.horror_total).toLocaleString();
        }
      } catch (e) {
        console.error("Error:", e);
        if (modeDisplay) modeDisplay.textContent = "ERROR";
        if (modeDisplayTop) modeDisplayTop.textContent = "ERROR";
      }

      document.getElementById('loading-overlay').style.display = 'none';
    }

    function initEngine() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);

      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 10000);
      camera.position.set(0, 500, 1500);

      renderer = new THREE.WebGLRenderer({ 
        antialias: false, // Disabled for extreme performance
        powerPreference: "high-performance",
        logarithmicDepthBuffer: true // Better depth precision for large scenes
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Reduced for 150k nodes
      renderer.setSize(innerWidth, innerHeight);
      renderer.toneMapping = THREE.ReinhardToneMapping;
      renderer.toneMappingExposure = 1.0;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // WebGL Resilience
      renderer.domElement.addEventListener('webglcontextlost', (e) => {
          e.preventDefault();
          console.warn('‚ö†Ô∏è WebGL Context Lost! Stabilizing...');
          showToast('‚ö†Ô∏è GPU OVERLOAD: RECOVERING...');
      }, false);

      renderer.domElement.addEventListener('webglcontextrestored', () => {
          console.log('‚úÖ WebGL Context Restored');
          loadUniverse(currentUniverseSeed);
      }, false);

      // 1. Post-processing setup (OPTIMIZED FOR 150K NODES)
      const renderScene = new THREE.RenderPass(scene, camera);
      bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(innerWidth * 0.8, innerHeight * 0.8), // Reduced resolution for performance
        1.2, // Reduced strength
        0.3, // Reduced radius
        0.88 // Higher threshold
      );
      bloomPass.threshold = 0.25; // Higher threshold = less bloom = better FPS
      bloomPass.strength = 0.9; // Reduced strength
      bloomPass.radius = 0.45; // Reduced radius

      composer = new THREE.EffectComposer(renderer);
      composer.addPass(renderScene);
      composer.addPass(bloomPass);

      // 2. Lights (Essential for MeshStandardMaterial depth)
      const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft white light
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0x00ffff, 2, 500);
      pointLight.position.set(0, 0, 0); // Inside the Poneglyph
      scene.add(pointLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(100, 200, 100);
      scene.add(directionalLight);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // MOVED: Double click listener added here to ensure renderer exists
      // Viz Mode Change
      document.getElementById('vizMode')?.addEventListener('change', e => {
         const mode = e.target.value;
         if (mode === 'MANDALA') {
            createMandalaUniverse();
            // Ensure audio is on for Mandala reactivity, but don't force Matrix
            if (!isFiestaMode) {
              isFiestaMode = true;
              const fCheckbox = document.getElementById('fiestaMode');
              if (fCheckbox) fCheckbox.checked = true;
              initAudio();
            }
         } else if (mode === 'FUSION') {
            invokeFusion();
         } else if (mode === 'LASER') {
            createLaserUniverse();
         } else if (mode === 'BUBBLE') {
            createBubbleUniverse();
         } else if (mode === 'LANIAKEA') {
            createLaniakeaUniverse();
         } else if (mode === 'NEGATIVE_RGB') {
            createNegativeRGBUniverse();
         } else {
            loadUniverse(currentUniverseSeed); 
         }
      });
      
      // Initialize Sine Graph
      initSineGraph();
      
      // Ion Channels Toggle
      document.getElementById('ionChannelsToggle')?.addEventListener('change', e => {
         if(e.target.checked) createIonChannels();
         else removeIonChannels();
      });


      loadUniverse(currentUniverseSeed);
      initSineWave(); // Initialize sine wave visualization
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (!scene || !camera) return;

      const time = Date.now() * 0.001;
      const speedMultiplier = timeSpeed;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);
      const side = new THREE.Vector3().crossVectors(camera.up, dir).normalize();

      const accel = new THREE.Vector3();
      if (moveState.forward) accel.addScaledVector(dir, acceleration * speedMultiplier);
      if (moveState.back) accel.addScaledVector(dir, -acceleration * speedMultiplier);
      if (moveState.left) accel.addScaledVector(side, acceleration * speedMultiplier);
      if (moveState.right) accel.addScaledVector(side, -acceleration * speedMultiplier);
      if (moveState.up) accel.y += acceleration * speedMultiplier;
      if (moveState.down) accel.y -= acceleration * speedMultiplier;

      velocity.add(accel);
      velocity.multiplyScalar(deceleration);
      if (velocity.length() > maxSpeed) velocity.setLength(maxSpeed);

      camera.position.add(velocity);
      controls.target.add(velocity);
      
      if (moveState.rotateLeft) camera.rotation.y += rotationSpeed * speedMultiplier;
      if (moveState.rotateRight) camera.rotation.y -= rotationSpeed * speedMultiplier;
      if (moveState.rotateUp) camera.rotation.x += rotationSpeed * speedMultiplier;
      if (moveState.rotateDown) camera.rotation.x -= rotationSpeed * speedMultiplier;
      
      if (!isImmersionMode && controls) controls.update();

      // 1. UPDATE AUDIO DATA ONCE PER FRAME
      if (isFiestaMode) {
        if (audioInitialized && analyser && dataArray) {
          analyser.getByteFrequencyData(dataArray);
        } else {
          simulateAudioData();
        }
      }

      // 2. ANIMATE CENTRAL SINGULARITY
      if (centralSingularity) {
        const ud = centralSingularity.userData;
        if (ud?.disk) ud.disk.rotation.y += 0.002 * speedMultiplier;

        if (ud?.poneglyph?.material) {
          const pg = ud.poneglyph;
          pg.rotation.y -= 0.005 * speedMultiplier;
          pg.rotation.x += 0.003 * speedMultiplier;
          pg.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
        }

        if (ud?.photonSphere?.material) {
          ud.photonSphere.material.opacity = Math.sin(Date.now() * 0.001) * 0.05 + 0.15;
        }
      }

      // 3. ANIMATE MATRIX LINES
      if (matrixLines?.material) {
        matrixLines.rotation.y += 0.001 * speedMultiplier;

        if (matrixModeActive) {
          if (isFiestaMode && dataArray && currentUniverseData) {
             const gravityFactor = Math.abs(currentUniverseData?.modo_info?.physics?.gravity || 1000) / 10000;
             const flowSpeed = 0.002 * (1 + gravityFactor); 
             const timeAt = Date.now();
             const bass = dataArray[4] || 0; 
             const normBass = bass / 255.0;
             const hue = (timeAt * flowSpeed + normBass * 0.1) % 1; 
             
             matrixLines.material.color?.setHSL(hue, 1.0, 0.3 + normBass * 0.7);
             matrixLines.material.opacity = (matrixOpacity || 0.3) + (normBass * 0.5);
             
             if (ionLines?.material?.color) {
                 ionLines.material.color.setHSL((hue + 0.5) % 1, 1.0, 0.5 + normBass*0.5);
                 ionLines.material.opacity = 0.4 + normBass * 0.4;
                 ionLines.rotation.y -= 0.02; 
             }
          } else {
             const timeAt = Date.now() * 0.0005;
             const hue = (timeAt % 1); 
             matrixLines.material.color?.setHSL(hue, 0.8, 0.5);
             matrixLines.material.opacity = matrixOpacity || 0.3;
          }
        }
      }

      // 4. ANIMATE ION LINES (CHANNELS)
      if (ionLines?.material) {
        ionLines.rotation.y -= 0.002 * speedMultiplier; 
        ionLines.rotation.x += 0.001 * speedMultiplier;
        
        if (isFiestaMode && dataArray) {
           const mid = dataArray[20] || 0;
           const normMid = mid / 255.0;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + (normMid * 0.5), 1.0, 0.6 + (normMid * 0.4));
           ionLines.material.opacity = 0.4 + (normMid * 0.6);
           const scale = 1.0 + (normMid * 0.5); 
           ionLines.scale.set(scale, scale, scale);
        } else {
           const timeAt = Date.now() * 0.002;
           const pulse = 0.3 + Math.sin(timeAt) * 0.2;
           ionLines.material.opacity = pulse;
           if (ionLines.material.color) ionLines.material.color.setHSL(0.5 + Math.sin(timeAt*0.5)*0.1, 1.0, 0.5);
           ionLines.scale.set(1,1,1);
        }
      }
      
      // 5. ANIMATE ORBITAL IONS
      if (orbitalIons && orbitalIons.material) {
          orbitalIons.rotation.y += 0.0015 * speedMultiplier * (isFiestaMode ? 4 : 1);
          orbitalIons.material.opacity = 0.5 + Math.sin(time * 3) * 0.3;
      }

      // 6. ANIMATE MANDALA / POINTS CLOUD
      const pc = pointsCloud;
      if (pc && pc.geometry && pc.geometry.attributes && pc.geometry.attributes.position) {
        if (pc.userData && pc.userData.isMandala) {
          pc.rotation.z += 0.001 * speedMultiplier;
          pc.rotation.y += 0.002 * speedMultiplier;

          if (isFiestaMode && dataArray) {
            if (frameCount % 2 === 0) {
              const positions = pc.geometry.attributes.position.array;
              const original = pc.geometry.userData.originalPositions;
              const layerIndices = pc.geometry.userData.layerIndices;
              const scales = pc.geometry.userData.scales;
              
                if (original && layerIndices && scales) {
                  const count = positions.length / 3;
                  const start = currentChunk * CHUNK_SIZE;
                  const end = Math.min(start + CHUNK_SIZE, count);

                  for(let i = start; i < end; i++) {
                    const layer = layerIndices[i];
                    const audioIdx = Math.floor((layer * 5) % dataArray.length);
                    const audioVal = dataArray[audioIdx] || 0;
                    const targetScale = 1.0 + (audioVal * 0.015);
                    scales[i] = scales[i] + (targetScale - scales[i]) * 0.3;

                    const idx3 = i*3;
                    positions[idx3]   = original[idx3] * scales[i];
                    positions[idx3+1] = original[idx3+1] * scales[i];
                    positions[idx3+2] = original[idx3+2] * scales[i];
                  }
                  pc.geometry.attributes.position.needsUpdate = true;
                }
            }
          }
        }
        
        // Gravitational Redshift Simulation (Universal)
        if (pc.geometry.userData.originalColors && frameCount % 2 === 0) {
            const colorAttr = pc.geometry.attributes.color;
            if (colorAttr) {
                const colors = colorAttr.array;
                const orig = pc.geometry.userData.originalColors;
                const positions = pc.geometry.attributes.position.array;
                const count = colorAttr.count;
                
                const start = currentChunk * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, count);

                for (let i = start; i < end; i++) {
                    const x = positions[i*3], y = positions[i*3+1], z = positions[i*3+2];
                    const d = Math.sqrt(x*x + y*y + z*z);
                    const grav = Math.max(0.0, 1.0 - (d / 3500));
                    const boost = 1.0 + Math.pow(grav, 3) * 25.0; 
                    colors[i*3]   = orig[i*3] * boost;
                    colors[i*3+1] = orig[i*3+1] * boost;
                    colors[i*3+2] = orig[i*3+2] * boost;
                }
                colorAttr.needsUpdate = true;
                
                // Advance chunk for next frame
                currentChunk = (currentChunk + 1) % Math.ceil(count / CHUNK_SIZE);
            }
        }
      }

      updateTitanPanel();
      if (composer) composer.render();
      else renderer.render(scene, camera);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé® THEME SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const themeSelect = document.getElementById('uxTheme');
    if (themeSelect) {
      themeSelect.addEventListener('change', (e) => {
        setTheme(e.target.value);
      });
    }

    function setTheme(theme) {
      console.log(`üé® Theme changed to: ${theme}`);
      
      const nodes = pointsCloud ? pointsCloud.geometry : null;
      
      switch(theme) {
        case 'PHOTON':
          // MODO FOT√ìN: Cyan electric, bright, high contrast
          document.documentElement.style.setProperty('--text-cyan', '#00ffff');
          document.body.style.background = '#000000';
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 6;
            pointsCloud.material.opacity = 0.9;
            pointsCloud.material.color = new THREE.Color(0x00ffff);
            pointsCloud.material.vertexColors = false; 
          }
          
          // Matrix lines bright
          if (matrixLines && matrixLines.material) {
            matrixLines.material.color = new THREE.Color(0xffffff);
            matrixLines.material.opacity = 0.5;
          }
          
          showToast('‚ö° MODO FOT√ìN ACTIVADO');
          break;
          
        case 'PARADOX':
          // MODO 666 PARADOX: Fire, Red/Orange/Yellow, Hellish
          document.documentElement.style.setProperty('--text-cyan', '#ff4500'); // OrangeRed
          document.body.style.background = '#1a0500'; // Dark red/brown
          
          if (pointsCloud && pointsCloud.material) {
            pointsCloud.material.size = 10;
            pointsCloud.material.opacity = 1.0;
            pointsCloud.material.vertexColors = true;
            
            // Recolor nodes to fire gradient
            const count = nodes.attributes.position.count;
            const colors = nodes.attributes.color.array;
            
            for (let i = 0; i < count; i++) {
              const r = Math.random() * 0.5 + 0.5; // 0.5-1.0 (Red)
              const g = Math.random() * 0.5;       // 0-0.5 (Green -> Orange/Yellow)
              const b = 0;                         // No blue
              
              colors[i * 3] = r;
              colors[i * 3 + 1] = g;
              colors[i * 3 + 2] = b;
            }
            nodes.attributes.color.needsUpdate = true;
          }
          
          // Singularity becomes a burning sun
          if (centralSingularity) {
            const children = centralSingularity.children;
            children.forEach(child => {
              if (child.isMesh && child.geometry.type === 'SphereGeometry' && child.material) {
                 // Core becomes bright yellow/white
                 if (child.geometry.parameters.radius === 30) {
                   child.material.color.setHex(0xffff00);
                 }
                 // Glow becomes orange
                 if (child.geometry.parameters.radius === 45) {
                   child.material.color.setHex(0xff4500);
                   child.material.opacity = 0.4;
                 }
              }
            });
          }
          
          showToast('üî• 666 PARADOX ACTIVADO');
          break;
          
        case 'COSMIC':
        default:
          // Reset to default
          document.documentElement.style.setProperty('--text-cyan', '#00f2ff');
          document.body.style.background = 'var(--bg-black)';
           
          // Restore functionality would require reloading mechanism or storing original state
          // For now, we just reset colors if possible or re-enable vertex colors
          if (pointsCloud && pointsCloud.material) {
             pointsCloud.material.vertexColors = true;
             pointsCloud.material.color = new THREE.Color(0xffffff);
             pointsCloud.material.size = 8;
          }
          if (centralSingularity && centralSingularity.children) {
             // Reset singularity colors
             if (centralSingularity.children[0] && centralSingularity.children[0].material) {
                centralSingularity.children[0].material.color.setHex(0x000000); // Core
             }
             if (centralSingularity.children[1] && centralSingularity.children[1].material) {
                centralSingularity.children[1].material.color.setHex(0xffffff); // Glow
             }
          }
          showToast('üåå MODO C√ìSMICO RESTAURADO');
          break;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß† NEURAL INTERFACE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    let lastTime = performance.now();
    let fps = 60;
    frameCount = 0;
    let lastFpsUpdate = performance.now();

    function updateTitanPanel() {
      // FPS calculation
      frameCount++;
      const now = performance.now();
      if (now - lastFpsUpdate >= 1000) {
        fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
        frameCount = 0;
        lastFpsUpdate = now;
        
        const fpsEl = document.getElementById('titan-fps');
        if (fpsEl) {
          fpsEl.textContent = fps;
          fpsEl.className = 'titan-stat-value';
          if (fps < 30) fpsEl.classList.add('danger');
          else if (fps < 50) fpsEl.classList.add('warning');
        }
      }

      // Node count
      const nodesEl = document.getElementById('titan-nodes');
      if (nodesEl && pointsCloud) {
        const count = pointsCloud.geometry.attributes.position.count;
        nodesEl.textContent = count.toLocaleString();
      }

      // Memory usage
      const memEl = document.getElementById('titan-memory');
      if (memEl && performance.memory) {
        const mb = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
        memEl.textContent = mb + ' MB';
      }

      // Speed
      const speedEl = document.getElementById('titan-speed');
      if (speedEl) {
        if (isPaused) {
          speedEl.textContent = 'PAUSED';
          speedEl.className = 'titan-stat-value warning';
        } else {
          speedEl.textContent = 'x' + timeSpeed.toFixed(1);
          speedEl.className = 'titan-stat-value';
        }
      }
    }

    function enterCosmicOS() {
      gsap.to("#intro-overlay", {opacity:0, duration:1.2, onComplete:() => {
        document.getElementById('intro-overlay').style.display = 'none';
        initEngine();
      }});
    }

    function invokeCaos() {
      const randomSeed = availableSeeds[Math.floor(Math.random() * availableSeeds.length)];
      currentUniverseSeed = randomSeed;
      loadUniverse(randomSeed);
    }

    function invokeFusion() {
      const seedCount = parseInt(document.getElementById('seedSlider').value);
      const seeds = [];
      for (let i = 0; i < seedCount; i++) {
        seeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
      }
      console.log('FUSION MODE:', seeds);
      loadMultipleSeeds(seeds);
    }

    async function loadMultipleSeeds(seeds) {
      document.getElementById('loading-overlay').style.display = 'flex';
      
      if (pointsCloud) scene.remove(pointsCloud);
      
      const allNodes = [];
      const offsetDistance = 2000;
      
      const loadingCounter = document.getElementById('loading-overlay');
      
      for (let i = 0; i < seeds.length; i++) {
        if (i % 10 === 0) { // Batch updates every 10 seeds
            loadingCounter.textContent = `üåå COLAPSANDO EL MULTIVERSO... [${i}/${seeds.length}]`;
            await new Promise(r => setTimeout(r, 10)); // Allow DOM to breathe
        }

        try {
          const res = await fetch(`/web/data_seed_${seeds[i]}.json`);
          if (!res.ok) continue;
          const data = await res.json();
          
          if (data.nodes) {
            const angle = (i / seeds.length) * Math.PI * 2;
            const offsetX = Math.cos(angle) * offsetDistance;
            const offsetZ = Math.sin(angle) * offsetDistance;
            
            const hue = (i / seeds.length) * 360;
            const color = new THREE.Color();
            color.setHSL(hue / 360, 0.8, 0.6);
            
            data.nodes.forEach(n => {
              const p = n.position || [Math.random()*2000-1000, Math.random()*1000-500, Math.random()*2000-1000];
              allNodes.push({
                x: p[0] + offsetX,
                y: p[1],
                z: p[2] + offsetZ,
                r: color.r,
                g: color.g,
                b: color.b
              });
            });
          }
        } catch (e) {
          console.error(`Error loading seed ${seeds[i]}:`, e);
        }
      }
      loadingCounter.textContent = `ESTABILIZANDO SINGULARIDAD... (${allNodes.length.toLocaleString()} nodos)`;
      
      const positions = new Float32Array(allNodes.length * 3);
      const colors = new Float32Array(allNodes.length * 3);
      
      allNodes.forEach((n, i) => {
        positions[i * 3] = n.x;
        positions[i * 3 + 1] = n.y;
        positions[i * 3 + 2] = n.z;
        colors[i * 3] = n.r;
        colors[i * 3 + 1] = n.g;
        colors[i * 3 + 2] = n.b;
      });
      
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      // Dynamic Point Size based on total nodes
      let pSize = 8;
      if (allNodes.length > 500000) pSize = 1;
      else if (allNodes.length > 200000) pSize = 2;
      else if (allNodes.length > 100000) pSize = 4;

      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: pSize,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        })
      );
      
      scene.add(pointsCloud);
      
      // Force Titan Panel update for node count
      if (typeof updateTitanPanel === 'function') updateTitanPanel();

      document.getElementById('loading-overlay').style.display = 'none';
    }

    // üî• SINGULARITY OMEGA - 200 UNIVERSES CONVERGING
    async function invokeSingularityOmega() {
        const omegaSeeds = [];
        for(let i=0; i<200; i++) {
            omegaSeeds.push(availableSeeds[Math.floor(Math.random() * availableSeeds.length)]);
        }
        showToast('‚ö† ALERTA: Iniciando SINGULARIDAD OMEGA (1M Nodos)');
        await loadMultipleSeeds(omegaSeeds);
    }


    // üå∏ MANDALA UNIVERSE (FRACTAL & AUDIO REACTIVE)
    function createMandalaUniverse() {
      if (pointsCloud) scene.remove(pointsCloud);
      if (centralSingularity) {
        scene.remove(centralSingularity);
        centralSingularity.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        centralSingularity = null;
      }

      const particleCount = 50000;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const layerIndices = new Float32Array(particleCount);
      const scales = new Float32Array(particleCount); // New: para lerp smooth

      const layers = 12;
      let particleIdx = 0;

      for(let l = 0; l < layers; l++) {
        const layerCount = Math.floor(particleCount / layers);
        const radius = 200 + (l * 150);

        for(let i = 0; i < layerCount; i++) {
          if (particleIdx >= particleCount) break;

          const theta = i * 2.39996;
          const phi = Math.acos(1 - 2 * (i + 0.5) / layerCount);

          const x = radius * Math.sin(phi) * Math.cos(theta);
          const y = radius * Math.sin(phi) * Math.sin(theta);
          const z = radius * Math.cos(phi);

          positions[particleIdx * 3] = x;
          positions[particleIdx * 3 + 1] = y;
          positions[particleIdx * 3 + 2] = z;

          const color = new THREE.Color().setHSL(l / layers, 1.0, 0.5);
          colors[particleIdx * 3] = color.r;
          colors[particleIdx * 3 + 1] = color.g;
          colors[particleIdx * 3 + 2] = color.b;

          layerIndices[particleIdx] = l;
          scales[particleIdx] = 1.0; // Init scale

          particleIdx++;
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      geometry.userData.originalPositions = positions.slice();
      geometry.userData.layerIndices = layerIndices;
      geometry.userData.scales = scales;
      geometry.userData.originalColors = colors.slice(); // Fix for redshift simulation

      pointsCloud = new THREE.Points(
        geometry,
        new THREE.PointsMaterial({
          size: 2, // Optimized for 50k nodes
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending
        })
      );

      pointsCloud.userData.isMandala = true;
      scene.add(pointsCloud);
      showToast('üå∏ UNIVERSO MANDALA ACTIVADO');
    }

    function resetCamera() {
      if (camera && controls) {
        camera.position.set(0, 500, 1500);
        controls.target.set(0, 0, 0);
        velocity.set(0, 0, 0);
        controls.update();
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - FULL MESH INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üü¢ MATRIX MODE - SAFEGUARDED INTERCONNECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createMatrixLines() {
      if (!pointsCloud || !scene) return;
      
      removeMatrixLines(); 
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const nodeCount = positions.length / 3;
      
      const linePositions = [];
      const MAX_TOTAL_LINES = 300000; // Hard limit for WebGL buffer safety
      
      // Smart Logic: If too many nodes, use K-Nearest or Random Neighbors instead of Full Mesh
      if (nodeCount > 800) { 
        // Optimization for large datasets (O(N*K))
        console.warn('‚ö° High node count detected. Optimizing Matrix connections (Nearest Neighbors)...');
        
        for (let i = 0; i < nodeCount; i++) {
           // Connect to 5 random neighbors instead of everyone
           // (Approximation of "Matrix" look without O(N^2))
           for (let k = 0; k < 6; k++) {
              if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
              
              const j = Math.floor(Math.random() * nodeCount);
              if (i === j) continue;
              
              // Only connect if somewhat close (optional, but pure random is chaotic enough for noise)
              // To make it look structured, we could check distance, but that is expensive.
              // Fast alternative: Spatial hashing or just simple random for visual "noise".
              
              linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
           }
        }
      } else {
         // Full Mesh for small datasets
         for (let i = 0; i < nodeCount; i++) {
            for (let j = i + 1; j < nodeCount; j++) {
               if (linePositions.length / 6 >= MAX_TOTAL_LINES) break;
               linePositions.push(
                positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2],
                positions[j * 3], positions[j * 3 + 1], positions[j * 3 + 2]
              );
            }
         }
      }
      
      const lineGeometry = new THREE.BufferGeometry();
      lineGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(linePositions), 3));
      
      const lineMaterial = new THREE.LineBasicMaterial({
        color: matrixColor,
        opacity: matrixOpacity,
        transparent: true,
        linewidth: 1
      });
      
      matrixLines = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(matrixLines);
      
      console.log(`üü¢ MATRIX MODE SAFE: ${nodeCount} nodes, ${linePositions.length / 6} lines`);
    }

    // ... (removeMatrixLines, updateMatrixColor, etc. remain the same, ensure they are kept or I will break them if I overwrite)
    function removeMatrixLines() {
      if (matrixLines && scene) {
        scene.remove(matrixLines);
        if(matrixLines.geometry) matrixLines.geometry.dispose();
        if(matrixLines.material) matrixLines.material.dispose();
        matrixLines = null;
      }
    }
    
    function updateMatrixColor() { if (matrixLines && matrixLines.material) matrixLines.material.color.setHex(matrixColor); }
    function updateMatrixOpacity() { if (matrixLines && matrixLines.material) matrixLines.material.opacity = matrixOpacity; }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üåå NEW UNIVERSES (Laser, Bubble, Laniakea)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. LASER UNIVERSE (Grid / Linear Energy)
    function createLaserUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
             // Grid distribution
             const range = 2000;
             if (i < particleCount * 0.8) {
                 // PLANES
                 positions[i*3] = (Math.random() - 0.5) * range;
                 positions[i*3+1] = (Math.floor(Math.random() * 10) - 5) * 200; // Quantized Y layers
                 positions[i*3+2] = (Math.random() - 0.5) * range;
             } else {
                 // BEAMS (Vertical)
                 positions[i*3] = (Math.floor(Math.random() * 20) - 10) * 200;
                 positions[i*3+1] = (Math.random() - 0.5) * range;
                 positions[i*3+2] = (Math.floor(Math.random() * 20) - 10) * 200;
             }
             
             // NEON COLORS (Red/Blue/Laser)
             const color = new THREE.Color();
             Math.random() > 0.5 ? color.setHex(0xff0055) : color.setHex(0x0055ff);
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, blending: THREE.AdditiveBlending }));
        scene.add(pointsCloud);
        showToast('‚ö° UNIVERSO LASER ACTIVADO');
    }

    // 2. BUBBLE UNIVERSE (Multiverse Foam)
    function createBubbleUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        const bubbleCenters = [];
        for(let j=0; j<50; j++) bubbleCenters.push({
            x: (Math.random()-0.5)*3000, 
            y: (Math.random()-0.5)*3000, 
            z: (Math.random()-0.5)*3000, 
            r: 100 + Math.random()*300
        });

        for (let i = 0; i < particleCount; i++) {
             const bubble = bubbleCenters[Math.floor(Math.random() * bubbleCenters.length)];
             
             // Surface of sphere
             const theta = Math.random() * Math.PI * 2;
             const phi = Math.acos(2 * Math.random() - 1);
             
             const x = bubble.x + bubble.r * Math.sin(phi) * Math.cos(theta);
             const y = bubble.y + bubble.r * Math.sin(phi) * Math.sin(theta);
             const z = bubble.z + bubble.r * Math.cos(phi);
             
             positions[i*3] = x;
             positions[i*3+1] = y;
             positions[i*3+2] = z;
             
             const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6); // Rainbow bubbles
             colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent:true, opacity:0.6 }));
        scene.add(pointsCloud);
        showToast('üõÅ UNIVERSO BURBUJA ACTIVADO');
    }

    // 3. LANIAKEA UNIVERSE (Cosmic Web / Filaments)
    function createLaniakeaUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        // Laniakea has a Great Attractor! Keep Singularity but make it Golden
        if (!centralSingularity) {
            centralSingularity = createGargantuaSingularity();
            scene.add(centralSingularity);
        }
        
        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        // Simulating filaments using strange Attractors or Perlin noise curves
        // Simplified: Multiple sine waves paths
        
        for (let i = 0; i < particleCount; i++) {
            const t = Math.random() * 100; // path pos
            const filamentIdx = Math.floor(Math.random() * 20); // 20 main filaments
            
            // Parametric curves spiraling into center
            const angle = t * 0.1 + (filamentIdx * (Math.PI*2/20));
            const radius = t * 20 + 200; // expanding out
            const height = Math.sin(t * 0.5) * 500 * (Math.random()-0.5);
            
            // Add noise
            const spread = 50 + t;
            
            positions[i*3] = Math.cos(angle) * radius + (Math.random()-0.5)*spread;
            positions[i*3+1] = height + (Math.random()-0.5)*spread;
            positions[i*3+2] = Math.sin(angle) * radius + (Math.random()-0.5)*spread;
            
            // Golden / White colors
            const color = new THREE.Color().setHSL(0.1 + Math.random()*0.1, 0.8, 0.6); // Gold/Orange
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        pointsCloud = new THREE.Points(geometry, new THREE.PointsMaterial({ size: 2, vertexColors: true }));
        scene.add(pointsCloud);
        showToast('üåå LANIAKEA SUPERCLUSTER DETECTADO');
    }

    // 4. NEGATIVE RGB LIGHT UNIVERSE (Operates -255 to 0)
    function createNegativeRGBUniverse() {
        if (pointsCloud) scene.remove(pointsCloud);
        if (centralSingularity) {
          scene.remove(centralSingularity);
          centralSingularity.traverse(obj => {
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) obj.material.dispose();
          });
          centralSingularity = null;
        }

        const particleCount = 50000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        let idx = 0;
        
        // Explicit logic: "Desde lo negativo -255 hasta 0"
        // We will generate particles in batches mapping this negative range to position/color
        
        const range = 5000;
        
        for (let n = -255; n <= 0; n += 0.005) { // Updated for 50k nodes
            if(idx >= particleCount) break;
            
            // Negative Math for Position: (-255 to 0)
            // Map -255..0 to Space
            // Use random distribution but influenced by 'n'
            
            // Burst in all directions
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            // Radius depends on 'n' (inverted: -255 is CORE, 0 is EDGE)
            // n goes -255 -> 0. 
            // Normalized: (255 - abs(n)) / 255 => 0 to 1
            const rNorm = (255 - Math.abs(n)) / 255; 
            const r = rNorm * 2000; 

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            positions[idx*3] = x;
            positions[idx*3+1] = y;
            positions[idx*3+2] = z;
            
            // COLOR LOGIC: "RGB es facil 0 255 pero desde lo negativo -255 hasta 0"
            // Interpreted: Value = n + 255.
            // If n = -255, val = 0 (Black/Core).
            // If n = 0, val = 255 (Max Color).
            
            // R, G, B channels vary with different "negative frequencies"
            const rVal = 255 + (Math.random() > 0.5 ? n : -255); // Mix
            const gVal = 255 + (n); 
            const bVal = 255 + (Math.sin(n)*255 - 255)/2; // Oscillate
            
            const color = new THREE.Color(
                Math.max(0, rVal + Math.random()*50)/255, 
                Math.max(0, gVal + Math.random()*50)/255,
                Math.max(0, bVal + Math.random()*50)/255
            );
            
            colors[idx*3] = color.r;
            colors[idx*3+1] = color.g;
            colors[idx*3+2] = color.b;
            
            idx++;
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.userData.originalColors = colors.slice();
        
        // Additive Blending for "Light"
        pointsCloud = new THREE.Points(
            geometry, 
            new THREE.PointsMaterial({ 
                size: 2, // Optimized for 50k nodes
                vertexColors: true, 
                blending: THREE.AdditiveBlending, 
                transparent: true, 
                opacity: 0.8 
            })
        );
        scene.add(pointsCloud);
        showToast('üí° UNIVERSO LUZ RGB NEGATIVA ACTIVADO');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üìà SINE WAVE ANALYSIS (Real-Time Graph)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    let sineCanvas, sineCtx;
    
    function initSineGraph() {
        sineCanvas = document.createElement('canvas');
        sineCanvas.id = 'sine-graph';
        sineCanvas.width = 400;
        sineCanvas.height = 100;
        sineCanvas.style.cssText = `
            position: fixed;
            bottom: 80px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid var(--text-cyan);
            border-radius: 8px;
            z-index: 50;
            pointer-events: none;
        `;
        document.body.appendChild(sineCanvas);
        sineCtx = sineCanvas.getContext('2d');
        
        // Add Label
        const label = document.createElement('div');
        label.innerText = 'REAL-TIME DATA SINE ANALYSIS';
        label.style.cssText = `
            position: fixed;
            bottom: 185px;
            left: 20px;
            color: var(--text-cyan);
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 51;
        `;
        document.body.appendChild(label);
        
        updateSineGraph();
    }
    
    function updateSineGraph() {
        requestAnimationFrame(updateSineGraph);
        if(!sineCtx || !sineCanvas) return;
        
        sineCtx.fillStyle = 'rgba(0,0,0,0.2)'; // Fade effect
        sineCtx.fillRect(0,0, sineCanvas.width, sineCanvas.height);
        
        const t = Date.now() * 0.002;
        
        // Data sources: Audio, Time, Position, Entropy (Random)
        // We mix "Greatest Amount of Data" -> 3-4 Waves overlay
        
        // 1. Audio / Energy Wave (Red/Magenta)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ff00ff';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
            const y = 50 + Math.sin(x*0.05 + t*2) * 20 * (isFiestaMode ? 1.5 : 0.5);
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 2. Cosmic Entropy (Cyan - High Fast)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#00ffff';
        sineCtx.lineWidth = 1;
        for(let x=0; x<sineCanvas.width; x++) {
            // Complex Harmonics
            const y = 50 + Math.sin(x*0.1 - t*3) * 15 + Math.cos(x*0.3 + t) * 5;
            sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
        
        // 3. Gravity/Mass (Yellow - Slow Heavy)
        sineCtx.beginPath();
        sineCtx.strokeStyle = '#ffff00';
        sineCtx.lineWidth = 2;
        for(let x=0; x<sineCanvas.width; x++) {
             const y = 50 + Math.sin(x*0.02 + t*0.5) * 30;
             if(x===0) sineCtx.moveTo(x,y); else sineCtx.lineTo(x, y);
        }
        sineCtx.stroke();
    }

    // Call initSineGraph in initEngine logic (later)

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öõÔ∏è ION CHANNELS (CONCENTRIC CONNECTIONS)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function createIonChannels() {
      if (!pointsCloud || !scene) return;
      removeIonChannels();

      const positions = pointsCloud.geometry.attributes.position.array;
      const count = positions.length / 3;
      
      // 1. DENSE ION LINES (The "Highways")
      const connections = [];
      const shells = {}; 
      
      for(let i=0; i<count; i++) {
         const x = positions[i*3];
         const y = positions[i*3+1];
         const z = positions[i*3+2];
         const dist = Math.sqrt(x*x + y*y + z*z);
         const shellIdx = Math.floor(dist / 150); // Smaller shells = More layers
         
         if(!shells[shellIdx]) shells[shellIdx] = [];
         shells[shellIdx].push(i);
      }
      
      // Connect nodes within shells
      const shellKeys = Object.keys(shells);
      for(let k = 0; k < shellKeys.length; k++) {
        const shellKey = shellKeys[k];
        const indices = shells[shellKey];
        // COMPLEXITY CAP: Limit connections per shell to avoid O(n^2) web
        const limit = Math.min(indices.length, 300); 
        
        for(let i=0; i<limit; i++) {
           const idxA = indices[i];
           const idxB = indices[(i+1) % limit];
           const idxC = indices[(i+2) % limit];
           
           const ax = positions[idxA*3], ay = positions[idxA*3+1], az = positions[idxA*3+2];
           const bx = positions[idxB*3], by = positions[idxB*3+1], bz = positions[idxB*3+2];
           const cx = positions[idxC*3], cy = positions[idxC*3+1], cz = positions[idxC*3+2];
           
           connections.push(ax, ay, az, bx, by, bz);
           connections.push(ax, ay, az, cx, cy, cz);
        }
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(connections), 3));
      
      const material = new THREE.LineBasicMaterial({
        color: 0x00ffff, 
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending
      });
      
      ionLines = new THREE.LineSegments(geometry, material);
      ionLines.userData.isIon = true;
      scene.add(ionLines);


      // 2. ORBITAL ION FLOW (The "Traffic")
      // Particles that will rotate physically to simulate flow along the shells
      const ionCount = 15000;
      const ionPos = new Float32Array(ionCount * 3);
      const ionSizes = new Float32Array(ionCount);
      
      for(let i=0; i<ionCount; i++) {
          // Spawn on existing shells
          const shellKeys = Object.keys(shells);
          const rKey = shellKeys[Math.floor(Math.random() * shellKeys.length)];
          const nodesInShell = shells[rKey];
          if(!nodesInShell) continue;
          
          // Pick a random node as base
          const nodeIdx = nodesInShell[Math.floor(Math.random() * nodesInShell.length)];
          const px = positions[nodeIdx*3];
          const py = positions[nodeIdx*3+1];
          const pz = positions[nodeIdx*3+2];
          
          // Add random spread to create a "Cloud" around the shell highway
          ionPos[i*3] = px + (Math.random()-0.5)*50;
          ionPos[i*3+1] = py + (Math.random()-0.5)*10; // Flat spread
          ionPos[i*3+2] = pz + (Math.random()-0.5)*50;
          
          ionSizes[i] = Math.random() * 3;
      }
      
      const ionGeo = new THREE.BufferGeometry();
      ionGeo.setAttribute('position', new THREE.BufferAttribute(ionPos, 3));
      ionGeo.setAttribute('size', new THREE.BufferAttribute(ionSizes, 1)); // Custom attribute if shader supported, else ignored or mapped
      
      const ionMat = new THREE.PointsMaterial({
          color: 0x00ffff,
          size: 2,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
      });
      
      orbitalIons = new THREE.Points(ionGeo, ionMat);
      scene.add(orbitalIons);

      console.log(`‚öõÔ∏è ORBITAL SYSTEM CREATED: ${connections.length/6} lines + ${ionCount} flowing ions`);
    }

    function removeIonChannels() {
      if (ionLines && scene) {
        scene.remove(ionLines);
        ionLines.geometry?.dispose();
        ionLines.material?.dispose();
        ionLines = null;
      }
      if (orbitalIons && scene) {
        scene.remove(orbitalIons);
        orbitalIons.geometry?.dispose();
        orbitalIons.material?.dispose();
        orbitalIons = null;
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚è±Ô∏è TEMPORAL SPEED CONTROL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function setSpeed(speed) {
      timeSpeed = speed;
      isPaused = (speed === 0);
      
      // Update displays
      const display = document.getElementById('speed-display');
      const sliderDisplay = document.getElementById('speedSliderDisplay');
      const slider = document.getElementById('speedSlider');
      
      if (display) {
        if (isPaused) {
          display.textContent = '‚è∏ PAUSED';
          display.style.color = 'var(--text-red)';
        } else if (speed < 0) {
          display.textContent = `‚óÄ ${speed}x`;
          display.style.color = 'var(--text-magenta)';
        } else {
          display.textContent = `‚ñ∂ ${speed}x`;
          display.style.color = 'var(--text-cyan)';
        }
      }
      
      if (sliderDisplay) sliderDisplay.textContent = speed.toFixed(1);
      if (slider) slider.value = speed;
      
      // Highlight active button
      document.querySelectorAll('.temporal-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      console.log(`‚è±Ô∏è Velocidad: ${isPaused ? 'PAUSED' : speed + 'x'}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üß≠ QUICK NAVIGATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function goToSingularity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 200,
        y: 100,
        z: 200,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üåå Llegaste a la Singularidad');
        }
      });
    }

    function escapeGravity() {
      if (!camera) return;
      
      gsap.to(camera.position, {
        x: 5000,
        y: 3000,
        z: 5000,
        duration: 3,
        ease: 'power2.out',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üöÄ Escapaste de la gravedad');
        }
      });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üé® MATRIX COLOR CONTROL (NUEVO)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    function setMatrixColor(hexColor) {
      // Convertir hex a n√∫mero para THREE.js
      matrixColor = parseInt(hexColor.replace('#', '0x'), 16);
      
      // Actualizar el color picker visual
      const picker = document.getElementById('matrixColorPicker');
      if (picker) picker.value = hexColor;
      
      // Actualizar matriz si est√° activa
      if (matrixLines) {
        matrixLines.material.color.setHex(matrixColor);
        matrixLines.material.needsUpdate = true;
      }
      
      // Notificar al usuario
      const colorName = {
        '#00ff41': 'Verde Matrix',
        '#00ffff': 'Cyan',
        '#ff00ff': 'Magenta',
        '#ffff00': 'Amarillo',
        '#ff0033': 'Rojo',
        '#ff6600': 'Naranja',
        '#9900ff': 'P√∫rpura',
        '#ffffff': 'Blanco'
      }[hexColor] || 'Personalizado';
      
      showToast(`üé® Matrix: ${colorName}`);
      console.log(`üé® Matrix color changed to: ${hexColor} (${matrixColor})`);
    }

    function goToNearestNode() {
      if (!pointsCloud || !camera) return;
      
      const positions = pointsCloud.geometry.attributes.position.array;
      const camPos = camera.position;
      
      let nearestDist = Infinity;
      let nearestPos = null;
      
      for (let i = 0; i < positions.length; i += 3) {
        const x = positions[i];
        const y = positions[i + 1];
        const z = positions[i + 2];
        
        const dist = Math.sqrt(
          Math.pow(x - camPos.x, 2) +
          Math.pow(y - camPos.y, 2) +
          Math.pow(z - camPos.z, 2)
        );
        
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestPos = { x, y, z };
        }
      }
      
      if (nearestPos) {
        const direction = new THREE.Vector3(
          camPos.x - nearestPos.x,
          camPos.y - nearestPos.y,
          camPos.z - nearestPos.z
        ).normalize();
        
        const targetPos = {
          x: nearestPos.x + direction.x * 100,
          y: nearestPos.y + direction.y * 100,
          z: nearestPos.z + direction.z * 100
        };
        
        gsap.to(camera.position, {
          x: targetPos.x,
          y: targetPos.y,
          z: targetPos.z,
          duration: 1.5,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(nearestPos.x, nearestPos.y, nearestPos.z);
            controls.update();
          },
          onComplete: () => {
            showToast('üéØ Nodo m√°s cercano alcanzado');
          }
        });
      }
    }

    function goToRandomPosition() {
      if (!camera) return;
      
      const randomPos = {
        x: (Math.random() - 0.5) * 4000,
        y: (Math.random() - 0.5) * 2000,
        z: (Math.random() - 0.5) * 4000
      };
      
      gsap.to(camera.position, {
        x: randomPos.x,
        y: randomPos.y,
        z: randomPos.z,
        duration: 2,
        ease: 'power2.inOut',
        onUpdate: () => {
          controls.target.set(0, 0, 0);
          controls.update();
        },
        onComplete: () => {
          showToast('üé≤ Posici√≥n aleatoria');
        }
      });
    }

    function toggleImmersionMode() {
      isImmersionMode = !isImmersionMode;
      document.body.style.cursor = isImmersionMode ? 'none' : 'default';
      
      const hud = document.querySelector('.hud-module');
      const toggle = document.querySelector('.immersion-toggle');
      const temporalControls = document.getElementById('temporal-controls');
      
      if (hud) hud.style.display = isImmersionMode ? 'none' : 'block';
      
      // Toggle siempre visible, solo cambia opacidad
      if (toggle) {
        toggle.style.opacity = isImmersionMode ? '0.5' : '1';
        toggle.textContent = isImmersionMode ? 'Exit Immersion [H]' : 'Immersion [H]';
      }
      
      // CRITICAL: Disable OrbitControls in immersive mode
      if (controls) {
        controls.enabled = !isImmersionMode;
      }
      
      // Temporal controls SOLO en modo inmersivo
      if (temporalControls) {
        temporalControls.style.display = isImmersionMode ? 'block' : 'none';
      }
      
      // üåå ZOOM OUT AL ENTRAR EN MODO INMERSIVO
      if (isImmersionMode && camera) {
        // Guardar posici√≥n actual
        const currentPos = camera.position.clone();
        
        // Calcular punto m√°s lejano visible (vista panor√°mica)
        const farDistance = 3000; // Distancia lejana
        const direction = new THREE.Vector3(1, 1, 1).normalize(); // Diagonal
        const farPos = direction.multiplyScalar(farDistance);
        
        // Animar c√°mara hacia posici√≥n lejana
        gsap.to(camera.position, {
          x: farPos.x,
          y: farPos.y,
          z: farPos.z,
          duration: 2,
          ease: 'power2.inOut',
          onUpdate: () => {
            controls.target.set(0, 0, 0); // Mirar al centro
            controls.update();
          },
          onComplete: () => {
            console.log('üåå Vista panor√°mica activada - Listo para explorar');
          }
        });
      }
      
      console.log(isImmersionMode ? 'üåå IMMERSION ON - Temporal controls habilitados' : 'üåå IMMERSION OFF');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üñ±Ô∏è INTERACTION & RAYCASTING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    
    // Expand/Fly to Node
    function onDocumentMouseClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        if (!camera || !mouse) return;
        raycaster.setFromCamera(mouse, camera);
        
        // 1. Check Singularity
        if (centralSingularity) {
            const intersectsSingularity = raycaster.intersectObjects(centralSingularity.children);
            if (intersectsSingularity.length > 0) {
                goToSingularity();
                return;
            }
        }
        
        // 2. Check Nodes
        if (pointsCloud) {
            // Threshold for points (hitbox)
            raycaster.params.Points.threshold = 15; 
            const intersects = raycaster.intersectObject(pointsCloud);
            
            if (intersects.length > 0) {
                const index = intersects[0].index;
                const pos = pointsCloud.geometry.attributes.position;
                
                const targetPos = {
                    x: pos.getX(index),
                    y: pos.getY(index),
                    z: pos.getZ(index)
                };
                
                // "THE FORMULA TO EXPAND" interaction
                // 1. Fly to it
                flyToPosition(targetPos);
                
                // 2. Expand/Highlight (Pulse effect)
                highlightNode(index);
                
                showToast(`üî≠ Nodo #${index} Analizado`);
            }
        }
    }
    
    function flyToPosition(target) {
        if (!camera) return;
        
        // Offset to stop before hitting it
        const offset = 100;
        // Direction from current cam to target
        const direction = new THREE.Vector3(target.x - camera.position.x, target.y - camera.position.y, target.z - camera.position.z).normalize();
        
        const finalPos = {
            x: target.x - direction.x * offset,
            y: target.y - direction.y * offset,
            z: target.z - direction.z * offset
        };

        gsap.to(camera.position, {
            x: finalPos.x,
            y: finalPos.y,
            z: finalPos.z,
            duration: 1.5,
            ease: "power2.inOut",
            onUpdate: () => {
                controls.target.set(target.x, target.y, target.z);
                controls.update();
            }
        });
    }
    
    function highlightNode(index) {
        if (!pointsCloud || !pointsCloud.geometry || !pointsCloud.geometry.attributes.position) return;
        
        const pos = pointsCloud.geometry.attributes.position;
        const x = pos.getX(index);
        const y = pos.getY(index);
        const z = pos.getZ(index);
        
        const glowGeo = new THREE.SphereGeometry(2, 32, 32);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
        const glowMesh = new THREE.Mesh(glowGeo, glowMat);
        glowMesh.position.set(x, y, z);
        scene.add(glowMesh);
        
        // Animate Expansion "Explosion"
        gsap.to(glowMesh.scale, { x: 20, y: 20, z: 20, duration: 0.5, ease: "back.out(1.7)" });
        gsap.to(glowMesh.material, { opacity: 0, duration: 0.5, onComplete: () => scene.remove(glowMesh) });
    }

    window.addEventListener('click', onDocumentMouseClick, false);

    // Event listeners (se ejecutan despu√©s de cargar DOM)
    document.addEventListener('DOMContentLoaded', () => {
      // Sliders
      // Sliders with Debounce
      let pendingSliderUpdate = false;
      document.getElementById('nodeSlider')?.addEventListener('input', e => {
        const val = e.target.value;
        const display = document.getElementById('nodeDisplay');
        if (display) display.textContent = parseInt(val).toLocaleString();
        
        if (!pendingSliderUpdate) {
            pendingSliderUpdate = true;
            requestAnimationFrame(() => {
                pendingSliderUpdate = false;
            });
        }
      });
      
      // Regenerate on release
      document.getElementById('nodeSlider')?.addEventListener('change', () => {
         const btn = document.createElement('div'); 
         // Toast or simple reload
         showToast('üîÑ Regenerando universo con nueva capacidad...');
         loadUniverse(currentUniverseSeed);
      });
      document.getElementById('seedSlider')?.addEventListener('input', e => {
        if (document.getElementById('seedDisplay')) document.getElementById('seedDisplay').textContent = e.target.value;
      });

      // Matrix Mode Toggle
      document.getElementById('matrixMode')?.addEventListener('change', e => {
        matrixModeActive = e.target.checked;
        const controls = document.getElementById('matrixControls');
        if (controls) controls.style.display = matrixModeActive ? 'block' : 'none';
        
        if (matrixModeActive) {
          createMatrixLines();
        } else {
          removeMatrixLines();
        }
      });

      // Matrix Color Preset
      document.getElementById('matrixColorPreset')?.addEventListener('change', e => {
        const customGroup = document.getElementById('customColorGroup');
        if (e.target.value === 'custom') {
          customGroup.style.display = 'block';
          const picker = document.getElementById('matrixColorPicker');
          matrixColor = parseInt(picker.value.replace('#', '0x'));
        } else {
          customGroup.style.display = 'none';
          matrixColor = parseInt(e.target.value.replace('#', '0x'));
        }
        updateMatrixColor();
      });

      // Fiesta Mode Toggle
      document.getElementById('fiestaMode')?.addEventListener('change', e => {
        isFiestaMode = e.target.checked;
        if (isFiestaMode) {
          initAudio();
          // Solo auto-clic Matrix si estamos en el modo Orbitador por defecto
          const currentViz = document.getElementById('vizMode')?.value;
          if (currentViz === 'ORBITAL' && !matrixModeActive) {
            document.getElementById('matrixMode').click();
          }
        }
      });

      // Matrix Custom Color Picker
      document.getElementById('matrixColorPicker')?.addEventListener('input', e => {
        matrixColor = parseInt(e.target.value.replace('#', '0x'));
        updateMatrixColor();
      });

      // Matrix Opacity
      document.getElementById('matrixOpacity')?.addEventListener('input', e => {
        matrixOpacity = parseFloat(e.target.value);
        document.getElementById('matrixOpacityDisplay').textContent = matrixOpacity;
        updateMatrixOpacity();
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚è±Ô∏è TEMPORAL CONTROLS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      document.getElementById('speedSlider')?.addEventListener('input', e => {
        const speed = parseFloat(e.target.value);
        setSpeed(speed);
      });

      // Teclado con controles configurables
      document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional (WASD)
        if (k === keyBindings.forward) moveState.forward = 1;
        if (k === keyBindings.back) moveState.back = 1;
        if (k === keyBindings.left) moveState.left = 1;
        if (k === keyBindings.right) moveState.right = 1;
        if (k === keyBindings.up) moveState.up = 1;
        if (k === keyBindings.down) moveState.down = 1;
        
        // Rotaci√≥n de c√°mara (Flechas)
        if (k === 'arrowleft') moveState.rotateLeft = 1;
        if (k === 'arrowright') moveState.rotateRight = 1;
        if (k === 'arrowup') moveState.rotateUp = 1;
        if (k === 'arrowdown') moveState.rotateDown = 1;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 2.0;
          acceleration = 9.0;
          maxSpeed = 90;
        }
        
        // Acciones
        if (k === keyBindings.immersion || k === 'l') toggleImmersionMode();
        if (k === keyBindings.resetCamera) resetCamera();
        if (k === '?' || k === '/') openTutorial();
      });

      document.addEventListener('keyup', e => {
        const k = e.key.toLowerCase();
        
        // Movimiento direccional
        if (k === keyBindings.forward) moveState.forward = 0;
        if (k === keyBindings.back) moveState.back = 0;
        if (k === keyBindings.left) moveState.left = 0;
        if (k === keyBindings.right) moveState.right = 0;
        if (k === keyBindings.up) moveState.up = 0;
        if (k === keyBindings.down) moveState.down = 0;
        
        // Rotaci√≥n de c√°mara
        if (k === 'arrowleft') moveState.rotateLeft = 0;
        if (k === 'arrowright') moveState.rotateRight = 0;
        if (k === 'arrowup') moveState.rotateUp = 0;
        if (k === 'arrowdown') moveState.rotateDown = 0;
        
        // Speed boost
        if (k === keyBindings.speedBoost) {
          speedBoost = 1.0;
          acceleration = 4.5;
          maxSpeed = 45;
        }
      });

      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéÆ GAMEPAD / JOYSTICK SUPPORT
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      let gamepadConnected = false;
      let gamepadIndex = null;

      window.addEventListener('gamepadconnected', (e) => {
        gamepadConnected = true;
        gamepadIndex = e.gamepad.index;
        console.log(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
        showToast(`üéÆ Gamepad conectado: ${e.gamepad.id}`);
      });

      window.addEventListener('gamepaddisconnected', (e) => {
        gamepadConnected = false;
        gamepadIndex = null;
        console.log('üéÆ Gamepad desconectado');
      });

      function updateGamepad() {
        if (!gamepadConnected || gamepadIndex === null) return;

        const gamepads = navigator.getGamepads();
        const gamepad = gamepads[gamepadIndex];
        if (!gamepad) return;

        // Stick izquierdo: Movimiento horizontal/vertical
        const leftX = gamepad.axes[0]; // -1 (izq) a +1 (der)
        const leftY = gamepad.axes[1]; // -1 (arriba) a +1 (abajo)

        // Stick derecho: Rotaci√≥n c√°mara
        const rightX = gamepad.axes[2];
        const rightY = gamepad.axes[3];

        // Deadzone para evitar drift
        const deadzone = 0.15;

        // Movimiento con stick izquierdo
        if (Math.abs(leftX) > deadzone) {
          moveState.left = leftX < 0 ? -leftX : 0;
          moveState.right = leftX > 0 ? leftX : 0;
        } else {
          moveState.left = 0;
          moveState.right = 0;
        }

        if (Math.abs(leftY) > deadzone) {
          moveState.forward = leftY < 0 ? -leftY : 0;
          moveState.back = leftY > 0 ? leftY : 0;
        } else {
          moveState.forward = 0;
          moveState.back = 0;
        }

        // Gatillos: Subir/Bajar
        const lt = gamepad.buttons[6]?.value || 0; // L2/LT
        const rt = gamepad.buttons[7]?.value || 0; // R2/RT
        moveState.down = lt;
        moveState.up = rt;

        // Botones de acci√≥n
        if (gamepad.buttons[0]?.pressed) { // A/X - Reset camera
          resetCamera();
        }
        if (gamepad.buttons[1]?.pressed) { // B/Circle - Toggle immersion
          toggleImmersionMode();
        }
        if (gamepad.buttons[2]?.pressed) { // X/Square - CAOS
          invokeCaos();
        }
        if (gamepad.buttons[3]?.pressed) { // Y/Triangle - Matrix toggle
          const matrixCheckbox = document.getElementById('matrixMode');
          if (matrixCheckbox) matrixCheckbox.click();
        }
      }

      // Llamar updateGamepad en cada frame
      function gamepadLoop() {
        updateGamepad();
        requestAnimationFrame(gamepadLoop);
      }
      gamepadLoop();

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚öôÔ∏è SETTINGS PANEL FUNCTIONS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

      function openSettings() {
        document.getElementById('settings-panel').style.display = 'flex';
        updateKeyBindingsUI();
      }

      function closeSettings() {
        document.getElementById('settings-panel').style.display = 'none';
        saveKeyBindings();
      }

      function openTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'flex';
      }

      function closeTutorial() {
        document.getElementById('tutorial-overlay').style.display = 'none';
      }

      function updateKeyBindingsUI() {
        const container = document.getElementById('key-bindings-list');
        const labels = {
          forward: 'Adelante',
          back: 'Atr√°s',
          left: 'Izquierda',
          right: 'Derecha',
          up: 'Subir',
          down: 'Bajar',
          rotateLeft: 'Rotar Izq',
          rotateRight: 'Rotar Der',
          speedBoost: 'Speed Boost',
          immersion: 'Immersion',
          resetCamera: 'Reset C√°mara'
        };

        container.innerHTML = '';
        for (const [action, key] of Object.entries(keyBindings)) {
          const div = document.createElement('div');
          div.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(0,242,255,0.05);border:1px solid var(--glass-border);border-radius:4px;';
          div.innerHTML = `
            <span style="color:#888;">${labels[action] || action}</span>
            <button onclick="rebindKey('${action}')" style="width:auto;padding:5px 15px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);text-transform:uppercase;">
              ${keyBindings[action] === ' ' ? 'SPACE' : keyBindings[action].toUpperCase()}
            </button>
          `;
          container.appendChild(div);
        }
      }

      let rebindingAction = null;

      function rebindKey(action) {
        rebindingAction = action;
        showToast('‚å®Ô∏è Presiona la nueva tecla para ' + action, 5000);
        
        const listener = (e) => {
          e.preventDefault();
          const newKey = e.key.toLowerCase();
          keyBindings[action] = newKey;
          updateKeyBindingsUI();
          rebindingAction = null;
          document.removeEventListener('keydown', listener);
          showToast(`‚úÖ ${action} ‚Üí ${newKey === ' ' ? 'SPACE' : newKey.toUpperCase()}`);
        };
        
        document.addEventListener('keydown', listener);
      }

      // Toast notification helper
      function showToast(message, duration = 3000) {
        const toast = document.createElement('div');
        toast.style.cssText = `
          position:fixed; top:80px; right:20px; z-index:10000;
          background:rgba(0,242,255,0.2); border:1px solid var(--text-cyan);
          padding:15px 20px; border-radius:8px; color:var(--text-cyan);
          font-size:0.9rem; pointer-events:none;
          animation: slideIn 0.3s ease-out;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => {
          toast.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      window.addEventListener('resize', () => {
        if (camera) {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
        }
        if (renderer) renderer.setSize(innerWidth, innerHeight);
      });

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üöÄ DOUBLE CLICK TO TRAVEL (Teleport to node/black hole)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Init logic when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
       if (typeof updateKeyBindingsUI === 'function') updateKeyBindingsUI();
       initQuickNavDrag();
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ‚öîÔ∏è RPG ACTION BAR LOGIC & UI INJECTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // 1. Inject CSS
    const actionBarStyle = document.createElement('style');
    actionBarStyle.textContent = `
      #action-bar {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 8px;
        z-index: 10001;
        background: rgba(0, 0, 0, 0.6);
        padding: 5px;
        border: 1px solid var(--glass-border);
        border-radius: 6px;
        backdrop-filter: blur(10px);
      }
      .action-slot {
        width: 50px;
        height: 50px;
        position: relative;
        background: rgba(0, 20, 20, 0.8);
        border: 1px solid #444;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .action-slot:hover {
        border-color: var(--text-cyan);
        box-shadow: 0 0 10px rgba(0,242,255,0.3);
      }
      .action-slot.active {
        background: rgba(0, 242, 255, 0.2);
        border-color: var(--text-magenta);
      }
      .action-key {
        position: absolute;
        top: 2px;
        left: 4px;
        font-size: 0.7rem;
        color: var(--text-yellow);
        font-weight: bold;
      }
      .action-icon {
        font-size: 1.5rem;
      }
    `;
    document.head.appendChild(actionBarStyle);

    // 2. Inject HTML
    // Wait for body to be ready if not already (safeguard)
    if (document.body) {
        injectActionBar();
    } else {
        document.addEventListener('DOMContentLoaded', injectActionBar);
    }

    function injectActionBar() {
        if(document.getElementById('action-bar')) return;
        const bar = document.createElement('div');
        bar.id = 'action-bar';
        bar.innerHTML = `
          <div class="action-slot" onclick="triggerAction('Q')" title="Toggle Matrix">
            <span class="action-key">Q</span>
            <span class="action-icon">üü¢</span>
          </div>
          <div class="action-slot" onclick="triggerAction('W')" title="Toggle Ion Channels">
            <span class="action-key">W</span>
            <span class="action-icon">‚öõÔ∏è</span>
          </div>
          <div class="action-slot" onclick="triggerAction('E')" title="Warp / Fly">
            <span class="action-key">E</span>
            <span class="action-icon">üöÄ</span>
          </div>
          <div class="action-slot" onclick="triggerAction('R')" title="Reset Camera">
            <span class="action-key">R</span>
            <span class="action-icon">üé•</span>
          </div>
          <div class="action-slot" onclick="triggerAction('F')" title="FIESTA MODE (Rainbow)">
            <span class="action-key">F</span>
            <span class="action-icon">üåà</span>
          </div>
        `;
        document.body.appendChild(bar);
    }
    
    // 3. Logic
    const rpgKeyBindings = {
      forward: 'arrowup',
      back: 'arrowdown',
      left: 'arrowleft',
      right: 'arrowright', 
      skill_q: 'q',
      skill_w: 'w',
      skill_e: 'e',
      skill_r: 'r',
      skill_f: 'f',
      up: ' ',
      down: 'shift',
      speedBoost: 'control',
      immersion: 'h',
      resetCamera: 'x'
    };
    
    // Merge RPG bindings into active bindings
    Object.assign(keyBindings, rpgKeyBindings);

    function triggerAction(key) {
       const slot = Array.from(document.querySelectorAll('.action-key')).find(el => el.textContent === key)?.parentElement;
       if(slot) {
           slot.classList.add('active');
           setTimeout(() => slot.classList.remove('active'), 200);
       }
       
       switch(key) {
           case 'Q': 
               const mat = document.getElementById('matrixMode');
               if(mat) mat.click(); 
               showToast('Q: Matrix Toggle');
               break;
           case 'W':
               const ion = document.getElementById('ionChannelsToggle');
               if(ion) ion.click();
               showToast('W: Ion Channels Toggle');
               break;
           case 'E':
               if(centralSingularity) {
                  controls.target.copy(centralSingularity.position);
                  camera.position.set(0, 200, 500); 
                  showToast('E: Warp Core');
               }
               break;
           case 'R':
               resetCamera();
               showToast('R: Camera Reset');
               break;
           case 'F':
               const fiesta = document.getElementById('fiestaMode');
               if(fiesta) {
                   fiesta.click(); // This toggles checked state and fires change event
                   showToast('F: üî• FIESTA MODE TOGGLE üî•');
               }
               break;
       }
    }

    // Init Quick Nav Drag (Preserved)
    function initQuickNavDrag() {
       // ... (rest of function as before)
       const panel = document.getElementById('quick-nav-panel');
       const handle = document.getElementById('quick-nav-handle');
       if (!panel || !handle) return;
       // ... 
       // Only partial replace to keep code short? 
       // No, I must include the full function if I replace the block.
       // I'll assume the original 'initQuickNavDrag' is the target to keep or I put it before closing script.
       
       let isDragging = false;
       let startX, startY, initialLeft, initialTop;

       handle.addEventListener('mousedown', (e) => {
         e.preventDefault();
         isDragging = true;
         startX = e.clientX;
         startY = e.clientY;
         const rect = panel.getBoundingClientRect();
         initialLeft = rect.left;
         initialTop = rect.top;
         panel.style.transform = 'none';
         panel.style.bottom = 'auto';
         panel.style.left = initialLeft + 'px';
         panel.style.top = initialTop + 'px';
         handle.style.cursor = 'grabbing';
       });

       document.addEventListener('mousemove', (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const dx = e.clientX - startX;
         const dy = e.clientY - startY;
         panel.style.left = (initialLeft + dx) + 'px';
         panel.style.top = (initialTop + dy) + 'px';
       });
       
       document.addEventListener('mouseup', () => {
         if (isDragging) {
            isDragging = false;
            handle.style.cursor = 'grab';
         }
       });
    }

    // KEY LISTENER UPDATE for Skills
    document.addEventListener('keydown', e => {
         // ... (existing listeners might conflict if I don't remove them or merge)
         // Since I am replacing the block at end of generic script, I might be outside the main listener scope.
         // Wait, the original code had the listener inside the main script block.
         // I am INJECTING this at the end of the file/script?
         // The `view_file` showed 'initQuickNavDrag' near the end.
         // I will simply add a NEW listener for the Skills to avoid messing with the complex existing one for now,
         // OR I should have modified the `defaultKeyBindings` definition at the top.
         // But I am rewriting `initQuickNavDrag` as anchor.
         
         const k = e.key.toLowerCase();
         if(k === 'q' && !e.repeat) triggerAction('Q');
         if(k === 'w' && !e.repeat) triggerAction('W');
         if(k === 'e' && !e.repeat) triggerAction('E');
         if(k === 'r' && !e.repeat) triggerAction('R');
         if(k === 'f' && !e.repeat) triggerAction('F');
    });
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // üéØ INICIALIZACI√ìN DE SISTEMA DRAGGABLE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Inicializar draggable para todos los paneles cuando el DOM est√© listo
    window.addEventListener('DOMContentLoaded', () => {
      // Restaurar posiciones guardadas
      restorePositions();
      
      // Hacer paneles draggables (usar .hud-title como handle)
      makeDraggable('config-module', '.hud-title');
      makeDraggable('temporal-controls', '.hud-title');
      makeDraggable('quick-nav-panel', '#quick-nav-handle');
      makeDraggable('donation-module'); // Todo el m√≥dulo es draggable
      
      console.log('üéØ Sistema Draggable inicializado');
    });

    
  </script>
</head>
<body>

  <div id="intro-overlay" onclick="enterCosmicOS()">
    <div style="text-align:center">
      <h1 style="color:var(--text-cyan);font-size:4rem;margin:0">COSMIC 11D</h1>
      <p style="color:var(--text-magenta);letter-spacing:6px">BAYESIAN NEGATIVE COMPLEXITY</p>
      <div style="margin-top:30px;color:#555">[ CLICK TO ENTER ]</div>
    </div>
  </div>

  <div id="loading-overlay">SYNCHRONIZING IONIC CHANNELS...</div>

  <div id="canvas-container"></div>

  <!-- Titan Panel - Stats Bar -->
  <div id="titan-panel">
    <div class="titan-stat">
      <span class="titan-stat-label">FPS</span>
      <span id="titan-fps" class="titan-stat-value">60</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Nodes</span>
      <span id="titan-nodes" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Horror</span>
      <span id="titan-horror" class="titan-stat-value">0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Memory</span>
      <span id="titan-memory" class="titan-stat-value">0 MB</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Speed</span>
      <span id="titan-speed" class="titan-stat-value">x1.0</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Mode</span>
      <span id="titan-mode" class="titan-stat-value">LOADING</span>
    </div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Seed</span>
      <span id="titan-seed" class="titan-stat-value">-10</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <div class="titan-stat">
      <span class="titan-stat-label">Dimensions</span>
      <span id="titan-dims" class="titan-stat-value">11D</span>
    </div>
    
    <div class="titan-divider"></div>
    
    <!-- Panel Visibility Controls -->
    <div id="titan-panel-controls">
      <button data-panel="config-module" onclick="togglePanel('config-module')" title="Toggle Neural Config">üß†</button>
      <button data-panel="temporal-controls" onclick="togglePanel('temporal-controls')" title="Toggle Temporal Controls">‚è±Ô∏è</button>
      <button data-panel="quick-nav-panel" onclick="togglePanel('quick-nav-panel')" title="Toggle Quick Navigation">üß≠</button>
      <button data-panel="donation-module" onclick="togglePanel('donation-module')" title="Toggle Donations">üí∞</button>
      <div class="titan-divider"></div>
      <button onclick="resetAllPanels()" title="Restaurar Vista" style="background:rgba(0,255,65,0.2);border-color:var(--text-green);">üîÑ</button>
    </div>
  </div>

  <!-- Seed/Mode Display - Siempre visible -->
  <div style="position:fixed;top:50px;left:20px;z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:10px 15px;pointer-events:none;">
    <div style="font-size:0.7rem;color:#666;margin-bottom:3px;">CURRENT UNIVERSE</div>
    <div style="font-size:1rem;font-weight:bold;">
      <span style="color:var(--text-cyan);">Seed:</span> <span id="current-seed-display" style="color:var(--text-yellow);">-10</span>
    </div>
    <div style="font-size:0.9rem;margin-top:3px;">
      <span style="color:var(--text-magenta);">Mode:</span> <span id="current-mode-display" style="color:var(--text-green);">LOADING...</span>
    </div>
  </div>

  <!-- Sine Wave Visualization (Top Left) -->
  <div id="sine-wave-canvas">
    <canvas id="sine-canvas" width="290" height="140"></canvas>
  </div>

  <div id="config-module" class="hud-module">
    <div class="hud-title">üß† NEURAL CONFIG (11D BIAS)</div>
    <div class="input-group">
      <label>Nodos: <span id="nodeDisplay">50000</span></label>
      <input type="range" id="nodeSlider" min="50" max="1000000" value="50000" step="1000">
    </div>
    <div class="input-group">
      <label>Multi-Seed: <span id="seedDisplay">3</span></label>
      <input type="range" id="seedSlider" min="1" max="100" value="3" step="1">
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
       <button onclick="invokeFusion()" style="background:var(--text-cyan);color:black; padding:8px; font-size:0.75rem;">FUSI√ìN</button>
       <button onclick="invokeSingularityOmega()" style="background:var(--text-red);color:white; padding:8px; font-size:0.75rem;">Œ© OMEGA</button>
    </div>
    <div class="input-group">
      <label>Visualizaci√≥n</label>
      <select id="vizMode">
        <option value="ORBITAL" selected>√ìRBITA MULTI-SEED üåå</option>
        <option value="ENTITY">ENTE VIAJERO üëæ</option>
        <option value="BICAMERAL">CEREBRO BICAMERAL üß†</option>
        <option value="FUSION">FUSI√ìN MULTIVERSAL üß¨</option>
        <option value="MANDALA">UNIVERSO MANDALA üå∏</option>
        <option value="LASER">UNIVERSO LASER ‚ö°</option>
        <option value="BUBBLE">UNIVERSO BURBUJA üõÅ</option>
        <option value="LANIAKEA">SUPERCLUSTER LANIAKEA üåå</option>
        <option value="NEGATIVE_RGB">LUZ RGB NEGATIVA (-255) üí°</option>
      </select>
    </div>
    <div class="input-group">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="ionChannelsToggle" style="width:auto;">
        <span>ION CHANNELS ‚öõÔ∏è</span>
      </label>
    </div>
    <div class="input-group">
      <label>Meta-Tema</label>
      <select id="uxTheme">
        <option value="COSMIC" selected>ABISMO C√ìSMICO üåå</option>
        <option value="MAPUCHE">MAPUCHE-C√ìSMICO üèîÔ∏è</option>
        <option value="CRISTAL">CRISTAL üíé</option>
        <option value="MANDA">MANDALA üåÄ</option>
        <option value="NAVE">NAVE ESPACIAL üöÄ</option>
        <option value="PHOTON">MODO FOT√ìN ‚ö°</option>
        <option value="PARADOX">666 PARADOX üî•</option>
      </select>
    </div>
    <button onclick="invokeCaos()" style="background:var(--text-magenta);color:white">CAOS</button>
    <button onclick="resetCamera()" style="background:#333;color:white">RESET CAM</button>
    
    <div class="input-group" style="margin-top:12px;border-top:1px solid var(--glass-border);padding-top:12px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="matrixMode" style="width:auto;">
        <span>MATRIX MODE üü¢</span>
      </label>
      
      <!-- NUEVO: Color Personalizado de Matrix -->
      <div style="margin-top:10px;padding:8px;background:rgba(0,255,65,0.05);border-radius:4px;border:1px solid rgba(0,255,65,0.2);">
        <label style="font-size:0.75rem;color:#888;margin-bottom:5px;display:block;">Color Matrix Est√°tico</label>
        <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;margin-bottom:8px;">
          <button onclick="setMatrixColor('#00ff41')" style="background:#00ff41;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Verde Cl√°sico"></button>
          <button onclick="setMatrixColor('#00ffff')" style="background:#00ffff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Cyan"></button>
          <button onclick="setMatrixColor('#ff00ff')" style="background:#ff00ff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Magenta"></button>
          <button onclick="setMatrixColor('#ffff00')" style="background:#ffff00;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Amarillo"></button>
          <button onclick="setMatrixColor('#ff0033')" style="background:#ff0033;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Rojo"></button>
          <button onclick="setMatrixColor('#ff6600')" style="background:#ff6600;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="Naranja"></button>
          <button onclick="setMatrixColor('#9900ff')" style="background:#9900ff;width:100%;height:30px;border:1px solid #fff;border-radius:3px;cursor:pointer;" title="P√∫rpura"></button>
          <button onclick="setMatrixColor('#ffffff')" style="background:#ffffff;width:100%;height:30px;border:1px solid #888;border-radius:3px;cursor:pointer;" title="Blanco"></button>
        </div>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="width:100%;height:35px;border:1px solid var(--glass-border);background:rgba(0,0,0,0.3);border-radius:4px;cursor:pointer;" onchange="setMatrixColor(this.value)">
      </div>
      
      <label style="display:flex;align-items:center;gap:8px;margin-top:5px;">
        <input type="checkbox" id="fiestaMode" style="width:auto;">
        <span>FIESTA MODE (MIC) üé§</span>
      </label>
    </div>
    
    <div id="matrixControls" style="display:none;margin-top:8px;">
      <div class="input-group">
        <label>Color Matrix</label>
        <select id="matrixColorPreset">
          <option value="#00ff41" selected>Matrix Green üü¢</option>
          <option value="#ff00ff">Vaporwave Purple üíú</option>
          <option value="#00f2ff">Cyan Hacker üîµ</option>
          <option value="#ff0033">Red Alert üî¥</option>
          <option value="#ffff00">Yellow Electric ‚ö°</option>
          <option value="custom">Custom...</option>
        </select>
      </div>
      <div class="input-group" id="customColorGroup" style="display:none;">
        <label>Color Personalizado</label>
        <input type="color" id="matrixColorPicker" value="#00ff41" style="height:40px;cursor:pointer;">
      </div>
      <div class="input-group">
        <label>Opacidad: <span id="matrixOpacityDisplay">0.3</span></label>
        <input type="range" id="matrixOpacity" min="0.1" max="1" value="0.3" step="0.1">
      </div>
    </div>
    
    <div style="margin-top:10px;font-size:0.7rem;color:#666;border-top:1px solid var(--glass-border);padding-top:8px;">
      Seed: <span id="current-seed" style="color:var(--text-cyan)">-10</span><br>
      Mode: <span id="current-mode" style="color:var(--text-magenta)">LOADING...</span><br>
      <span style="color:#444">DIM 10-11: THERMAL NOISE FILTERING</span>
    </div>
  </div>

  <button class="immersion-toggle" onclick="toggleImmersionMode()">Immersion [H]</button>

  <div id="temporal-controls">
    <div class="hud-title">‚è±Ô∏è TEMPORAL CONTROL</div>
    <div id="speed-display">x1.0</div>
    <div style="display:flex;justify-content:center;gap:5px;margin-bottom:10px;">
      <button class="temporal-btn" onclick="setSpeed(-10)">‚óÄ‚óÄ -10x</button>
      <button class="temporal-btn" onclick="setSpeed(-5)">‚óÄ -5x</button>
      <button class="temporal-btn" onclick="setSpeed(0)">‚è∏ PAUSE</button>
      <button class="temporal-btn active" onclick="setSpeed(1)">‚ñ∂ 1x</button>
      <button class="temporal-btn" onclick="setSpeed(5)">‚ñ∂‚ñ∂ 5x</button>
      <button class="temporal-btn" onclick="setSpeed(10)">‚ñ∂‚ñ∂‚ñ∂ 10x</button>
      <button class="temporal-btn" onclick="setSpeed(20)">‚ö° 20x</button>
    </div>
    <div class="input-group">
      <label>Velocidad: <span id="speedSliderDisplay">1.0</span>x</label>
      <input type="range" id="speedSlider" min="-10" max="20" value="1" step="0.5">
    </div>
    
    <!-- IMMERSIVE CONTROLS -->
    <div style="margin-top:15px;padding-top:10px;border-top:1px solid var(--glass-border);">
      <div style="font-size:0.75rem;color:#888;margin-bottom:5px;">IMMERSIVE TOGGLES</div>
      <div style="display:flex;gap:10px;">
        <button onclick="document.getElementById('matrixMode').click()" style="background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green);font-size:0.8rem;">
          TOGGLE MATRIX
        </button>
        <button onclick="document.getElementById('fiestaMode').click()" style="background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);font-size:0.8rem;">
          TOGGLE FIESTA
        </button>
      </div>
    </div>
  </div>

  <!-- Settings Panel (Hidden by default) -->
  <div id="settings-panel" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.9);align-items:center;justify-content:center;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚öôÔ∏è SETTINGS</h2>
        <button onclick="closeSettings()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div class="hud-title" style="margin-bottom:15px;">KEYBOARD CONTROLS</div>
      
      <div id="key-bindings-list" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:20px;">
        <!-- Populated by updateKeyBindingsUI() -->
      </div>
      
      <div style="display:flex;gap:10px;">
        <button onclick="resetKeyBindings()" style="background:var(--text-red);">RESET TO DEFAULTS</button>
        <button onclick="closeSettings()" style="background:var(--text-cyan);color:black;">SAVE & CLOSE</button>
      </div>
    </div>
  </div>

  <!-- Tutorial / Help Overlay -->
  <div id="tutorial-overlay" style="display:none;position:fixed;inset:0;z-index:20000;background:rgba(0,0,0,0.95);align-items:center;justify-content:center;overflow-y:auto;padding:20px;">
    <div style="background:var(--glass-bg);backdrop-filter:blur(20px);border:1px solid var(--glass-border);border-radius:12px;padding:30px;max-width:800px;width:90%;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <h2 style="color:var(--text-cyan);margin:0;">‚ùì COSMIC OS TUTORIAL</h2>
        <button onclick="closeTutorial()" style="width:auto;padding:8px 15px;background:#333;">CLOSE</button>
      </div>
      
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;">
        <div>
          <div class="hud-title" style="margin-bottom:10px;">‚å®Ô∏è KEYBOARD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">W/S/A/D</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">Q/E</b> - Rotar c√°mara<br>
            <b style="color:var(--text-cyan);">Space</b> - Subir<br>
            <b style="color:var(--text-cyan);">Shift</b> - Bajar<br>
            <b style="color:var(--text-cyan);">Ctrl</b> - Speed Boost 2x<br>
            <b style="color:var(--text-cyan);">H/L</b> - Modo Inmersivo<br>
            <b style="color:var(--text-cyan);">R</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">?</b> - Este tutorial<br>
          </div>
        </div>
        
        <div>
          <div class="hud-title" style="margin-bottom:10px;">üïπÔ∏è MOUSE</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Click + Drag</b> - Rotar vista<br>
            <b style="color:var(--text-cyan);">Scroll</b> - Zoom in/out<br>
            <b style="color:var(--text-cyan);">Double Click</b> - Viajar a nodo<br>
            <b style="color:var(--text-cyan);">Hover Izq</b> - Mostrar panel<br>
          </div>
          
          <div class="hud-title" style="margin:15px 0 10px;">üéÆ GAMEPAD</div>
          <div style="font-size:0.85rem;line-height:1.8;color:#ccc;">
            <b style="color:var(--text-cyan);">Stick Izq</b> - Movimiento<br>
            <b style="color:var(--text-cyan);">LT/RT</b> - Subir/Bajar<br>
            <b style="color:var(--text-cyan);">A</b> - Reset C√°mara<br>
            <b style="color:var(--text-cyan);">B</b> - Immersion<br>
            <b style="color:var(--text-cyan);">X</b> - CAOS<br>
            <b style="color:var(--text-cyan);">Y</b> - Matrix Toggle<br>
          </div>
        </div>
      </div>
      
      <div style="margin-top:20px;padding-top:20px;border-top:1px solid var(--glass-border);">
        <div class="hud-title" style="margin-bottom:10px;">üåå MODO INMERSIVO</div>
        <p style="font-size:0.85rem;color:#ccc;margin:0;">
          Presiona <b style="color:var(--text-cyan);">H</b> para entrar en modo inmersivo. La c√°mara se alejar√° autom√°ticamente para vista panor√°mica. 
          Los controles temporales aparecer√°n en la esquina inferior derecha para controlar la velocidad de simulaci√≥n (-10x a +20x).
        </p>
      </div>
      
      <button onclick="closeTutorial()" style="margin-top:20px;background:var(--text-cyan);color:black;">GOT IT!</button>
    </div>
  </div>

  <!-- Quick Navigation Panel -->
  <div id="quick-nav-panel" style="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);z-index:1000;background:var(--glass-bg);backdrop-filter:blur(15px);border:1px solid var(--glass-border);border-radius:8px;padding:15px;width:200px;">
    <div class="hud-title" id="quick-nav-handle" style="margin-bottom:10px;cursor:grab;">üß≠QUICK NAV (Drag Me)</div>
    <button onclick="goToSingularity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red);">
      üåå SINGULARITY
    </button>
    <button onclick="escapeGravity()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(0,242,255,0.2);border:1px solid var(--text-cyan);color:var(--text-cyan);">
      üöÄ ESCAPE
    </button>
    <button onclick="goToNearestNode()" style="width:100%;margin-bottom:5px;padding:8px;background:rgba(255,255,0,0.2);border:1px solid var(--text-yellow);color:var(--text-yellow);">
      üéØ NEAREST NODE
    </button>
    <button onclick="goToRandomPosition()" style="width:100%;padding:8px;background:rgba(255,0,255,0.2);border:1px solid var(--text-magenta);color:var(--text-magenta);">
      üé≤ RANDOM
    </button>
  </div>



  <!-- Donation Module (Responsive) -->
  <div id="donation-module">
    <div style="font-size:0.8rem; font-weight:bold; color:var(--text-white); margin-bottom:5px; border-bottom:1px solid rgba(0,242,255,0.2); padding-bottom:5px;">
      DONACIONES (ABISMO 11D)
    </div>
    <div style="display:flex; flex-wrap:wrap; gap:10px;">
      <div class="qr-container">
        <div style="position:relative;">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh" class="qr-image" alt="Bitcoin QR">
          <div class="qr-image-overlay">BTC</div>
        </div>
        <span class="qr-label">Bitcoin (BTC)</span>
        <span style="font-size:0.55rem; color:#aaa; font-family:monospace;">bc1q...seed</span>
      </div>
      <div class="qr-container">
        <div style="position:relative;">
          <img src="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=0x71C7656EC7ab88b098defB751B7401B5f6d8976F" class="qr-image" alt="Ethereum QR">
          <div class="qr-image-overlay">ETH</div>
        </div>
        <span class="qr-label">Ethereum (ETH)</span>
        <span style="font-size:0.55rem; color:#aaa; font-family:monospace;">0x...abyss</span>
      </div>
    </div>
    <div style="margin-top: 10px; display: flex; gap: 8px;">
       <button onclick="openSettings()" style="width:auto;padding:8px 12px;background:rgba(255,255,255,0.1);border:1px solid var(--glass-border);color:var(--text-cyan); font-size:0.7rem;">
        ‚öôÔ∏è SETTINGS
      </button>
      <button onclick="window.location.href='/hall_of_shame'" style="width:auto;padding:8px 12px;background:rgba(255,0,51,0.2);border:1px solid var(--text-red);color:var(--text-red); font-size:0.7rem;">
        üèÜ SHAME
      </button>
      <button onclick="openTutorial()" style="width:auto;padding:8px 12px;background:rgba(0,255,65,0.2);border:1px solid var(--text-green);color:var(--text-green); font-size:0.7rem;">
        ‚ùì HELP
      </button>
    </div>
  </div>

</body>
</html>
