<!DOCTYPE html>
<html>
<head>
    <title>Multi-Seed Cosmic Brain - Bayesian Negative 9D</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000000 !important;
            font-family: 'Courier New', monospace;
        }

        #monitor-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            background: rgba(0, 15, 25, 0.85);
            backdrop-filter: blur(8px);
            padding: 12px 16px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 100;
            font-size: 0.9rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
            pointer-events: none;
        }

        #seed-display {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ffff;
            background: rgba(0, 15, 25, 0.85);
            backdrop-filter: blur(8px);
            padding: 10px 14px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 100;
            font-size: 0.85rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
        }

        .seed-item {
            margin: 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .seed-color-box {
            width: 14px;
            height: 14px;
            border-radius: 2px;
            display: inline-block;
        }

        #controls-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 100;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .hud-btn {
            background: #111;
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 14px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9rem;
            transition: all 0.25s;
        }

        .hud-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 12px #00ffff;
        }

        /* FUTURE DIALOG - Cosmic Data Explorer v2.1 */
        #node-details-dialog {
            position: absolute;
            top: 150px; /* Movido hacia abajo para no chocar con SEED DISPLAY */
            right: 10px;
            width: 250px;
            background: rgba(0, 15, 25, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.4);
            border-left: 4px solid #00ffff;
            color: #fff;
            padding: 15px;
            font-family: 'Courier New', monospace;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.15);
            pointer-events: auto;
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }

        #node-details-dialog.active {
            display: block;
            transform: translateX(0);
        }

        .dialog-header {
            font-size: 0.7rem;
            color: #00ffff;
            letter-spacing: 2px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            padding-bottom: 4px;
        }

        .node-label {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 5px;
            color: #ffd700;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
        }

        .horror-bar-container {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            margin-top: 5px;
            overflow: hidden;
        }

        .horror-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #ff4400);
            width: 0%;
            transition: width 0.6s ease;
        }
    </style>
</head>
<body>
    <!-- NODE INFO DIALOG (NEW) -->
    <div id="node-details-dialog">
        <div class="dialog-header">NODE EXPLORER v2.1</div>
        <div id="dialog-node-id" style="font-size: 0.6rem; color: #888;">ID: --</div>
        <div id="dialog-node-label" class="node-label">--</div>
        
        <div class="stat-row">
            <span>DIMENSION:</span>
            <span id="dialog-node-dim">--</span>
        </div>
        <div class="stat-row">
            <span>HORROR:</span>
            <span id="dialog-node-horror">--</span>
        </div>
        <div class="horror-bar-container">
            <div id="dialog-horror-fill" class="horror-bar-fill"></div>
        </div>
        <div id="dialog-node-desc" style="font-size: 0.7rem; color: #aaa; margin-top: 10px; font-style: italic;">
            --
        </div>
    </div>
    <div id="monitor-panel">
        <div>MODO: <span id="mode-label">MULTI-SEED COSMIC</span></div>
        <div>SEEDS: <span id="seed-count">{{ seeds|length }}</span></div>
        <div>TOTAL NODOS: <span id="node-count">0</span></div>
        
        <!-- RESOURCE MONITOR -->
        <div style="margin-top:10px; border-top:1px solid #444; padding-top:4px;">
            <div style="color:#aaa; font-size:0.75rem;">SYSTEM VITALITY</div>
            <div style="display:flex; justify-content:space-between; font-size: 0.85rem;">
                <span>FPS: <span id="fps-val" style="color:#0f0">60</span></span>
                <span id="ping-val" style="color:#666; font-size:0.7rem;">--ms</span>
            </div>
            <div style="font-size: 0.85rem;">CPU: <span id="cpu-val" style="color:#00aaff">--%</span> | RAM: <span id="ram-val" style="color:#ff00ff">--GB</span></div>
        </div>
    </div>

    <div id="seed-display">
        <div style="margin-bottom:8px; font-weight:bold;">ğŸŒŒ SEMILLAS ACTIVAS</div>
        {% for graph in graphs %}
        <div class="seed-item">
            <span class="seed-color-box" style="background:{{ graph.color }}"></span>
            <span>Seed #{{ graph.seed }}</span>
        </div>
        {% endfor %}
    </div>

    <div id="controls-panel">
        <button class="hud-btn" onclick="toggleFullscreen()">Fullscreen</button>
        <button class="hud-btn" onclick="resetCamera()">Reset Cam</button>
        <button class="hud-btn" onclick="toggleOrbits()">Toggle Ã“rbitas</button>
        <button class="hud-btn" onclick="window.location.href='/'">â† Dashboard</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // DATOS INYECTADOS DESDE FLASK
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        
        const graphsData = {{ graphs | tojson }};
        var selectedNodeId = null; 

        let totalNodes = 0;
        graphsData.forEach(g => totalNodes += g.nodes.length);
        document.getElementById('node-count').innerText = totalNodes;

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // CONFIGURACIÃ“N THREE.JS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 20000);
        camera.position.set(0, 400, 1500);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        let controls;
        try {
            if (typeof THREE.OrbitControls === 'function') {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.07;
                controls.rotateSpeed = 0.6;
                controls.target.set(0, 0, 0);
            }
        } catch (e) { 
            console.error("Error inicializando controles:", e); 
        }

        // Arrays para almacenar grupos y meshes
        const seedGroups = [];
        const nodeMeshes = {};
        const lineMeshes = [];
        let showOrbits = true;

        // SISTEMA DE PARTÃCULAS DORADAS (NEW v2.1) - Inicializado despuÃ©s de centralSingularity
        const goldenParticles = [];
        const particleCount = 100;
        const pGeo = new THREE.SphereGeometry(1.2, 4, 4);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0.8 });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // CREACIÃ“N DE SINGULARIDAD CENTRAL (CERO ABSOLUTO)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        const centralSingularity = new THREE.Group();
        centralSingularity.position.set(0, 0, 0);

        // Agujero negro central
        const blackHoleGeo = new THREE.SphereGeometry(25, 32, 32);
        const blackHoleMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        centralSingularity.add(blackHole);

        // Event Horizon (borde dorado)
        const horizonGeo = new THREE.SphereGeometry(28, 32, 32);
        const horizonMat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            transparent: true,
            opacity: 0.6,
            wireframe: true
        });
        const horizon = new THREE.Mesh(horizonGeo, horizonMat);
        centralSingularity.add(horizon);

        // Glow central
        try {
            const glowTex = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/ball.png');
            const glow = new THREE.Sprite(new THREE.SpriteMaterial({
                map: glowTex,
                color: 0xffaa00,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.7
            }));
            glow.scale.set(150, 150, 1);
            centralSingularity.add(glow);
        } catch(e) {
            console.warn("No se pudo cargar textura de glow");
        }

        // AGREGAR PARTÃCULAS AHORA QUE centralSingularity YA EXISTE
        for(let i=0; i<particleCount; i++) {
            const p = new THREE.Mesh(pGeo, pMat);
            const r = 40 + Math.random() * 60;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            p.position.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
            p.userData = { 
                r: r, 
                angle: Math.random() * Math.PI * 2, 
                speed: 0.01 + Math.random() * 0.03,
                axis: new THREE.Vector3(Math.random(), Math.random(), Math.random()).normalize()
            };
            centralSingularity.add(p);
            goldenParticles.push(p);
        }

        scene.add(centralSingularity);

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // FUNCIÃ“N: DISTRIBUCIÃ“N ESFÃ‰RICA (NO RECTANGULAR)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        function randomSphericalPosition(innerRadius, outerRadius) {
            // DistribuciÃ³n esfÃ©rica uniforme (mÃ©todo de Marsaglia)
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            
            // Radio con distribuciÃ³n cÃºbica para mejor dispersiÃ³n
            const r = innerRadius + Math.pow(Math.random(), 0.7) * (outerRadius - innerRadius);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // CREACIÃ“N DE SEMILLAS CON GRADIENTE CÃ“SMICO
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        graphsData.forEach((graphData, seedIndex) => {
            const group = new THREE.Group();
            
            // Cada semilla tiene su Ã³rbita base
            const orbitRadius = 600;
            const orbitAngle = (seedIndex / graphsData.length) * Math.PI * 2;
            group.position.x = Math.cos(orbitAngle) * orbitRadius;
            group.position.z = Math.sin(orbitAngle) * orbitRadius;
            group.position.y = 0;

            // Metadata para animaciÃ³n
            group.userData.orbitPhase = orbitAngle;
            group.userData.orbitSpeed = graphData.orbit_speed;
            group.userData.oscillationPhase = Math.random() * Math.PI * 2;
            group.userData.seedColor = graphData.color;
            group.userData.seedIndex = seedIndex;

            // Calcular maxHorror para normalizaciÃ³n
            const maxHorror = Math.max(1, ...graphData.nodes.map(n => n.horror || 0));

            // Crear nodos con distribuciÃ³n esfÃ©rica
            graphData.nodes.forEach(nodeData => {
                const localPos = randomSphericalPosition(150, 450);
                const globalPos = localPos.clone().add(group.position);
                const distanceToCenter = globalPos.length();
                const distanceNorm = Math.min(1, distanceToCenter / 1500);
                let brightness = 0.05 + (distanceNorm * 0.95);
                nodeMeshes[nodeData.id] = { userData: { ...nodeData, distanceToCenter, brightness }, localPos };
            });

            // INSTANCED MESH PARA NODOS (OPTIMIZACIÃ“N MÃXIMA)
            const nodeGeometry = new THREE.SphereGeometry(1, 8, 8); // Base geometry (scaled per instance)
            const nodeMaterial = new THREE.MeshBasicMaterial({ 
                transparent: true, 
                opacity: 0.9,
                blending: THREE.AdditiveBlending 
            });
            
            const instancedMesh = new THREE.InstancedMesh(nodeGeometry, nodeMaterial, graphData.nodes.length);
            const dummy = new THREE.Object3D();

            graphData.nodes.forEach((nodeData, i) => {
                const nodeRef = nodeMeshes[nodeData.id];
                const horrorNorm = (nodeData.horror || 0) / maxHorror;
                const size = 2.0 + (horrorNorm * 6);
                
                dummy.position.copy(nodeRef.localPos);
                dummy.scale.set(size, size, size);
                dummy.updateMatrix();
                instancedMesh.setMatrixAt(i, dummy.matrix);

                // Central node (Cero Absoluto) always Gold, others seed color * brightness
                let color = new THREE.Color(graphData.color);
                if (nodeData.is_central) {
                    color.set(0xffd700);
                } else {
                    color.multiplyScalar(nodeRef.userData.brightness);
                }
                instancedMesh.setColorAt(i, color);
            });
            
            instancedMesh.instanceMatrix.needsUpdate = true;
            if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
            
            group.add(instancedMesh);
            // Referencia para raycasting (InstancedMesh requiere lÃ³gica especial, usaremos dummy meshes invisibles o bounding boxes si es necesario, 
            // pero por ahora mantendremos la compatibilidad con el raycaster original usando invisibles para interactividad si el rendimiento lo permite)
            // Para v2.1 usaremos una tÃ©cnica de raycasting sobre InstancedMesh
            instancedMesh.userData.isNodeInstance = true;
            instancedMesh.userData.seedIndex = seedIndex;

            // Crear lÃ­neas (edges) dentro del grupo
            graphData.edges.forEach(edgeData => {
                const sourceData = nodeMeshes[edgeData.source];
                const targetData = nodeMeshes[edgeData.target];
                
                if (!sourceData || !targetData) return;

                const mat = new THREE.LineBasicMaterial({
                    color: graphData.color,
                    opacity: 0.15,
                    transparent: true,
                    linewidth: 1
                });

                // PUENTE ELÃ‰CTRICO (Solicitado por el usuario)
                // En multiseed detectamos si los IDs originales sugieren cruce (aunque aquÃ­ son intragrupo por ahora)
                // La lÃ³gica de puentes globales estÃ¡ mÃ¡s abajo.

                const geo = new THREE.BufferGeometry().setFromPoints([
                    sourceData.localPos,
                    targetData.localPos
                ]);
                
                const line = new THREE.Line(geo, mat);
                line.userData = { source: edgeData.source, target: edgeData.target };
                group.add(line);
                lineMeshes.push(line);
            });

            // Opcional: Visualizador de Ã³rbita
            if (showOrbits) {
                const orbitGeo = new THREE.RingGeometry(orbitRadius - 10, orbitRadius + 10, 128);
                const orbitMat = new THREE.MeshBasicMaterial({
                    color: graphData.color,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.08
                });
                const orbitRing = new THREE.Mesh(orbitGeo, orbitMat);
                orbitRing.rotation.x = Math.PI / 2;
                orbitRing.userData.isOrbit = true;
                scene.add(orbitRing);
            }

            scene.add(group);
            seedGroups.push(group);
        });

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // PUENTES DE ENERGÃA ENTRE SEMILLAS
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        if (seedGroups.length >= 2) {
            for (let i = 0; i < seedGroups.length; i++) {
                const nextIndex = (i + 1) % seedGroups.length;
                const groupA = seedGroups[i];
                const groupB = seedGroups[nextIndex];

                // PUENTE ELÃ‰CTRICO v2.1 (Amarillo brillante y grueso)
                const bridgeMat = new THREE.LineBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.8,
                    linewidth: 4 // MÃ¡s impactante
                });

                const points = [
                    groupA.position.clone(),
                    groupB.position.clone()
                ];

                const bridgeGeo = new THREE.BufferGeometry().setFromPoints(points);
                const bridge = new THREE.Line(bridgeGeo, bridgeMat);
                bridge.userData.isBridge = true;
                scene.add(bridge);
            }
        }

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // ANIMACIÃ“N ORBITAL & INTERACCIÃ“N (Energy Packets)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        // Sistema de Energy Packets (partÃ­culas de intercambio)
        const energyPackets = [];
        const packetGeo = new THREE.SphereGeometry(3, 4, 4);
        const packetMat = new THREE.MeshBasicMaterial({ color: 0xffffff });

        function spawnPacket() {
            if (seedGroups.length < 2) return;
            const fromIdx = Math.floor(Math.random() * seedGroups.length);
            let toIdx = Math.floor(Math.random() * seedGroups.length);
            while(toIdx === fromIdx) toIdx = Math.floor(Math.random() * seedGroups.length);

            const packet = new THREE.Mesh(packetGeo, packetMat);
            
            // PosiciÃ³n inicial (aleatoria dentro del grupo origen)
            const startPos = seedGroups[fromIdx].position.clone().add(
                randomSphericalPosition(0, 200) 
            );
            packet.position.copy(startPos);
            
            packet.userData = {
                targetGroup: seedGroups[toIdx],
                speed: 5 + Math.random() * 5,
                life: 0
            };
            
            scene.add(packet);
            energyPackets.push(packet);
        }

        // Aumentar trÃ¡fico de datos (High Bandwidth)
        setInterval(() => {
            for(let i=0; i<8; i++) spawnPacket(); 
        }, 200); // RÃ¡fagas de 8 paquetes cada 200ms


        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) controls.update();

            // Animar cada semilla (SeparaciÃ³n Aumentada)
            seedGroups.forEach((group, idx) => {
                // RotaciÃ³n orbital alrededor del centro
                group.userData.orbitPhase += group.userData.orbitSpeed;
                const orbitR = 1100; // AUMENTADO de 600 a 1100 para separaciÃ³n clara
                
                group.position.x = Math.cos(group.userData.orbitPhase) * orbitR;
                group.position.z = Math.sin(group.userData.orbitPhase) * orbitR;

                // OscilaciÃ³n vertical suave
                group.userData.oscillationPhase += 0.0008;
                group.position.y = Math.sin(group.userData.oscillationPhase) * 120; // MÃ¡s amplitud

                // RotaciÃ³n interna del grupo (giro sobre sÃ­ mismo)
                group.rotation.y += 0.0005;
                
                // Actualizar posiciÃ³n de puentes de energÃ­a si existen
                // (Como los puentes son estÃ¡ticos en vertices, hay que actualizarlos)
            });

            // Actualizar Bridges (Lineas verdes)
            scene.children.forEach(child => {
                if (child.userData.isBridge) {
                    // Recalcular posiciones (esto es costoso pero necesario si se mueven)
                    // SimplificaciÃ³n: Asumimos bridge conecta idx i con i+1
                    // Pero no guardamos referencia idx en bridge. 
                    // Mejor borrar y recrear? O actualizar geometry?
                    // Por performance, los bridges estÃ¡ticos se ven mal si orbitan.
                    // Vamos a ocultarlos o animarlos.
                    // Mejor: Hacer que los bridges sean dinÃ¡micos.
                    // Por ahora, eliminarlos de la escena y dejar solo energy packets 
                    // O actualizarlos si tuvieramos referencia.
                    child.visible = false; // Ocultar bridges estÃ¡ticos viejos
                }
            });

            // Animar Energy Packets
            for (let i = energyPackets.length - 1; i >= 0; i--) {
                const p = energyPackets[i];
                const target = p.userData.targetGroup.position;
                
                // Mover hacia target
                const dir = target.clone().sub(p.position).normalize();
                p.position.add(dir.multiplyScalar(p.userData.speed));
                
                // Chequear llegada
                if (p.position.distanceTo(target) < 50 || p.userData.life > 500) {
                    scene.remove(p);
                    energyPackets.splice(i, 1);
                }
                p.userData.life++;
            }

            // Pulso del agujero negro central (Dynamic Glow Pulsing)
            const pulseFactor = Math.sin(Date.now() * 0.002);
            const pulseScale = 1.0 + pulseFactor * 0.05;
            centralSingularity.scale.set(pulseScale, pulseScale, pulseScale);
            
            // Pulse glow opacity
            if (centralSingularity.children[2]) {
                centralSingularity.children[2].material.opacity = 0.5 + pulseFactor * 0.2;
            }

            // Animar partÃ­culas doradas
            goldenParticles.forEach(p => {
                p.userData.angle += p.userData.speed;
                p.position.applyAxisAngle(p.userData.axis, p.userData.speed);
            });
            
            // RotaciÃ³n del anillo de eventos
            centralSingularity.children[1].rotation.z += 0.002; 
            centralSingularity.children[1].rotation.x += 0.001; 

            renderer.render(scene, camera);
        }

        animate();

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // CONTROLES
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else {
                document.exitFullscreen();
            }
        };

        window.resetCamera = () => {
            camera.position.set(0, 300, 1200);
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
        };

        window.toggleOrbits = () => {
            showOrbits = !showOrbits;
            scene.children.forEach(child => {
                if (child.userData.isOrbit) {
                    child.visible = showOrbits;
                }
            });
        };

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // INTERACCIÃ“N: CLICK & HIGHLIGHT (Unificado)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);

            // Raycasting sobre InstancedMesh (v2.1)
            const instancedMeshes = [];
            scene.traverse(child => {
                if (child.isInstancedMesh) instancedMeshes.push(child);
            });
            
            const intersects = raycaster.intersectObjects(instancedMeshes);

            // Helper para resetear lÃ­neas
            const resetLines = () => {
                lineMeshes.forEach(line => {
                    line.material.opacity = 0.15;
                    line.material.color.set(line.userData.originalColor || 0x00ffff);
                });
                
                scene.children.forEach(child => {
                    if (child.userData.isBridge) {
                        child.material.opacity = 0.8;
                        child.material.color.set(0xffff00);
                    }
                });
            };

            if (lineMeshes.length > 0 && !lineMeshes[0].userData.originalColor) {
                 lineMeshes.forEach(l => l.userData.originalColor = l.material.color.clone());
            }

            if (intersects.length > 0) {
                const intersection = intersects[0];
                const instanceId = intersection.instanceId;
                const iMesh = intersection.object;
                const seedIdx = iMesh.userData.seedIndex;
                const graphNodes = graphsData[seedIdx].nodes;
                const nodeData = graphNodes[instanceId];

                if (selectedNodeId === nodeData.id) {
                    selectedNodeId = null;
                    resetLines();
                    hideNodeDetails();
                } else {
                    selectedNodeId = nodeData.id;
                    showNodeDetails(nodeData);

                    resetLines();
                    lineMeshes.forEach(line => {
                        if (line.userData.source === nodeData.id || line.userData.target === nodeData.id) {
                             line.material.color.set(0xffd700);
                             line.material.opacity = 0.9;
                        } else {
                             line.material.opacity = 0.05;
                        }
                    });
                }
            } else {
                selectedNodeId = null;
                resetLines();
                hideNodeDetails();
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // RESOURCE MONITORING (FPS & POLL)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let lastFrameTime = performance.now();
        let frameCount = 0;
        const fpsEl = document.getElementById('fps-val');
        
        function updateFPS() {
            const now = performance.now();
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                if(fpsEl) {
                    fpsEl.innerText = frameCount;
                    fpsEl.style.color = frameCount < 30 ? '#ff0000' : (frameCount < 50 ? '#ffff00' : '#00ff00');
                }
                frameCount = 0;
                lastFrameTime = now;
            }
            requestAnimationFrame(updateFPS);
        }
        updateFPS();

        setInterval(() => {
            const startPing = Date.now();
            fetch('/api/resources')
                .then(r => r.json())
                .then(data => {
                    const ping = Date.now() - startPing;
                    if(document.getElementById('ping-val')) document.getElementById('ping-val').innerText = ping + 'ms';
                    if(document.getElementById('cpu-val')) {
                        document.getElementById('cpu-val').innerText = data.cpu + '%';
                        document.getElementById('cpu-val').style.color = data.cpu > 80 ? '#ff0000' : '#00aaff';
                    }
                    if(document.getElementById('ram-val')) document.getElementById('ram-val').innerText = data.ram_used + 'GB';
                })
                .catch(err => console.error("Monitor error:", err));
        }, 2000);

        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // SPIKE VISUAL EFFECT (IONIC CHANNELS)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        window.addEventListener('message', (event) => {
            if (event.data.type === 'spike') {
                trigger3DMultiSpike(event.data.color || '#ffd700');
            }
        });

        function trigger3DMultiSpike(colorHex) {
            const spikeColor = new THREE.Color(colorHex);
            
            // 1. Flash all seed groups
            seedGroups.forEach(group => {
                group.scale.set(1.2, 1.2, 1.2);
                setTimeout(() => group.scale.set(1, 1, 1), 500);
            });

            // 2. Pulse background temporarily
            const originalBg = scene.background.clone();
            scene.background.set(spikeColor).multiplyScalar(0.05); // Muy sutil
            setTimeout(() => scene.background.copy(originalBg), 400);

            // 3. Shake camera
            const originalPos = camera.position.clone();
            const shakeInterval = setInterval(() => {
                camera.position.x += (Math.random() - 0.5) * 5;
                camera.position.y += (Math.random() - 0.5) * 5;
            }, 50);
            
            setTimeout(() => {
                clearInterval(shakeInterval);
                camera.position.copy(originalPos);
            }, 500);
        }
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // DIALOG LOGIC
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function showNodeDetails(data) {
            const dialog = document.getElementById('node-details-dialog');
            document.getElementById('dialog-node-id').innerText = `ID: ${data.id}`;
            document.getElementById('dialog-node-label').innerText = data.label;
            document.getElementById('dialog-node-dim').innerText = data.original_id ? data.original_id.split('.')[0] : 'UNKNOWN';
            document.getElementById('dialog-node-horror').innerText = data.horror.toFixed(2);
            document.getElementById('dialog-node-desc').innerText = `Captura de resonancia negativa en T+${Date.now()%1000}ms.`;
            
            // Fill bar (max approx 3000 horror for scale)
            const fillPerc = Math.min((data.horror / 3000) * 100, 100);
            document.getElementById('dialog-horror-fill').style.width = fillPerc + '%';

            dialog.style.display = 'block';
            setTimeout(() => dialog.classList.add('active'), 10);
        }

        function hideNodeDetails() {
            const dialog = document.getElementById('node-details-dialog');
            dialog.classList.remove('active');
            setTimeout(() => {
                if(!dialog.classList.contains('active')) dialog.style.display = 'none';
            }, 400);
        }
    </script>
</body>
</html>
