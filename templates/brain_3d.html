<!DOCTYPE html>
<html>
<head>
    <title>Cosmic Brain - Bayesian Negative 9D</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000000 !important;
            font-family: 'Courier New', monospace;
        }

        #monitor-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            background: rgba(0,0,0,0.92);
            padding: 12px 16px;
            border: 1px solid #444;
            border-radius: 4px;
            z-index: 100;
            font-size: 0.9rem;
            box-shadow: 0 0 12px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #motion-hud {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #ffdd00;
            background: rgba(0,0,0,0.92);
            padding: 10px 14px;
            border: 1px solid #ffdd00;
            border-radius: 4px;
            z-index: 100;
            font-size: 0.85rem;
        }

        #controls-panel {
            position: absolute;
            bottom: 15px;
            left: 15px;
            z-index: 100;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .hud-btn {
            background: #111;
            border: 1px solid #00ffff;
            color: #00ffff;
            padding: 8px 14px;
            cursor: pointer;
            font-family: monospace;
            font-size: 0.9rem;
            transition: all 0.25s;
        }

        .hud-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 12px #00ffff;
        }

        select.hud-btn {
            background: #111;
            color: #00ffff;
            border: 1px solid #00ffff;
        }

        /* STATS SEED STYLES */
        .stat-row { display: flex; justify-content: space-between; gap: 15px; margin-bottom: 4px; }
        .seed-stat { font-size: 0.8rem; border-left: 3px solid #666; padding-left: 8px; margin-top: 4px; }
        .seed-cyan { border-color: #00ffff; color: #ccffff; }
        .seed-magenta { border-color: #ff00ff; color: #ffccff; }
        .seed-white { border-color: #ffffff; color: #ffffff; }

        /* TOOLTIP STYLE */
        #tooltip {
            position: absolute;
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #ffd700;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            pointer-events: none;
            display: none;
            z-index: 200;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.2);
            max-width: 300px;
        }
        .tooltip-header { color: #ffd700; font-weight: bold; border-bottom: 1px solid #444; padding-bottom: 4px; margin-bottom: 4px; }
        .tooltip-row { display: flex; justify-content: space-between; }
        .tooltip-val { font-weight: bold; color: #00ffff; }
    </style>
</head>
<body>
    <div id="monitor-panel">
        <div>MODE: <span id="mode-label">Cargando...</span></div>
        <div>NODES: <span id="node-count">0</span></div>
        <div>EDGES: <span id="edge-count">0</span></div>
        <div id="seed-stats-container" style="margin-top:8px; border-top:1px solid #555; padding-top:4px;"></div>
        
        <!-- RESOURCE MONITOR -->
        <div style="margin-top:12px; border-top:1px solid #444; padding-top:6px;">
            <div style="color:#888; font-size:0.7rem; margin-bottom:2px;">SYSTEM VITALITY</div>
            <div style="display:flex; justify-content:space-between;">
                <span>FPS: <span id="fps-val" style="color:#0f0">60</span></span>
                <span id="ping-val" style="color:#666; font-size:0.7rem;">--ms</span>
            </div>
            <div>CPU: <span id="cpu-val" style="color:#00aaff">--%</span> | RAM: <span id="ram-val" style="color:#ff00ff">--GB</span></div>
        </div>
    </div>
    
    <div id="tooltip"></div>

    <div id="motion-hud">
        DIRECTION: <span id="dir-val">STABLE</span>
    </div>

    <div id="controls-panel">
        <button class="hud-btn" onclick="toggleFullscreen()">Fullscreen</button>
        <button class="hud-btn" onclick="resetCamera()">Reset Cam</button>
        <button class="hud-btn" onclick="flyTo(centralSingularity)" style="border-color:#ff0000; color:#ffcccc;">WARP SINGULARITY</button>
    </div>

    <!-- THREE.JS & POST-PROCESSING -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/shaders/DigitalGlitch.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/GlitchPass.js"></script>


    <script>
        const nodesData = {{ nodes | tojson }};
        const edgesData = {{ edges | tojson }};
        const modeData = {{ modo | tojson }};
        
        var selectedNodeId = null; 
        // 
        // STATS POR SEED
        // 
        const seedStats = {};
        nodesData.forEach(n => {
            const s = n.seed_index !== undefined ? n.seed_index : 'root';
            if (!seedStats[s]) seedStats[s] = { count: 0, horrorSum: 0 };
            seedStats[s].count++;
            seedStats[s].horrorSum += (n.horror || 0);
        });

        const statsHtml = Object.keys(seedStats).map(k => {
            const s = seedStats[k];
            const avg = (s.horrorSum / s.count).toFixed(1);
            let colorClass = 'seed-white';
            let label = 'Root/White';
            if (k == 1) { colorClass = 'seed-cyan'; label = 'Cyan Seed'; }
            if (k == 2) { colorClass = 'seed-magenta'; label = 'Magenta Seed'; }
            
            return `<div class="seed-stat ${colorClass}">
                <div>${label}</div>
                <div style="font-size:0.75rem; opacity:0.8;">${s.count} nodos |  Avg: ${avg}</div>
            </div>`;
        }).join('');
        document.getElementById('seed-stats-container').innerHTML = statsHtml;

        // 
        // THREE.JS SETUP
        // 
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Fondo negro abismo

        // Fog para profundidad
        scene.fog = new THREE.FogExp2(0x000000, 0.0008);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 100, 800); // Inicio lejos para anim

        // 
        // POST-PROCESSING: BLOOM & GLOW
        // 
        const renderScene = new THREE.RenderPass(scene, camera);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0; // Brillante en oscuridad
        bloomPass.strength = 1.0; // Intensidad del brillo
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 
        // THEME MANAGER
        // 
        const currentTheme = {
            name: modeData ? modeData.nombre : "ABISMO DEFAULT",
            color: modeData && modeData.info ? new THREE.Color(modeData.info.color) : new THREE.Color(0xffffff),
            emoji: modeData && modeData.info ? modeData.info.emoji : "",
            isMapuche: modeData && modeData.nombre && modeData.nombre.includes("MAPUCHE"),
        };
        console.log("THEME ACTIVE:", currentTheme);

        // 
        // GRAVITY WATER EFFECT (SPACETIME FABRIC)
        // 
        // SINGULARIDAD CENTRAL: Gargantua Refined & Bayesian Crystal
        const centralSingularity = new THREE.Group();
        centralSingularity.position.set(0, 0, 0);

        // 1. CLCULO BAYESIANO NEGATIVO DE LA ESTRUCTURA DE CRISTAL
        // "Promediar todo y encontrar la mejor opci贸n por 谩ngulos de intersecci贸n"
        // Simulamos este c谩lculo analizando la densidad de conexiones entrantes
        const connectionDensity = edgesData.filter(e => e.target === "CERO_ABSOLUTO" || e.source === "CERO_ABSOLUTO").length;
        const crystalComplexity = Math.min(5, Math.max(1, Math.floor(connectionDensity / 50))); 
        console.log(`Bayesian Crystal Calculated: Complexity Level ${crystalComplexity} based on ${connectionDensity} matrix crossings.`);

        // 2. NCLEO DE CRISTAL (LA ESTRUCTURA DE LA MATRIX PROMEDIADA)
        const crystalGeo = new THREE.IcosahedronGeometry(20, 1); // Base geom茅trica pura
        const crystalMat = new THREE.MeshPhysicalMaterial({ 
            color: currentTheme.color, // Color del tema (ej. Mapuche Purple)
            emissive: currentTheme.color,
            emissiveIntensity: 0.5,
            metalness: 0.9,
            roughness: 0.1,
            wireframe: true, // "Red de cristal"
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const crystalCore = new THREE.Mesh(crystalGeo, crystalMat);
        
        // Estructura interna densa (La masa rellena)
        const innerCoreGeo = new THREE.OctahedronGeometry(12, 2);
        const innerCoreMat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.5 
        });
        crystalCore.add(new THREE.Mesh(innerCoreGeo, innerCoreMat));

        centralSingularity.add(crystalCore);

        // 3. EVENT HORIZON (EL VELO DEL ABISMO)
        // Ahora es semitransparente para dejar ver la estructura interna
        const blackHoleGeo = new THREE.SphereGeometry(28, 64, 64);
        const blackHoleMat = new THREE.MeshBasicMaterial({ 
            color: 0x000000, 
            transparent: true, 
            opacity: 0.85 // Deja ver el cristal interior
        });
        const blackHole = new THREE.Mesh(blackHoleGeo, blackHoleMat);
        centralSingularity.add(blackHole);

        // 4. PHOTON SPHERE / GLOW (Shader)
        const glowGeo = new THREE.SphereGeometry(29, 64, 64); // Levemente m谩s grande
        const glowMat = new THREE.ShaderMaterial({
            uniforms: {
                glowColor: { value: new THREE.Color(0xffffff) },
                viewVector: { value: camera.position }
            },
            vertexShader: `
                uniform vec3 viewVector;
                varying float intensity;
                void main() {
                    vec3 vNormal = normalize( normalMatrix * normal );
                    vec3 vNormel = normalize( normalMatrix * viewVector );
                    intensity = pow( 0.55 - dot(vNormal, vNormel), 4.5 );
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform vec3 glowColor;
                varying float intensity;
                void main() {
                    vec3 glow = glowColor * intensity;
                    gl_FragColor = vec4( glow, 1.0 );
                }
            `,
            side: THREE.BackSide,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        const photonSphere = new THREE.Mesh(glowGeo, glowMat);
        centralSingularity.add(photonSphere);
        scene.add(centralSingularity);

        // Pulso del agujero negro (variable para animate)
        const singularityMesh = centralSingularity;
        // Referencia para rotar el cristal independientemente
        const crystalMesh = crystalCore;
        const warpGeo = new THREE.IcosahedronGeometry(750, 4);
        const warpMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                baseColor: { value: new THREE.Color(0x0a0a0a) }, 
                accentColor: { value: currentTheme.color }
            },
            vertexShader: `
                uniform float time;
                varying vec2 vUv;
                varying float vWave;
                void main() {
                    vUv = uv;
                    vec3 pos = position;
                    // Efecto de agua/gravedad
                    float wave = sin(pos.x * 0.01 + time) * cos(pos.y * 0.01 + time) * 10.0;
                    wave += sin(pos.x * 0.03 - time * 0.5) * 5.0;
                    pos += normal * wave;
                    vWave = wave;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 baseColor;
                uniform vec3 accentColor;
                varying float vWave;
                void main() {
                    // Mezcla negro con color del tema seg煤n la onda
                    float intensity = smoothstep(-10.0, 10.0, vWave);
                    vec3 col = mix(baseColor, accentColor * 0.2, intensity); // Muy sutil
                    float alpha = 0.1 + intensity * 0.2;
                    gl_FragColor = vec4(col, alpha);
                }
            `,
            side: THREE.BackSide,
            transparent: true,
            depthWrite: false, 
            blending: THREE.AdditiveBlending // Para que brille
        });
        const warpField = new THREE.Mesh(warpGeo, warpMat);
        scene.add(warpField);


        // 
        // FUNCIN: DISTRIBUCIN ESFRICA (NO RECTANGULAR)
        // 

        function randomSphericalPosition(innerRadius, outerRadius) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const r = innerRadius + Math.pow(Math.random(), 0.7) * (outerRadius - innerRadius);
            
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        }

        // 
        // CREACIN DE NODOS: GRADIENTE CSMICO + HYBRIDS
        // 

        nodesData.forEach(n => {
            // Posici贸n final objetivo
            const targetPos = randomSphericalPosition(150, 700);
            
            // Posici贸n inicial (LEJOS para collapse animation)
            const startPos = targetPos.clone().normalize().multiplyScalar(2500); 

            // Distancia al centro para gradiente
            const dist = targetPos.length();
            const distNorm = Math.min(1, dist / 800);
            
            let color = new THREE.Color(0.8, 0.8, 0.8);
            let size = 2 + (n.horror/maxHorror) * 5;
            let opacity = 0.8;

            // Logica de colores por seed
            const seedIdx = n.seed_index;
            if (seedIdx === 1) color.set(0x00ffff);
            else if (seedIdx === 2) color.set(0xff00ff);
            else color.setHSL(0, 0, 1.0 - (distNorm * 0.8)); // Blanco -> Gris

            // HYBRID HIGHLIGHT
            // Si el nombre dice "HYBRID" o tiene horror muy alto en fusion
            const isHybrid = n.label && n.label.includes('HYBRID'); // O l贸gica custom
            if (isHybrid || n.horror > maxHorror * 0.9) {
                color.set(0xffffff); // Blanco puro
                size *= 1.5;
                // Borde/Glow simulado con sprite luego, o simplemente brillante
            }

            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity
            });

            const mesh = new THREE.Mesh(new THREE.SphereGeometry(size, 8, 8), mat);
            
            // Empezar lejos!
            mesh.position.copy(startPos);
            mesh.userData = { ...n, targetPos: targetPos, originalColor: color };
            
            scene.add(mesh);
            nodeMeshes[n.id] = mesh;
        });

        // 

        // 
        // CDIGO VIEJO ELIMINADO PARA EVITAR DUPLICADOS
        // 


        // 
        // ARISTAS: PUENTES DIMENSIONALES & CONEXIONES
        // 
        const lineMaterialNormal = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.15 });
        const lineMaterialFusion = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }); // Blanco absoluto
        
        edgesData.forEach(e => {
            const u = nodeMeshes[e.source];
            const v = nodeMeshes[e.target];
            if (!u || !v) return;

            // Detectar si es un Puente Dimensional (Fusion visual)
            const isDimensional = e.type === 'dimensional_bridge' || 
                                (e.label && (e.label.includes("Dimensional") || e.label.includes("Bridge") || e.label.includes("Multiversal")));
            
            const mat = isDimensional ? lineMaterialFusion : lineMaterialNormal;

            const geo = new THREE.BufferGeometry().setFromPoints([u.position, v.position]);
            const line = new THREE.Line(geo, mat);
            
            // Metadata para animaci贸n
            line.userData = { source: u, target: v, isDimensional: isDimensional };
            
            scene.add(line);
            edgeMeshes.push(line);
        });

        // 
        // PARTICULAS ORBITALES (Singularidad)
        // 
        const particlesGeo = new THREE.BufferGeometry();
        const particleCount = 500;
        const pPos = new Float32Array(particleCount * 3);
        
        for(let i=0; i<particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 25 + Math.random() * 100; // Radio orbital
            // Disco plano con leve variaci贸n vertical
            pPos[i*3] = Math.cos(angle) * r;
            pPos[i*3+1] = (Math.random() - 0.5) * 15; 
            pPos[i*3+2] = Math.sin(angle) * r;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        
        const particlesMat = new THREE.PointsMaterial({
            color: currentTheme.color, // Particulas del color del tema
            size: 2.5,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        const orbitalParticles = new THREE.Points(particlesGeo, particlesMat);
        scene.add(orbitalParticles);


        // 
        // CAMERA TRAVEL LOGIC
        // 
        let isTraveling = false;
        let flightStartPos = new THREE.Vector3();
        let flightTargetPos = new THREE.Vector3();
        let flightStartLook = new THREE.Vector3();
        let flightTargetLook = new THREE.Vector3();
        let flightStartTime = 0;
        const flightDuration = 1500; // ms

        function flyTo(targetObj, zoomDist = 60) {
            isTraveling = true;
            flightStartTime = Date.now();
            flightStartPos.copy(camera.position);
            flightStartLook.copy(controls.target);

            // Determinar destino
            const targetCenter = targetObj.position.clone();
            
            // Si es un grupo (Singularity), asegurar posici贸n absoluta 0,0,0 si es est谩tico, 
            // o calcular bounding box si fuera movil. Aqu铆 asumimos 0,0,0 para la singularidad.
            if (targetObj === centralSingularity) {
                targetCenter.set(0,0,0);
                zoomDist = 150; // M谩s lejos para el agujero negro
            }

            flightTargetLook.copy(targetCenter);

            // Calcular posici贸n de c谩mara final:
            // Mantener 谩ngulo actual pero acercarse
            const offset = new THREE.Vector3().subVectors(camera.position, targetCenter).normalize().multiplyScalar(zoomDist);
            flightTargetPos.addVectors(targetCenter, offset);

            // Desactivar auto-rotaci贸n durante el viaje
            controls.autoRotate = false;
        }

        function updateTravel() {
            if (!isTraveling) return;

            const now = Date.now();
            const progress = (now - flightStartTime) / flightDuration;

            if (progress >= 1) {
                // Fin del viaje
                camera.position.copy(flightTargetPos);
                controls.target.copy(flightTargetLook);
                isTraveling = false;
                // Reactivar rotaci贸n suave si se desea
                controls.autoRotate = true; 
                return;
            }

            // Easing: Quadratic Ease In-Out
            const ease = progress < 0.5 ? 2 * progress * progress : -1 + (4 - 2 * progress) * progress;

            camera.position.lerpVectors(flightStartPos, flightTargetPos, ease);
            controls.target.lerpVectors(flightStartLook, flightTargetLook, ease);
        }

        // 
        // ANIMACIN & INTERACCIN
        // 
        let startTime = Date.now();
        const collapseDuration = 2000; // ms

        // Raycasting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');

        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Tooltip sigue al mouse
            tooltip.style.left = (event.clientX + 20) + 'px';
            tooltip.style.top = (event.clientY + 20) + 'px';
            
            // Cursor pointer si hover sobre interactuable
            if (hoveredNode) {
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'default';
            }
        });

        let hoveredNode = null;

        let prevPos = new THREE.Vector3().copy(camera.position);
        const dirVal = document.getElementById('dir-val');

        function animate() {
            requestAnimationFrame(animate);
            
            if (isTraveling) {
                updateTravel();
                controls.update(); // Importante para actualizar los vectores internos
            } else {
                controls.update();
            }

            const now = Date.now();
            const timeInfo = now * 0.001;

            // UPDATE SHADER UNIFORMS
            if (warpMat) {
                warpMat.uniforms.time.value = timeInfo;
                
                // EFECTOS ESPECIALES POR MODO
                if (currentTheme.name === "MODO MAPUCHE_COSMICO") {
                     // Efecto especial latido lento para Mapuche
                     warpMat.uniforms.accentColor.value.setHSL(0.8, 1.0, 0.5 + Math.sin(timeInfo) * 0.2); 
                } 
                else if (currentTheme.name === "MODO NAVE_ESPACIAL") {
                    //  EFECTO INTERSTELLAR: ONDAS ESPACIALES INTENSAS
                    // Aumentamos velocidad simulada multiplicando el tiempo en el seno ? 
                    // No podemos cambiar el vertex shader al vuelo facil, pero si los uniformes.
                    // Vamos a hacer que el color pulse rapid铆simo y brillante, simulando viaje.
                    const warpSpeed = timeInfo * 5.0; // Velocidad Warp
                    warpMat.uniforms.accentColor.value.setHSL(0.3, 1.0, 0.5 + Math.sin(warpSpeed) * 0.4);
                    // Nota: para cambiar la geometr铆a/onda real requerir铆a otro shader, 
                    // pero visualmente esto + el movimiento de c谩mara da el efecto.
                }
            }

            const progress = Math.min(1, (now - startTime) / collapseDuration);
            
            // Easing cubic out
            const ease = 1 - Math.pow(1 - progress, 3);
            
            // 0. PULSO SINGULARIDAD
            if (typeof singularityMesh !== 'undefined') {
                 const pulseScale = 1.0 + Math.sin(now * 0.001) * 0.05;
                 singularityMesh.scale.set(pulseScale, pulseScale, pulseScale);
            }

            // 1. ANIMACIN DE COLAPSO (Intro)
            if (progress < 1) {
                for (let id in nodeMeshes) {
                    const mesh = nodeMeshes[id];
                    const currentPos = new THREE.Vector3().copy(mesh.userData.targetPos).normalize().multiplyScalar(2000).lerp(mesh.userData.targetPos, ease);
                    mesh.position.copy(currentPos);
                }
            }

            // 2. ACTUALIZAR ARISTAS
            if (progress < 1) {
                edgeMeshes.forEach(line => {
                    const pos = line.geometry.attributes.position;
                    pos.setXYZ(0, line.userData.source.position.x, line.userData.source.position.y, line.userData.source.position.z);
                    pos.setXYZ(1, line.userData.target.position.x, line.userData.target.position.y, line.userData.target.position.z);
                    pos.needsUpdate = true;
                });
            } else {
                const pulse = 0.5 + Math.sin(now * 0.005) * 0.5;
                if (lineMaterialFusion) {
                    lineMaterialFusion.opacity = 0.4 + pulse * 0.6;
                }
            }

            // 2.5 ROTACIN DEL CRYSTAL CORE (NUEVO)
            if (typeof crystalMesh !== 'undefined') {
                crystalMesh.rotation.y = now * 0.0002;
                crystalMesh.rotation.z = now * 0.0001;
            }

            // 3. ROTACIN DE PARTCULAS
            orbitalParticles.rotation.y = now * 0.0003;

            // 4. INTERACCIN (RAYCAST)
            raycaster.setFromCamera(mouse, camera);
            
            // Intersectar nodos Y singularidad (Black Hole)
            const raycastTargets = [...Object.values(nodeMeshes), ...centralSingularity.children]; // children[0] es blackHole mesh
            const intersects = raycaster.intersectObjects(raycastTargets);

            if (intersects.length > 0) {
                const obj = intersects[0].object;
                
                // Si es el agujero negro
                if (obj.parent === centralSingularity) {
                    if (hoveredNode !== centralSingularity) {
                        hoveredNode = centralSingularity;
                        tooltip.innerHTML = `
                            <div class="tooltip-header" style="color:#ff0000">SINGULARIDAD</div>
                            <div style="font-size:0.8rem; color:#ddd;">Gargantua Refined</div>
                            <div class="tooltip-row"><span>Event Horizon:</span> <span class="tooltip-val" style="color:#ff0000">CRITICAL</span></div>
                            <div style="font-size:0.7rem; color:#888; margin-top:4px;">Click para viajar al vac铆o</div>
                        `;
                        tooltip.style.display = 'block';
                    }
                } 
                // Si es un nodo
                else { 
                     if (hoveredNode !== obj) {
                        // Restaurar previo
                        if (hoveredNode && hoveredNode !== centralSingularity) {
                            hoveredNode.material.color.copy(hoveredNode.userData.originalColor);
                        }
                        
                        hoveredNode = obj;
                        hoveredNode.material.color.set(0xffffff);
                        
                        const d = obj.userData;
                        
                        // Modificar tooltip para mostrar tema si aplica
                        let themeBadge = currentTheme.name !== "ABISMO DEFAULT" ? `<span style="color:${currentTheme.color.getHexString()}">[${currentTheme.emoji}]</span>` : "";
                        
                        tooltip.innerHTML = `
                            <div class="tooltip-header">${currentTheme.emoji} ${d.label}</div>
                            <div style="font-size:0.8rem; margin-bottom:6px; color:#ddd;">${d.desc || 'Unknown Dimension'}</div>
                            <div class="tooltip-row"><span>Horror:</span> <span class="tooltip-val">${(d.horror||0).toFixed(1)}</span></div>
                             <div style="font-size:0.7rem; color:#888; margin-top:4px;">Click para viajar</div>
                        `;
                        tooltip.style.display = 'block';
                    }
                }
            } else {
                if (hoveredNode) {
                    if (hoveredNode !== centralSingularity) {
                        hoveredNode.material.color.copy(hoveredNode.userData.originalColor);
                    }
                    hoveredNode = null;
                    tooltip.style.display = 'none';
                }
            }

            // 5. MOTION HUD
            const delta = camera.position.distanceTo(prevPos);
            if (delta > 0.3) {
                const dz = camera.position.z - prevPos.z;
                const dx = camera.position.x - prevPos.x;
                const dy = camera.position.y - prevPos.y;

                let dir = "STABLE";
                if (Math.abs(dz) > Math.abs(dx) && Math.abs(dz) > Math.abs(dy)) {
                    dir = dz > 0 ? "RETROCESO" : "AVANCE";
                } else if (Math.abs(dx) > Math.abs(dy)) {
                    dir = dx > 0 ? "PAN DERECHA" : "PAN IZQUIERDA";
                } else {
                    dir = dy > 0 ? "SUBIENDO" : "BAJANDO";
                }
                dirVal.innerText = dir;
            } else {
                dirVal.innerText = "ESTABLE";
            }
            prevPos.copy(camera.position);

            // RENDER CON COMPOSER (BLOOM)
            composer.render();
        }

        animate();

        // 6. INTERACCIN CLICK (Viajar & Highlight)
        // Definir materiales globales
        const matHighlight = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 1.0, transparent: true, linewidth: 2 });
        const matDim = new THREE.LineBasicMaterial({ color: 0x333333, opacity: 0.05, transparent: true });

        window.addEventListener('click', (event) => {
            if (!raycaster || !mouse) return;
            
            // Recalcular mouse por si acaso (aunque se actualiza en move)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            
            const raycastTargets = [...Object.values(nodeMeshes), ...centralSingularity.children];
            const intersects = raycaster.intersectObjects(raycastTargets);
            
            const resetLines = () => {
                edgeMeshes.forEach(line => {
                    line.material = line.userData.isDimensional ? lineMaterialFusion : lineMaterialNormal;
                });
            };

            if (intersects.length > 0) {
                const obj = intersects[0].object;

                // CLICK EN BLACK HOLE
                if (obj.parent === centralSingularity) {
                    console.log("Viajando a la Singularidad...");
                    flyTo(centralSingularity);
                    // Reset selecciones de nodos
                    if (selectedNodeId && nodeMeshes[selectedNodeId]) {
                        nodeMeshes[selectedNodeId].material.color.copy(nodeMeshes[selectedNodeId].userData.originalColor);
                        selectedNodeId = null;
                    }
                    resetLines();
                    return;
                }

                // CLICK EN NODO
                // ...existing interaction logic + flyTo...
                
                // Toggle Highlight
                if (selectedNodeId === obj.userData.id) {
                    // Deselect
                    obj.material.color.copy(obj.userData.originalColor);
                    selectedNodeId = null;
                    resetLines(); 
                } else {
                    // Deselect prev
                    if (selectedNodeId && nodeMeshes[selectedNodeId]) {
                        nodeMeshes[selectedNodeId].material.color.copy(nodeMeshes[selectedNodeId].userData.originalColor);
                    }
                    
                    selectedNodeId = obj.userData.id;
                    obj.material.color.set(0xffffff); 
                    
                    // VIAJAR AL NODO
                    flyTo(obj);

                    // HIGHLIGHT CONEXIONES
                    resetLines(); 
                    
                    let connectedCount = 0;
                    edgeMeshes.forEach(line => {
                        if (line.userData.source === obj || line.userData.target === obj) {
                            line.material = matHighlight;
                            connectedCount++;
                        } else {
                             line.material = matDim;
                        }
                    });
                    
                    console.log(`Nodo seleccionado: ${obj.userData.label} | Conexiones: ${connectedCount}`);
                }
            } else {
                // Click en vacio -> Deseleccionar
                if (selectedNodeId && nodeMeshes[selectedNodeId]) {
                    nodeMeshes[selectedNodeId].material.color.copy(nodeMeshes[selectedNodeId].userData.originalColor);
                    selectedNodeId = null;
                }
                resetLines();
            }
        });

        // 
        // UTILS & LISTENERS
        // 
        window.toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else {
                document.exitFullscreen();
            }
        };
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        window.resetCamera = () => {
            camera.position.set(0, 120, 700);
            controls.target.set(0,0,0);
            controls.update();
        };

        window.addEventListener('message', (event) => {
            if (event.data && event.data.action === 'resetCamera') {
                window.resetCamera();
            }
        });

        // Asegurarse de quitar loading screen si existiera en parent (opcional)
        console.log("Brain 3D: Rendering iniciado.");

        // 
        // REPORTING INICIAL HUD
        // 
        document.getElementById('node-count').innerText = nodesData.length;
        document.getElementById('edge-count').innerText = edgesData.length;
        
        // 
        // RESOURCE MONITORING (FPS & POLL)
        // 
        let lastFrameTime = performance.now();
        let frameCount = 0;
        const fpsEl = document.getElementById('fps-val');
        
        function updateFPS() {
            const now = performance.now();
            frameCount++;
            if (now - lastFrameTime >= 1000) {
                fpsEl.innerText = frameCount;
                fpsEl.style.color = frameCount < 30 ? '#ff0000' : (frameCount < 50 ? '#ffff00' : '#00ff00');
                frameCount = 0;
                lastFrameTime = now;
            }
            requestAnimationFrame(updateFPS);
        }
        updateFPS();

        // Polling Server Resources
        setInterval(() => {
            const startPing = Date.now();
            fetch('/api/resources')
                .then(r => r.json())
                .then(data => {
                    const ping = Date.now() - startPing;
                    document.getElementById('ping-val').innerText = ping + 'ms';
                    
                    const cpuEl = document.getElementById('cpu-val');
                    const ramEl = document.getElementById('ram-val');
                    
                    cpuEl.innerText = data.cpu + '%';
                    ramEl.innerText = data.ram_used + 'GB';
                    
                    // Alerta visual si carga alta
                    cpuEl.style.color = data.cpu > 80 ? '#ff0000' : '#00aaff';
                })
                .catch(err => console.error("Monitor error:", err));
        }, 2000);

        // Actualizar etiqueta de modo
        const hasFusionData = nodesData.some(n => n.seed_index && n.seed_index > 0);
        const modeLabel = document.getElementById('mode-label');
        if (modeLabel && modeData) {
             const vizType = hasFusionData ? "FUSIN CSMICA" : "ABISMO SINGULAR";
             const modeName = modeData.nombre || "DESCONOCIDO";
             const emoji = modeData.info ? modeData.info.emoji : "";
             const color = modeData.info ? modeData.info.color : "#ffffff";
             
             modeLabel.innerHTML = `${vizType} <span style="color:#666">|</span> <span style="color:${color}">${emoji} ${modeName}</span>`;
        }

        // 
        // SPIKE VISUAL EFFECT (IONIC CHANNELS)
        // 
        window.addEventListener('message', (event) => {
            if (event.data.type === 'spike') {
                trigger3DSpike(event.data.color || '#ffffff');
            }
        });

        function trigger3DSpike(colorHex) {
            const spikeColor = new THREE.Color(colorHex);
            const originalColors = new Map();

            // 1. Flash Singularity node
            if (nodeMeshes["CERO_ABSOLUTO"]) {
                const center = nodeMeshes["CERO_ABSOLUTO"];
                center.scale.set(3, 3, 3);
                setTimeout(() => center.scale.set(1, 1, 1), 500);
            }

            // 2. Pulse all nodes brightness
            Object.values(nodeMeshes).forEach(mesh => {
                if (mesh.material && mesh.material.color) {
                    originalColors.set(mesh, mesh.material.color.clone());
                    mesh.material.color.set(spikeColor);
                    
                    // Shake a little
                    mesh.position.x += (Math.random() - 0.5) * 10;
                    mesh.position.y += (Math.random() - 0.5) * 10;
                }
            });

            // 3. Restore after delay
            setTimeout(() => {
                Object.values(nodeMeshes).forEach(mesh => {
                    if (originalColors.has(mesh)) {
                        mesh.material.color.copy(originalColors.get(mesh));
                    }
                });
            }, 600);
        }
    </script>
</body>
</html>